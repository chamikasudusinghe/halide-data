Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50003_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
In random expression: uint32(uint16(max(sliced$1(_0, _1, _2), sliced$1(_0 + -1, _1, _2))))
The following expressions were unused:
sliced$1(_0 + 1, _1, _2)
In random expression: (let t16 = sliced$1(_0 + 1, _1, _2) in t16)
The following expressions were unused:
sliced$1(_0, _1, _2)
sliced$1(_0 + -1, _1, _2)
In random expression: (let t17 = sliced$1(_0 + -1, _1, _2) in t17)
The following expressions were unused:
sliced$1(_0, _1, _2)
sliced$1(_0 + 1, _1, _2)
In random expression: (sliced$1(_0, _1, _2)/sliced$1(_0 + -1, _1, _2))
The following expressions were unused:
sliced$1(_0 + 1, _1, _2)
In random expression: (uint1)1
The following expressions were unused:
sliced$1(_0, _1, _2)
sliced$1(_0 + -1, _1, _2)
sliced$1(_0 + 1, _1, _2)
In random expression: int16((sliced$1(_0 + 1, _1, _2) + sliced$1(_0, _1, _2)))
The following expressions were unused:
sliced$1(_0 + -1, _1, _2)
In random expression: (sliced$1(_0 + 1, _1, _2)/sliced$1(_0 + -1, _1, _2))
The following expressions were unused:
sliced$1(_0, _1, _2)
In random expression: int16(int8((sliced$1(_0 + 1, _1, _2)/sliced$1(_0, _1, _2))))
The following expressions were unused:
sliced$1(_0 + -1, _1, _2)
In random expression: 0
The following expressions were unused:
sliced$1(_0, _1, _2)
sliced$1(_0 + -1, _1, _2)
sliced$1(_0 + 1, _1, _2)
In random expression: (let t20 = sliced$1(_0, _1, _2) in t20)
The following expressions were unused:
sliced$1(_0 + -1, _1, _2)
sliced$1(_0 + 1, _1, _2)
(((0 + sliced$1(_0 + -1, _1, _2)) + sliced$1(_0, _1, _2)) + sliced$1(_0 + 1, _1, _2))
int16(min(mirror_interior(_0, _1, _2), upsampled_linear__1$1(_0, _1, _2)))
(let t26 = all(_0, _1, _2) in (let t27 = all_r$2(_0, _1, _2) in ((t27 + int32((t26 == t27)))*t27)))
(all$1(_0, _1, _2) + binary_op$1(_0, _1, _2))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Inlining upsampled_linear__1$2
Inlining upsampled_linear__0
Injecting realization of { all_r$3 }
Injecting realization of { downsampled_box__0 }
Injecting realization of { pool2D_r__0_1 }
Injecting realization of { binary_op$1 }
Injecting realization of { all_r$2 }
Injecting realization of { all }
Injecting realization of { relu }
Inlining mirror_interior
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required.s = let t824 = (input.extent.0 + input.min.0) in (let t825 = (casted.extent.0 + casted.min.0) in (let t826 = (((t824 + -1) <= ((casted.min.0/32)*32)) || ((((t825 + 31)/32)*32) < (input.min.0 + -36))) in (let t827 = max(min((((t825 + 31)/32)*32) + 37, t824) + -1, input.min.0) in (let t828 = (((t824 + -36) <= (((t825 + 31)/32)*32)) || (((casted.min.0/32)*32) < (input.min.0 + -1))) in (let t829 = (input.min.0 + (input.extent.0 - int32(max(uint32((input.extent.0 + -1)), uint32(((max(1 - (input.extent.0*2), max(input.extent.0*2, 3) + -3) - input.extent.0) + 1)))))) in (let t830 = max(min(((casted.min.0/32)*32) + 2, t824) + -1, input.min.0) in (max(select(t826, t824 + -1, t827), select(t828, t824 + -1, t827)) - min(select(t826, t829 + -1, t830), select(t828, t829 + -1, t830)))))))))
let input.min.0.required = let t831 = (input.extent.0 + input.min.0) in (let t832 = (casted.extent.0 + casted.min.0) in (let t833 = (input.min.0 + (input.extent.0 - int32(max(uint32((input.extent.0 + -1)), uint32(((max(1 - (input.extent.0*2), max(input.extent.0*2, 3) + -3) - input.extent.0) + 1)))))) in (let t834 = max(min(((casted.min.0/32)*32) + 2, t831) + -1, input.min.0) in min(select(((t831 + -1) <= ((casted.min.0/32)*32)) || ((((t832 + 31)/32)*32) < (input.min.0 + -36)), t833 + -1, t834), select(((t831 + -36) <= (((t832 + 31)/32)*32)) || (((casted.min.0/32)*32) < (input.min.0 + -1)), t833 + -1, t834)))))
let input.extent.1.required.s = let t835 = (input.extent.1 + input.min.1) in (let t836 = (casted.extent.1 + casted.min.1) in (let t837 = (((t835 + 3) <= ((casted.min.1/4)*4)) || ((((t836 + 3)/4)*4) < (input.min.1 + -4))) in (let t838 = max(min((((t836 + 3)/4)*4) + 5, t835) + -1, input.min.1) in (let t839 = (((t835 + -4) <= (((t836 + 3)/4)*4)) || (((casted.min.1/4)*4) < (input.min.1 + 3))) in (let t840 = (input.min.1 + (input.extent.1 - int32(max(uint32((input.extent.1 + -1)), uint32(((max(1 - (input.extent.1*2), max(input.extent.1*2, 3) + -3) - input.extent.1) + 1)))))) in (let t841 = max(min((casted.min.1/4)*4, t835 + 2) + -3, input.min.1) in (max(select(t837, t835 + -1, t838), select(t839, t835 + -1, t838)) - min(select(t837, t840 + -1, t841), select(t839, t840 + -1, t841)))))))))
let input.min.1.required = let t842 = (input.extent.1 + input.min.1) in (let t843 = (casted.extent.1 + casted.min.1) in (let t844 = (input.min.1 + (input.extent.1 - int32(max(uint32((input.extent.1 + -1)), uint32(((max(1 - (input.extent.1*2), max(input.extent.1*2, 3) + -3) - input.extent.1) + 1)))))) in (let t845 = max(min((casted.min.1/4)*4, t842 + 2) + -3, input.min.1) in min(select(((t842 + 3) <= ((casted.min.1/4)*4)) || ((((t843 + 3)/4)*4) < (input.min.1 + -4)), t844 + -1, t845), select(((t842 + -4) <= (((t843 + 3)/4)*4)) || (((casted.min.1/4)*4) < (input.min.1 + 3)), t844 + -1, t845)))))
let input.extent.2.required.s = let t846 = (input.extent.2 + input.min.2) in (let t847 = ((t846 <= 0) || (2 < input.min.2)) in (let t848 = max(min(t846, 3) + -1, input.min.2) in (let t849 = ((t846 <= 2) || (0 < input.min.2)) in (let t850 = (input.min.2 + (input.extent.2 - int32(max(uint32((input.extent.2 + -1)), uint32(((max(1 - (input.extent.2*2), max(input.extent.2*2, 3) + -3) - input.extent.2) + 1)))))) in (let t851 = max(min(t846, 1) + -1, input.min.2) in (max(select(t847, t846 + -1, t848), select(t849, t846 + -1, t848)) - min(select(t847, t850 + -1, t851), select(t849, t850 + -1, t851))))))))
let input.min.2.required = let t852 = (input.extent.2 + input.min.2) in (let t853 = (input.min.2 + (input.extent.2 - int32(max(uint32((input.extent.2 + -1)), uint32(((max(1 - (input.extent.2*2), max(input.extent.2*2, 3) + -3) - input.extent.2) + 1)))))) in (let t854 = max(min(t852, 1) + -1, input.min.2) in min(select((t852 <= 0) || (2 < input.min.2), t853 + -1, t854), select((t852 <= 2) || (0 < input.min.2), t853 + -1, t854))))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 let relu._1.extent_realized.s = (((casted.extent.1 + casted.min.1) + 3)/4) - (casted.min.1/4)
 let relu._0.extent_realized.s = (((casted.extent.0 + casted.min.0) + 31)/32) - (casted.min.0/32)
 let relu.stride.2 = ((relu._0.extent_realized.s*32) + 36)*((relu._1.extent_realized.s*4) + 8)
 allocate relu[int16 * ((relu._0.extent_realized.s*32) + 36) * ((relu._1.extent_realized.s*4) + 8) * 3]
 produce relu {
  let t529 = (casted.min.0/32)*32
  let t530 = (casted.min.1/4)*4
  let t515 = max(min(input.min.2, 3), 0)
  let t516 = relu._1.extent_realized.s*4
  let t517 = relu._0.extent_realized.s*32
  let t524 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (relu.s0._2, 0, t515) {
   let t539 = input.extent.2 + input.min.2
   let t538 = relu.s0._2*relu.stride.2
   let t531 = (select((t539 <= relu.s0._2) || (relu.s0._2 < input.min.2), (t539 - int32((uint32)abs((((relu.s0._2 - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t539 + -1, relu.s0._2), input.min.2))*input.stride.2) - t524
   for (relu.s0._1.rebased, 0, t516 + 8) {
    let t547 = input.extent.1 + input.min.1
    let t542 = t547 - int32((uint32)abs((((((t530 - input.min.1) + relu.s0._1.rebased) + -3) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
    let t546 = ((t517 + 36)*relu.s0._1.rebased) + t538
    let t540 = relu.s0._1.rebased + t530
    for (relu.s0._0.rebased, 0, t517 + 36) {
     let t464 = relu.s0._0.rebased + t529
     let t855 = input.extent.0 + input.min.0
     relu[relu.s0._0.rebased + t546] = max(int16(input[select(((t855 + -1) <= t464) || (t464 < (input.min.0 + -1)), (t855 - int32((uint32)abs((((((t529 - input.min.0) + relu.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t855, t464 + 2) + -1, input.min.0)) + ((select(((t547 + 3) <= t540) || (t540 < (input.min.1 + 3)), t542 + -1, max(min(t547 + 2, t540) + -3, input.min.1))*input.stride.1) + t531)]), (int16)0)
    }
   }
  }
  let t568 = input.extent.0 + input.min.0
  let t569 = input.extent.1 + input.min.1
  let t570 = input.min.2*input.stride.2
  let t571 = input.min.1*input.stride.1
  let t572 = casted.min.0/32
  let t573 = t572*32
  let t574 = casted.min.1/4
  let t575 = t574*4
  let t576 = max(min(input.min.2, 3), 0)
  let t577 = (relu._0.extent_realized.s + t572)*32
  let t578 = (relu._1.extent_realized.s + t574)*4
  let t579 = max(t573 + 1, input.min.0)
  let t580 = t577 + 37
  let t581 = max(t575 + -3, input.min.1)
  let t582 = t578 + 5
  let t550 = min(max(t569, t581), t582)
  let t563 = min(max(t568, t579), t580)
  let t549 = min(t581, t582)
  let t562 = min(t579, t580)
  let t552 = relu._0.extent_realized.s*32
  let t548 = max(min(input.extent.2 + input.min.2, 3), 0) - t576
  let t557 = (t570 + t571) + input.min.0
  for (relu.s0._2.rebased, 0, t548) {
   let t583 = t549 - t575
   let t584 = relu.s0._2.rebased + t576
   for (relu.s0._1.rebased, 0, t583 + 3) {
    let t590 = (input.stride.2*t584) - t557
    let t591 = t569 - int32((uint32)abs((((((t575 - input.min.1) + relu.s0._1.rebased) + -3) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
    let t594 = (relu.stride.2*t584) + ((t552 + 36)*relu.s0._1.rebased)
    let t589 = relu.s0._1.rebased + t575
    for (relu.s0._0.rebased, 0, t552 + 36) {
     let t469 = relu.s0._0.rebased + t573
     relu[relu.s0._0.rebased + t594] = max(int16(input[select(((t568 + -1) <= t469) || (t469 < (input.min.0 + -1)), (t568 - int32((uint32)abs((((((t573 - input.min.0) + relu.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t469 + 2, t568) + -1, input.min.0)) + ((select(((t569 + 3) <= t589) || (t589 < (input.min.1 + 3)), t591 + -1, max(min(t569 + 2, t589) + -3, input.min.1))*input.stride.1) + t590)]), (int16)0)
    }
   }
   let t602 = ((t562 - t570) - t571) - input.min.0
   let t603 = t577 - t563
   let t601 = t563 - t562
   let t596 = t562 - t573
   let t595 = t550 - t549
   let t600 = t549 - t575
   let t597 = relu.s0._2.rebased + t576
   for (relu.s0._1.rebased, 0, t595) {
    let t606 = ((relu.s0._1.rebased + t549)*input.stride.1) + ((input.stride.2*t597) - t557)
    let t609 = (relu.stride.2*t597) + (((relu.s0._1.rebased + t600) + 3)*(t552 + 36))
    for (relu.s0._0.rebased, 0, t596 + -1) {
     let t472 = relu.s0._0.rebased + t573
     relu[relu.s0._0.rebased + t609] = max(int16(input[select(((t568 + -1) <= t472) || (t472 < (input.min.0 + -1)), (t568 - int32((uint32)abs((((((t573 - input.min.0) + relu.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t472 + 2, t568) + -1, input.min.0)) + t606]), (int16)0)
    }
    let t611 = (((relu.s0._1.rebased + t600) + 3)*(t552 + 36)) + ((relu.stride.2*t597) + t596)
    let t610 = ((relu.s0._1.rebased + t549)*input.stride.1) + ((input.stride.2*t597) + t602)
    for (relu.s0._0.rebased, 0, t601) {
     relu[(relu.s0._0.rebased + t611) + -1] = max(int16(input[relu.s0._0.rebased + t610]), (int16)0)
    }
    let t615 = (((relu.s0._1.rebased + t600) + 3)*(t552 + 36)) + ((relu.stride.2*t597) + (t563 - t573))
    let t612 = ((relu.s0._1.rebased + t549)*input.stride.1) + ((input.stride.2*t597) - t557)
    for (relu.s0._0.rebased, 0, t603 + 37) {
     let t475 = relu.s0._0.rebased + t563
     relu[(relu.s0._0.rebased + t615) + -1] = max(int16(input[select(t475 < t568, max(min(t568 + -1, t475), input.min.0), (t568 - int32((uint32)abs(((((t563 - input.min.0) + relu.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1) + t612]), (int16)0)
    }
   }
   let t616 = t578 - t550
   let t622 = t550 - t575
   let t617 = relu.s0._2.rebased + t576
   for (relu.s0._1.rebased, 0, t616 + 5) {
    let t624 = (input.stride.2*t617) - t557
    let t625 = t569 - int32((uint32)abs(((((t550 - input.min.1) + relu.s0._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
    let t628 = (relu.stride.2*t617) + (((relu.s0._1.rebased + t622) + 3)*(t552 + 36))
    let t623 = relu.s0._1.rebased + t550
    for (relu.s0._0.rebased, 0, t552 + 36) {
     let t481 = relu.s0._0.rebased + t573
     relu[relu.s0._0.rebased + t628] = max(int16(input[select(((t568 + -1) <= t481) || (t481 < (input.min.0 + -1)), (t568 - int32((uint32)abs((((((t573 - input.min.0) + relu.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t481 + 2, t568) + -1, input.min.0)) + ((select(t623 < t569, max(min(t569 + -1, t623), input.min.1), t625 + -1)*input.stride.1) + t624)]), (int16)0)
    }
   }
  }
  let t643 = input.extent.2 + input.min.2
  let t644 = (casted.min.0/32)*32
  let t645 = (casted.min.1/4)*4
  let t630 = relu._1.extent_realized.s*4
  let t631 = relu._0.extent_realized.s*32
  let t629 = 3 - max(min(t643, 3), 0)
  let t638 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (relu.s0._2.rebased, 0, t629) {
   let t646 = max(min(t643, 3), 0)
   for (relu.s0._1.rebased, 0, t630 + 8) {
    let t663 = input.extent.1 + input.min.1
    let t662 = (t631 + 36)*relu.s0._1.rebased
    let t658 = t663 - int32((uint32)abs((((((t645 - input.min.1) + relu.s0._1.rebased) + -3) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
    let t656 = t643 - int32((uint32)abs(((((t646 - input.min.2) + relu.s0._2.rebased) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))
    let t654 = relu.s0._2.rebased + t646
    let t655 = relu.s0._1.rebased + t645
    for (relu.s0._0.rebased, 0, t631 + 36) {
     let t488 = relu.s0._0.rebased + t644
     let t856 = input.extent.0 + input.min.0
     relu[((relu.stride.2*t654) + t662) + relu.s0._0.rebased] = max(int16(input[select(((t856 + -1) <= t488) || (t488 < (input.min.0 + -1)), (t856 - int32((uint32)abs((((((t644 - input.min.0) + relu.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t856, t488 + 2) + -1, input.min.0)) + ((select(((t663 + 3) <= t655) || (t655 < (input.min.1 + 3)), t658 + -1, max(min(t663 + 2, t655) + -3, input.min.1))*input.stride.1) + ((select(t654 < t643, max(min(t643 + -1, t654), input.min.2), t656 + -1)*input.stride.2) - t638))]), (int16)0)
    }
   }
  }
 }
 let all.stride.2 = ((relu._0.extent_realized.s*32) + 36)*((relu._1.extent_realized.s*4) + 8)
 allocate all[int32 * ((relu._0.extent_realized.s*32) + 36) * ((relu._1.extent_realized.s*4) + 8) * 5]
 produce all {
  consume relu {
   let t664 = relu._1.extent_realized.s*4
   let t665 = relu._0.extent_realized.s*32
   for (all.s0._2, 0, 5) {
    let t668 = all.s0._2*all.stride.2
    for (all.s0._1.rebased, 0, t664 + 8) {
     let t669 = (t665 + 36)*all.s0._1.rebased
     for (all.s0._0.rebased, 0, t665 + 36) {
      all[(t668 + t669) + all.s0._0.rebased] = ((all.s0._2 + 7)*int32(relu[(relu.stride.2 + t669) + all.s0._0.rebased])) + (((all.s0._2 + 10)*int32(relu[((relu.stride.2*2) + t669) + all.s0._0.rebased])) + ((all.s0._2 + 4)*int32(relu[all.s0._0.rebased + t669])))
     }
    }
   }
  }
 }
 free relu
 allocate binary_op$1[int32 * ((relu._0.extent_realized.s*32) + 36) * ((relu._1.extent_realized.s*4) + 8) * 5]
 produce binary_op$1 {
  consume all {
   let t694 = input.extent.0 + input.min.0
   let t695 = input.extent.1 + input.min.1
   let t696 = input.extent.2 + input.min.2
   let t697 = input.min.2*input.stride.2
   let t698 = input.min.1*input.stride.1
   let t699 = max(min(t696, 3), 0)
   let t700 = casted.min.0/32
   let t701 = t700*32
   let t702 = casted.min.1/4
   let t703 = t702*4
   let t704 = max(min(input.min.2, 3), 0)
   let t705 = (relu._0.extent_realized.s + t700)*32
   let t706 = (relu._1.extent_realized.s + t702)*4
   let t707 = max(t701 + 1, input.min.0)
   let t708 = t705 + 37
   let t709 = max(t703 + -3, input.min.1)
   let t710 = t706 + 5
   let t672 = min(max(t695, t709), t710)
   let t686 = min(max(t694, t707), t708)
   let t671 = min(t709, t710)
   let t685 = min(t707, t708)
   let t674 = relu._0.extent_realized.s*32
   let t690 = t699 - t704
   let t691 = 3 - t699
   let t681 = (t697 + t698) + input.min.0
   for (binary_op$1.s0._2, 0, 5) {
    let t717 = all.stride.2*binary_op$1.s0._2
    let t711 = t671 - t703
    for (binary_op$1.s0._1.rebased, 0, t711 + 3) {
     let t719 = t695 - int32((uint32)abs((((((t703 - input.min.1) + binary_op$1.s0._1.rebased) + -3) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
     let t723 = ((t674 + 36)*binary_op$1.s0._1.rebased) + t717
     let t718 = binary_op$1.s0._1.rebased + t703
     for (binary_op$1.s0._0.rebased, 0, t674 + 36) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t725 = (select(((t695 + 3) <= t718) || (t718 < (input.min.1 + 3)), t719 + -1, max(min(t695 + 2, t718) + -3, input.min.1))*input.stride.1) - t681
       let t726 = t694 - int32((uint32)abs((((((t701 - input.min.0) + binary_op$1.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t724 = binary_op$1.s0._0.rebased + t701
       for (all_r$2.s1.r193$x, 0, 3) {
        all_r$2[0] = all_r$2[0] + (input[(select((t696 <= all_r$2.s1.r193$x) || (all_r$2.s1.r193$x < input.min.2), (t696 - int32((uint32)abs((((all_r$2.s1.r193$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t696 + -1, all_r$2.s1.r193$x), input.min.2))*input.stride.2) + (select(((t694 + -1) <= t724) || (t724 < (input.min.0 + -1)), t726 + -1, max(min(t724 + 2, t694) + -1, input.min.0)) + t725)]*(((all_r$2.s1.r193$x*3) + binary_op$1.s0._2) + 4))
       }
      }
      consume all_r$2 {
       let t402 = all_r$2[0]
       let t403.s = binary_op$1.s0._0.rebased + t723
       binary_op$1[t403.s] = (t402 + int32((all[t403.s] == t402)))*t402
      }
      free all_r$2
     }
    }
    let t742 = all.stride.2*binary_op$1.s0._2
    let t743 = t685 - t701
    let t737 = max(min(t696, 3), 0)
    let t736 = ((t685 - t697) - t698) - input.min.0
    let t739 = t705 - t686
    let t735 = t686 - t685
    let t728 = t672 - t671
    let t734 = t671 - t703
    let t741 = (t686 - t701) + t742
    for (binary_op$1.s0._1.rebased, 0, t728) {
     let t744 = ((binary_op$1.s0._1.rebased + t671)*input.stride.1) - t681
     let t748 = (((binary_op$1.s0._1.rebased + t734) + 3)*(t674 + 36)) + t742
     for (binary_op$1.s0._0.rebased, 0, t743 + -1) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t750 = t694 - int32((uint32)abs((((((t701 - input.min.0) + binary_op$1.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t749 = binary_op$1.s0._0.rebased + t701
       for (all_r$2.s1.r193$x, 0, 3) {
        all_r$2[0] = all_r$2[0] + (input[(select((t696 <= all_r$2.s1.r193$x) || (all_r$2.s1.r193$x < input.min.2), (t696 - int32((uint32)abs((((all_r$2.s1.r193$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t696 + -1, all_r$2.s1.r193$x), input.min.2))*input.stride.2) + (select(((t694 + -1) <= t749) || (t749 < (input.min.0 + -1)), t750 + -1, max(min(t749 + 2, t694) + -1, input.min.0)) + t744)]*(((all_r$2.s1.r193$x*3) + binary_op$1.s0._2) + 4))
       }
      }
      consume all_r$2 {
       let t406 = all_r$2[0]
       let t407.s = binary_op$1.s0._0.rebased + t748
       binary_op$1[t407.s] = (t406 + int32((all[t407.s] == t406)))*t406
      }
      free all_r$2
     }
     let t755 = (((binary_op$1.s0._1.rebased + t734) + 3)*(t674 + 36)) + (t742 + t743)
     let t752 = ((binary_op$1.s0._1.rebased + t671)*input.stride.1) + t736
     for (binary_op$1.s0._0.rebased, 0, t735) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t756 = binary_op$1.s0._0.rebased + t752
       for (all_r$2.s1.r193$x, 0, t704) {
        all_r$2[0] = all_r$2[0] + (input[(select((t696 <= all_r$2.s1.r193$x) || (all_r$2.s1.r193$x < input.min.2), (t696 - int32((uint32)abs((((all_r$2.s1.r193$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t696 + -1, all_r$2.s1.r193$x), input.min.2))*input.stride.2) + t756]*(((all_r$2.s1.r193$x*3) + binary_op$1.s0._2) + 4))
       }
       let t758 = binary_op$1.s0._0.rebased + t752
       for (all_r$2.s1.r193$x.rebased, 0, t690) {
        let t499 = all_r$2.s1.r193$x.rebased + t704
        all_r$2[0] = all_r$2[0] + (input[(input.stride.2*t499) + t758]*(((t499*3) + binary_op$1.s0._2) + 4))
       }
       let t759 = binary_op$1.s0._0.rebased + t752
       for (all_r$2.s1.r193$x.rebased, 0, t691) {
        let t502 = all_r$2.s1.r193$x.rebased + t737
        all_r$2[0] = all_r$2[0] + (input[(select(t502 < t696, max(min(t696 + -1, t502), input.min.2), (t696 - int32((uint32)abs(((((t737 - input.min.2) + all_r$2.s1.r193$x.rebased) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1)*input.stride.2) + t759]*(((t502*3) + binary_op$1.s0._2) + 4))
       }
      }
      consume all_r$2 {
       let t410 = all_r$2[0]
       let t411 = binary_op$1.s0._0.rebased + t755
       binary_op$1[t411 + -1] = (t410 + int32((all[t411 + -1] == t410)))*t410
      }
      free all_r$2
     }
     let t762 = ((binary_op$1.s0._1.rebased + t671)*input.stride.1) - t681
     let t766 = (((binary_op$1.s0._1.rebased + t734) + 3)*(t674 + 36)) + t741
     for (binary_op$1.s0._0.rebased, 0, t739 + 37) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t768 = t694 - int32((uint32)abs(((((t686 - input.min.0) + binary_op$1.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t767 = binary_op$1.s0._0.rebased + t686
       for (all_r$2.s1.r193$x, 0, 3) {
        all_r$2[0] = all_r$2[0] + (input[(select((t696 <= all_r$2.s1.r193$x) || (all_r$2.s1.r193$x < input.min.2), (t696 - int32((uint32)abs((((all_r$2.s1.r193$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t696 + -1, all_r$2.s1.r193$x), input.min.2))*input.stride.2) + (select(t767 < t694, max(min(t694 + -1, t767), input.min.0), t768 + -1) + t762)]*(((all_r$2.s1.r193$x*3) + binary_op$1.s0._2) + 4))
       }
      }
      consume all_r$2 {
       let t414 = all_r$2[0]
       let t415 = binary_op$1.s0._0.rebased + t766
       binary_op$1[t415 + -1] = (t414 + int32((all[t415 + -1] == t414)))*t414
      }
      free all_r$2
     }
    }
    let t776 = all.stride.2*binary_op$1.s0._2
    let t770 = t706 - t672
    let t777 = t672 - t703
    for (binary_op$1.s0._1.rebased, 0, t770 + 5) {
     let t779 = t695 - int32((uint32)abs(((((t672 - input.min.1) + binary_op$1.s0._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
     let t783 = (((binary_op$1.s0._1.rebased + t777) + 3)*(t674 + 36)) + t776
     let t778 = binary_op$1.s0._1.rebased + t672
     for (binary_op$1.s0._0.rebased, 0, t674 + 36) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t785 = (select(t778 < t695, max(min(t695 + -1, t778), input.min.1), t779 + -1)*input.stride.1) - t681
       let t786 = t694 - int32((uint32)abs((((((t701 - input.min.0) + binary_op$1.s0._0.rebased) + 1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t784 = binary_op$1.s0._0.rebased + t701
       for (all_r$2.s1.r193$x, 0, 3) {
        all_r$2[0] = all_r$2[0] + (input[(select((t696 <= all_r$2.s1.r193$x) || (all_r$2.s1.r193$x < input.min.2), (t696 - int32((uint32)abs((((all_r$2.s1.r193$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t696 + -1, all_r$2.s1.r193$x), input.min.2))*input.stride.2) + (select(((t694 + -1) <= t784) || (t784 < (input.min.0 + -1)), t786 + -1, max(min(t784 + 2, t694) + -1, input.min.0)) + t785)]*(((all_r$2.s1.r193$x*3) + binary_op$1.s0._2) + 4))
       }
      }
      consume all_r$2 {
       let t419 = all_r$2[0]
       let t420.s = binary_op$1.s0._0.rebased + t783
       binary_op$1[t420.s] = (t419 + int32((all[t420.s] == t419)))*t419
      }
      free all_r$2
     }
    }
   }
  }
 }
 free all
 let pool2D_r__0_1.stride.2 = ((relu._0.extent_realized.s*8) + 8)*(relu._1.extent_realized.s + 1)
 allocate pool2D_r__0_1[int16 * ((relu._0.extent_realized.s*8) + 8) * (relu._1.extent_realized.s + 1) * 5]
 let pool2D_r__0_1.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 7)/4) - (casted.min.1/4)
 produce pool2D_r__0_1 {
  let t788 = relu._0.extent_realized.s*8
  for (pool2D_r__0_1.s0._2, 0, 5) {
   let t789 = pool2D_r__0_1.s0._2*pool2D_r__0_1.stride.2
   for (pool2D_r__0_1.s0._1.rebased, 0, pool2D_r__0_1.s0._1.loop_extent) {
    let t790 = ((t788 + 8)*pool2D_r__0_1.s0._1.rebased) + t789
    for (pool2D_r__0_1.s0._0.rebased, 0, t788 + 8) {
     pool2D_r__0_1[pool2D_r__0_1.s0._0.rebased + t790] = (int16)0
    }
   }
  }
  consume binary_op$1 {
   let t795 = casted.min.0/32
   let t792 = t795*32
   let t793 = t795*8
   let t794 = relu._0.extent_realized.s*32
   let t791 = relu._0.extent_realized.s*8
   for (pool2D_r__0_1.s1._2, 0, 5) {
    let t796 = pool2D_r__0_1.s1._2*pool2D_r__0_1.stride.2
    let t797 = (all.stride.2*pool2D_r__0_1.s1._2) - t792
    for (pool2D_r__0_1.s1._1.rebased, 0, pool2D_r__0_1.s0._1.loop_extent) {
     let t799 = pool2D_r__0_1.s1._1.rebased*4
     let t798 = ((t791 + 8)*pool2D_r__0_1.s1._1.rebased) + t796
     for (pool2D_r__0_1.s1._0.rebased, 0, t791 + 8) {
      let t801 = ((pool2D_r__0_1.s1._0.rebased + t793)*4) + t797
      let t800 = pool2D_r__0_1.s1._0.rebased + t798
      for (pool2D_r__0_1.s1.r216$y.rebased, 0, 8) {
       let t802 = ((pool2D_r__0_1.s1.r216$y.rebased + t799)*(t794 + 36)) + t801
       for (pool2D_r__0_1.s1.r216$x.rebased, 0, 8) {
        pool2D_r__0_1[t800] = pool2D_r__0_1[t800] + (int16(binary_op$1[pool2D_r__0_1.s1.r216$x.rebased + t802])/(int16)64)
       }
      }
     }
    }
   }
  }
  free binary_op$1
 }
 let downsampled_box__0.stride.2 = (relu._0.extent_realized.s + 1)*(relu._1.extent_realized.s + 1)
 allocate downsampled_box__0[int16 * (relu._0.extent_realized.s + 1) * (relu._1.extent_realized.s + 1) * 5]
 let downsampled_box__0.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 7)/4) - (casted.min.1/4)
 let downsampled_box__0.s0._0.loop_extent = (((casted.extent.0 + casted.min.0) + 63)/32) - (casted.min.0/32)
 produce downsampled_box__0 {
  consume pool2D_r__0_1 {
   for (downsampled_box__0.s0._2, 0, 5) {
    let t804 = downsampled_box__0.s0._2*pool2D_r__0_1.stride.2
    let t806 = downsampled_box__0.s0._2*downsampled_box__0.stride.2
    for (downsampled_box__0.s0._1.rebased, 0, downsampled_box__0.s0._1.loop_extent) {
     let t807 = (((relu._0.extent_realized.s*8) + 8)*downsampled_box__0.s0._1.rebased) + t804
     let t808 = ((relu._0.extent_realized.s + 1)*downsampled_box__0.s0._1.rebased) + t806
     for (downsampled_box__0.s0._0.rebased, 0, downsampled_box__0.s0._0.loop_extent) {
      let t425 = (downsampled_box__0.s0._0.rebased*8) + t807
      downsampled_box__0[downsampled_box__0.s0._0.rebased + t808] = pool2D_r__0_1[t425 + 1] + (pool2D_r__0_1[t425] + (pool2D_r__0_1[t425 + 2] + (pool2D_r__0_1[t425 + 3] + (pool2D_r__0_1[t425 + 4] + (pool2D_r__0_1[t425 + 5] + (pool2D_r__0_1[t425 + 7] + pool2D_r__0_1[t425 + 6]))))))
     }
    }
   }
  }
 }
 free pool2D_r__0_1
 produce casted {
  consume downsampled_box__0 {
   let t810 = casted.min.1/4
   let t809 = casted.min.0/32
   let t811 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t814 = casted.min.2 + casted.s0._2.rebased
    let t813 = (casted.stride.2*t814) + t811
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t817 = casted.min.1 + casted.s0._1.rebased
     let t815 = (t817/4) - t810
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$3[int32 * 4]
      produce all_r$3 {
       for (all_r$3.s0._1.rebased, 0, 2) {
        let t818 = all_r$3.s0._1.rebased*2
        for (all_r$3.s0._0.rebased, 0, 2) {
         all_r$3[all_r$3.s0._0.rebased + t818] = 0
        }
       }
       let t819 = ((casted.min.0 + casted.s0._0.rebased)/32) - t809
       for (all_r$3.s1._1.rebased, 0, 2) {
        let t820 = all_r$3.s1._1.rebased*2
        let t821 = ((all_r$3.s1._1.rebased + t815)*(relu._0.extent_realized.s + 1)) + t819
        for (all_r$3.s1._0.rebased, 0, 2) {
         let t823 = all_r$3.s1._0.rebased + t821
         let t822 = all_r$3.s1._0.rebased + t820
         for (all_r$3.s1.r233$x, 0, 5) {
          all_r$3[t822] = all_r$3[t822] + ((((all_r$3.s1.r233$x*5) + t814) + 6)*int32(downsampled_box__0[(all_r$3.s1.r233$x*downsampled_box__0.stride.2) + t823]))
         }
        }
       }
      }
      consume all_r$3 {
       let t513 = t817 % 4
       let t514 = (casted.min.0 + casted.s0._0.rebased) % 32
       casted[((casted.stride.1*t817) + t813) + casted.s0._0.rebased] = int32((int16((((4 - t513)*int32((int16(((all_r$3[0]*(32 - t514)) + (all_r$3[1]*t514)))/(int16)64))) + (t513*int32((int16(((all_r$3[2]*(32 - t514)) + (all_r$3[3]*t514)))/(int16)64)))))/(int16)8))
      }
      free all_r$3
     }
    }
   }
  }
 }
 free downsampled_box__0
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
add_temp_object_file: /tmp/8sY4KS/random_pipeline.a.o
Module.compile(): temporary object /tmp/8sY4KS/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50003_0/random_pipeline.a
file_unlink: /tmp/8sY4KS/random_pipeline.a.o
dir_rmdir: /tmp/8sY4KS
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50003_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50003_0/random_pipeline.registration.cpp
