Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50053_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(let t14 = repeat_edge(_0, _1, _2) in (t14/all_r$3(_0, _1, _2)))
In random expression: (let t27 = binary_op(_0, _1, _2) in ((t27*t27)*t27))
The following expressions were unused:
all_r$6(_0, _1, _2)
(let t28 = all_r$6(_0, _1, _2) in (max(binary_op(_0, _1, _2), t28)/t28))
(let t34 = conv2D_r__0_1(_0, _1, _2) in (let t35 = all_r$7(_0, _1, _2) in (t34 % t35)))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Inlining upsampled_linear__1
Injecting realization of { all_r$8 }
Injecting realization of { binary_op$2 }
Injecting realization of { conv2D_r__0_1 }
Injecting realization of { sliced$2 }
Injecting realization of { all_r$5 }
Inlining downsampled_nn__1$1
Injecting realization of { all_r$4 }
Injecting realization of { downsampled_nn__1 }
Inlining repeat_edge$6
Inlining lambda_6
Inlining int32_weights_im
Injecting realization of { all_r$7 }
Inlining downsampled_box__1$1
Injecting realization of { upsampled_nn__1 }
Injecting realization of { constant_exterior }
Inlining repeat_edge$7
Injecting realization of { sliced$1 }
Injecting realization of { conv_r__0 }
Injecting realization of { all_r$2 }
Injecting realization of { all }
Injecting realization of { all_r$1 }
Injecting realization of { pool2D_r__0_1 }
Injecting realization of { sliced }
Injecting realization of { all_r }
Inlining repeat_edge
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)int32_weights.buffer) != (uint64)0, halide_error_buffer_argument_is_null("int32_weights"))
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let int32_weights = (void *)_halide_buffer_get_host((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.min.3 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.extent.3 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.stride.3 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 3)
let all_r$1.s1._1.max = let t786 = (casted.extent.1 + casted.min.1) in max(min(((t786 + 23)/8)*8, 1999), max((t786 + 23)/8, 0)*8)
let all_r$1.s1._0.max.s = let t787 = (casted.extent.0 + casted.min.0) in max(min(t787, 1998), max(t787, -1) + 4)
let all_r$1.s1._0.min = let t788 = min(casted.min.0, 1999) in min(max(t788, 0), t788 + -3)
let input.extent.0.required = let t789 = (input.extent.0 + input.min.0) in (max(min(all_r$1.s1._0.max.s + 3, t789), input.min.0 + 1) - max(min(t789 + 2, all_r$1.s1._0.min) + -3, input.min.0))
let input.min.0.required = max(min((input.extent.0 + input.min.0) + 2, all_r$1.s1._0.min) + -3, input.min.0)
let input.extent.1.required = let t790 = (input.extent.1 + input.min.1) in (max(min(all_r$1.s1._1.max + 2, t790), input.min.1 + 1) - max(min(min((casted.min.1/8)*8, t790 + 2), 1999) + -3, input.min.1))
let input.min.1.required = max(min(min((casted.min.1/8)*8, (input.extent.1 + input.min.1) + 2), 1999) + -3, input.min.1)
let input.extent.2.required.s = let t791 = (input.extent.2 + input.min.2) in (min(t791, 3) - max(min(t791, 1) + -1, input.min.2))
let input.min.2.required = max(min(input.extent.2 + input.min.2, 1) + -1, input.min.2)
let int32_weights.min.0.required = max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0)
let int32_weights.extent.1.required.s = let t792 = (int32_weights.extent.1 + int32_weights.min.1) in (min(t792, 3) - max(min(t792, 1) + -1, int32_weights.min.1))
let int32_weights.min.1.required = max(min(int32_weights.extent.1 + int32_weights.min.1, 1) + -1, int32_weights.min.1)
let int32_weights.extent.2.required.s = let t793 = (int32_weights.extent.2 + int32_weights.min.2) in (min(t793, 3) - max(min(t793, 1) + -1, int32_weights.min.2))
let int32_weights.min.2.required = max(min(int32_weights.extent.2 + int32_weights.min.2, 1) + -1, int32_weights.min.2)
let int32_weights.extent.3.required.s = let t794 = (int32_weights.extent.3 + int32_weights.min.3) in (min(t794, 104) - max(min(t794, 1) + -1, int32_weights.min.3))
let int32_weights.min.3.required = max(min(int32_weights.extent.3 + int32_weights.min.3, 1) + -1, int32_weights.min.3)
let int32_weights.stride.3.required = max(int32_weights.extent.1.required.s, 1)*max(int32_weights.extent.2.required.s, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required, 0, input.min.2.required, max(input.extent.2.required.s, 1), input.extent.0.required*input.extent.1.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer)) {
 let t795 = max(int32_weights.extent.1.required.s, 1) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)int32_weights.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)int32_weights.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 4, (struct halide_dimension_t *)make_struct(int32_weights.min.0.required, 1, 1, 0, int32_weights.min.1.required, t795, 1, 0, int32_weights.min.2.required, max(int32_weights.extent.2.required.s, 1), t795, 0, int32_weights.min.3.required, max(int32_weights.extent.3.required.s, 1), int32_weights.stride.3.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(int32_weights.type == (uint32)73728, halide_error_bad_type("Input buffer int32_weights", int32_weights.type, (uint32)73728))
 assert(int32_weights.dimensions == 4, halide_error_bad_dimensions("Input buffer int32_weights", int32_weights.dimensions, 4))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && ((max(input.extent.2.required.s, 1) + input.min.2.required) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, (max(input.extent.2.required.s, 1) + input.min.2.required) + -1, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((int32_weights.min.0 <= int32_weights.min.0.required) && ((int32_weights.min.0.required + 1) <= (int32_weights.extent.0 + int32_weights.min.0)), halide_error_access_out_of_bounds("Input buffer int32_weights", 0, int32_weights.min.0.required, int32_weights.min.0.required, int32_weights.min.0, (int32_weights.extent.0 + int32_weights.min.0) + -1))
 assert(0 <= int32_weights.extent.0, halide_error_buffer_extents_negative("Input buffer int32_weights", 0, int32_weights.extent.0))
 assert((int32_weights.min.1 <= int32_weights.min.1.required) && ((max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) <= (int32_weights.extent.1 + int32_weights.min.1)), halide_error_access_out_of_bounds("Input buffer int32_weights", 1, int32_weights.min.1.required, (max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) + -1, int32_weights.min.1, (int32_weights.extent.1 + int32_weights.min.1) + -1))
 assert(0 <= int32_weights.extent.1, halide_error_buffer_extents_negative("Input buffer int32_weights", 1, int32_weights.extent.1))
 assert((int32_weights.min.2 <= int32_weights.min.2.required) && ((max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) <= (int32_weights.extent.2 + int32_weights.min.2)), halide_error_access_out_of_bounds("Input buffer int32_weights", 2, int32_weights.min.2.required, (max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) + -1, int32_weights.min.2, (int32_weights.extent.2 + int32_weights.min.2) + -1))
 assert(0 <= int32_weights.extent.2, halide_error_buffer_extents_negative("Input buffer int32_weights", 2, int32_weights.extent.2))
 assert((int32_weights.min.3 <= int32_weights.min.3.required) && ((max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) <= (int32_weights.extent.3 + int32_weights.min.3)), halide_error_access_out_of_bounds("Input buffer int32_weights", 3, int32_weights.min.3.required, (max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) + -1, int32_weights.min.3, (int32_weights.extent.3 + int32_weights.min.3) + -1))
 assert(0 <= int32_weights.extent.3, halide_error_buffer_extents_negative("Input buffer int32_weights", 3, int32_weights.extent.3))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(int32_weights.stride.0 == 1, halide_error_constraint_violated("int32_weights.stride.0", int32_weights.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let int32_weights.total_extent.1 = int64(int32_weights.extent.1)*int64(int32_weights.extent.0)
 let int32_weights.total_extent.2 = int32_weights.total_extent.1*int64(int32_weights.extent.2)
 let int32_weights.total_extent.3 = int32_weights.total_extent.2*int64(int32_weights.extent.3)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(uint64(int32_weights.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", uint64(int32_weights.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)), (uint64)2147483647))
 assert(int32_weights.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)), (uint64)2147483647))
 assert(int32_weights.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)), (uint64)2147483647))
 assert(int32_weights.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.3, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!int32_weights.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer int32_weights"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(int32_weights != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer int32_weights"))
 let sliced._1.extent_realized.s = all_r$1.s1._1.max - min((casted.min.1/8)*8, 1999)
 allocate sliced[int32 * ((all_r$1.s1._0.max.s - all_r$1.s1._0.min) + 6) * (sliced._1.extent_realized.s + 5) * 1]
 produce sliced {
  let sliced.s0._1.prologue = let t796 = min((casted.min.1/8)*8, 1999) in min(max(t796 + -3, input.min.1), (t796 + sliced._1.extent_realized.s) + 2)
  let sliced.s0._1.epilogue = let t797 = min((casted.min.1/8)*8, 1999) in min(max(max(t797 + -3, input.min.1), input.extent.1 + input.min.1), (t797 + sliced._1.extent_realized.s) + 2)
  let t315 = input.min.2*input.stride.2
  let t316 = input.min.1*input.stride.1
  let t317 = min((casted.min.1/8)*8, 1999)
  let t306 = sliced.s0._1.prologue - t317
  let t307 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
  let t310 = (t315 + t316) + input.min.0
  let t312 = input.extent.2 + input.min.2
  let t308 = input.extent.1 + input.min.1
  let t311 = input.extent.0 + input.min.0
  for (sliced.s0._1.rebased, 0, t306 + 3) {
   let t321 = max(min(t308 + 2, sliced.s0._1.rebased + t317) + -3, input.min.1)*input.stride.1
   let t320 = (t307 + 6)*sliced.s0._1.rebased
   let t318 = t321 - t310
   for (sliced.s0._0.rebased, 0, t307 + 6) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t322 = max(min(t311 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + t318
     for (all_r.s1.r85$x, 0, 3) {
      all_r[0] = all_r[0] + (input[(max(min(t312 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t322]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     sliced[sliced.s0._0.rebased + t320] = input[max(min(t311 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + (((((max(min(max(min(all_r[0], 2), 0), t312 + -1), input.min.2)*input.stride.2) - t315) - t316) - input.min.0) + t321)]
    }
    free all_r
   }
  }
  let t336 = input.extent.0 + input.min.0
  let t337 = input.extent.2 + input.min.2
  let t338 = input.min.2*input.stride.2
  let t339 = input.min.1*input.stride.1
  let t340 = max(min(t337, 3), 0)
  let t341 = max(min(input.min.2, 3), 0)
  let t342 = max(all_r$1.s1._0.min + -3, input.min.0)
  let t343 = all_r$1.s1._0.max.s + 3
  let t325 = min(max(t336, t342), t343)
  let t324 = min(t342, t343)
  let t334 = t340 - t341
  let t331 = sliced.s0._1.prologue - min((casted.min.1/8)*8, 1999)
  let t323 = sliced.s0._1.epilogue - sliced.s0._1.prologue
  let t335 = 3 - t340
  let t326 = (t338 + t339) + input.min.0
  for (sliced.s0._1.rebased, 0, t323) {
   let t348 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t347 = ((sliced.s0._1.rebased + t331) + 3)*((all_r$1.s1._0.max.s - all_r$1.s1._0.min) + 6)
   let t345 = t348 - t326
   let t344 = t324 - all_r$1.s1._0.min
   for (sliced.s0._0.rebased, 0, t344 + 3) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t349 = max(min(t336 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + t345
     for (all_r.s1.r85$x, 0, 3) {
      all_r[0] = all_r[0] + (input[(max(min(t337 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t349]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     sliced[sliced.s0._0.rebased + t347] = input[max(min(t336 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + (((((max(min(max(min(all_r[0], 2), 0), t337 + -1), input.min.2)*input.stride.2) - t338) - t339) - input.min.0) + t348)]
    }
    free all_r
   }
   let t355 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t352 = max(min(t337, 3), 0)
   let t350 = t325 - t324
   let t354 = (((sliced.s0._1.rebased + t331) + 3)*((all_r$1.s1._0.max.s - all_r$1.s1._0.min) + 6)) + (t324 - all_r$1.s1._0.min)
   let t351 = (((t324 - t338) - t339) - input.min.0) + t355
   for (sliced.s0._0.rebased, 0, t350) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t356 = sliced.s0._0.rebased + t351
     for (all_r.s1.r85$x, 0, t341) {
      all_r[0] = all_r[0] + (input[(max(min(t337 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t356]*((all_r.s1.r85$x*3) + 4))
     }
     let t357 = sliced.s0._0.rebased + t351
     for (all_r.s1.r85$x.rebased, 0, t334) {
      let t273 = all_r.s1.r85$x.rebased + t341
      all_r[0] = all_r[0] + (input[(input.stride.2*t273) + t357]*((t273*3) + 4))
     }
     let t358 = sliced.s0._0.rebased + t351
     for (all_r.s1.r85$x.rebased, 0, t335) {
      let t275 = all_r.s1.r85$x.rebased + t352
      all_r[0] = all_r[0] + (input[(max(min(t337 + -1, t275), input.min.2)*input.stride.2) + t358]*((t275*3) + 4))
     }
    }
    consume all_r {
     sliced[(sliced.s0._0.rebased + t354) + 3] = input[((((((max(min(max(min(all_r[0], 2), 0), t337 + -1), input.min.2)*input.stride.2) + t324) - t338) - t339) - input.min.0) + t355) + sliced.s0._0.rebased]
    }
    free all_r
   }
   let t363 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t360 = t363 - t326
   let t359 = all_r$1.s1._0.max.s - t325
   let t362 = (((sliced.s0._1.rebased + t331) + 3)*((all_r$1.s1._0.max.s - all_r$1.s1._0.min) + 6)) + (t325 - all_r$1.s1._0.min)
   for (sliced.s0._0.rebased, 0, t359 + 3) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t364 = max(min(t336 + -1, sliced.s0._0.rebased + t325), input.min.0) + t360
     for (all_r.s1.r85$x, 0, 3) {
      all_r[0] = all_r[0] + (input[(max(min(t337 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t364]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     sliced[(sliced.s0._0.rebased + t362) + 3] = input[max(min(t336 + -1, sliced.s0._0.rebased + t325), input.min.0) + (((((max(min(max(min(all_r[0], 2), 0), t337 + -1), input.min.2)*input.stride.2) - t338) - t339) - input.min.0) + t363)]
    }
    free all_r
   }
  }
  let t374 = input.min.2*input.stride.2
  let t375 = input.min.1*input.stride.1
  let t376 = min((casted.min.1/8)*8, 1999)
  let t365 = (sliced._1.extent_realized.s + t376) - sliced.s0._1.epilogue
  let t373 = sliced.s0._1.epilogue - t376
  let t366 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
  let t368 = (t374 + t375) + input.min.0
  let t370 = input.extent.2 + input.min.2
  let t367 = input.extent.1 + input.min.1
  let t369 = input.extent.0 + input.min.0
  for (sliced.s0._1.rebased, 0, t365 + 2) {
   let t380 = max(min(t367 + -1, sliced.s0._1.epilogue + sliced.s0._1.rebased), input.min.1)*input.stride.1
   let t379 = ((sliced.s0._1.rebased + t373) + 3)*(t366 + 6)
   let t377 = t380 - t368
   for (sliced.s0._0.rebased, 0, t366 + 6) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t381 = max(min(t369 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + t377
     for (all_r.s1.r85$x, 0, 3) {
      all_r[0] = all_r[0] + (input[(max(min(t370 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t381]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     sliced[sliced.s0._0.rebased + t379] = input[max(min(t369 + 2, all_r$1.s1._0.min + sliced.s0._0.rebased) + -3, input.min.0) + (((((max(min(max(min(all_r[0], 2), 0), t370 + -1), input.min.2)*input.stride.2) - t374) - t375) - input.min.0) + t380)]
    }
    free all_r
   }
  }
 }
 allocate pool2D_r__0_1[int16 * ((all_r$1.s1._0.max.s - all_r$1.s1._0.min) + 2) * (sliced._1.extent_realized.s + 1) * 1]
 produce pool2D_r__0_1 {
  let t382 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
  for (pool2D_r__0_1.s0._1.rebased, 0, sliced._1.extent_realized.s + 1) {
   let t383 = (t382 + 2)*pool2D_r__0_1.s0._1.rebased
   for (pool2D_r__0_1.s0._0.rebased, 0, t382 + 2) {
    pool2D_r__0_1[pool2D_r__0_1.s0._0.rebased + t383] = (int16)0
   }
  }
  consume sliced {
   let t384 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
   for (pool2D_r__0_1.s1._1.rebased, 0, sliced._1.extent_realized.s + 1) {
    let t385 = (t384 + 2)*pool2D_r__0_1.s1._1.rebased
    for (pool2D_r__0_1.s1._0.rebased, 0, t384 + 2) {
     let t386 = pool2D_r__0_1.s1._0.rebased + t385
     for (pool2D_r__0_1.s1.r99$y.rebased, 0, 5) {
      let t387 = ((pool2D_r__0_1.s1._1.rebased + pool2D_r__0_1.s1.r99$y.rebased)*(t384 + 6)) + pool2D_r__0_1.s1._0.rebased
      for (pool2D_r__0_1.s1.r99$x.rebased, 0, 5) {
       pool2D_r__0_1[t386] = pool2D_r__0_1[t386] + (int16(sliced[pool2D_r__0_1.s1.r99$x.rebased + t387])/(int16)25)
      }
     }
    }
   }
  }
  free sliced
 }
 let all_r$1._1.extent_realized.s = let t798 = (casted.extent.1 + casted.min.1) in (max(max(min(((t798 + 23)/8)*8, 1999), all_r$1.s1._1.max), max((t798 + 23)/8, 0)*8) - min((casted.min.1/8)*8, 1999))
 let all_r$1._0.min_realized = let t799 = min(casted.min.0, 1999) in min(min(max(t799, 0), all_r$1.s1._0.min), t799 + -3)
 let all_r$1._0.extent_realized.s.s = let t800 = (casted.extent.0 + casted.min.0) in max(max(min(t800, 1998), all_r$1.s1._0.max.s), max(t800, -1) + 4)
 let all_r$1.stride.2 = ((all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized) + 2)*(all_r$1._1.extent_realized.s + 1)
 allocate all_r$1[int32 * ((all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized) + 2) * (all_r$1._1.extent_realized.s + 1) * 14]
 produce all_r$1 {
  let t389 = all_r$1.s1._0.min - all_r$1._0.min_realized
  let t388 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
  let t390 = all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized
  for (all_r$1.s0._2, 0, 14) {
   let t391 = (all_r$1.s0._2*all_r$1.stride.2) + t389
   for (all_r$1.s0._1.rebased, 0, sliced._1.extent_realized.s + 1) {
    let t392 = ((t390 + 2)*all_r$1.s0._1.rebased) + t391
    for (all_r$1.s0._0.rebased, 0, t388 + 2) {
     all_r$1[all_r$1.s0._0.rebased + t392] = 0
    }
   }
  }
  consume pool2D_r__0_1 {
   let t394 = all_r$1.s1._0.min - all_r$1._0.min_realized
   let t393 = all_r$1.s1._0.max.s - all_r$1.s1._0.min
   let t395 = all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized
   for (all_r$1.s1._2, 0, 14) {
    let t396 = (all_r$1.s1._2*all_r$1.stride.2) + t394
    for (all_r$1.s1._1.rebased, 0, sliced._1.extent_realized.s + 1) {
     let t398 = (t393 + 2)*all_r$1.s1._1.rebased
     let t397 = ((t395 + 2)*all_r$1.s1._1.rebased) + t396
     for (all_r$1.s1._0.rebased, 0, t393 + 2) {
      let t236 = all_r$1.s1._0.rebased + t397
      all_r$1[t236] = all_r$1[t236] + ((all_r$1.s1._2 + 2)*int32(pool2D_r__0_1[all_r$1.s1._0.rebased + t398]))
     }
    }
   }
  }
  free pool2D_r__0_1
 }
 let all._1.extent_realized.s = max(min((((casted.extent.1 + casted.min.1) + 23)/8)*8, 1999), 0) - max(min((casted.min.1/8)*8, 1999), 0)
 let all._0.extent_realized.s = max(min(casted.extent.0 + casted.min.0, 1998), -1) - max(min(casted.min.0, 1999), 0)
 let all.stride.2 = (all._0.extent_realized.s + 2)*(all._1.extent_realized.s + 1)
 allocate all[int32 * (all._0.extent_realized.s + 2) * (all._1.extent_realized.s + 1) * 12]
 produce all {
  consume all_r$1 {
   let t399 = min((casted.min.1/8)*8, 1999)
   let t400 = max(min(casted.min.0, 1999), 0) - all_r$1._0.min_realized
   let t401 = all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized
   for (all.s0._2, 0, 12) {
    let t427 = all.s0._2*all.stride.2
    let t414 = 0 - min(t399, 0)
    for (all.s0._1.rebased, 0, all._1.extent_realized.s + 1) {
     let t428 = ((all.s0._1.rebased + t414)*(t401 + 2)) + t400
     let t441 = ((all._0.extent_realized.s + 2)*all.s0._1.rebased) + t427
     for (all.s0._0.rebased, 0, all._0.extent_realized.s + 2) {
      let t238 = all.s0._0.rebased + t428
      all[all.s0._0.rebased + t441] = (all_r$1[all_r$1.stride.2 + t238]*(all.s0._2 + 29)) + ((all_r$1[t238]*(all.s0._2 + 15)) + ((all_r$1[(all_r$1.stride.2*2) + t238]*(all.s0._2 + 43)) + ((all_r$1[(all_r$1.stride.2*3) + t238]*(all.s0._2 + 57)) + ((all_r$1[(all_r$1.stride.2*4) + t238]*(all.s0._2 + 71)) + ((all_r$1[(all_r$1.stride.2*5) + t238]*(all.s0._2 + 85)) + ((all_r$1[(all_r$1.stride.2*6) + t238]*(all.s0._2 + 99)) + ((all_r$1[(all_r$1.stride.2*7) + t238]*(all.s0._2 + 113)) + ((all_r$1[(all_r$1.stride.2*8) + t238]*(all.s0._2 + 127)) + ((all_r$1[(all_r$1.stride.2*9) + t238]*(all.s0._2 + 141)) + ((all_r$1[(all_r$1.stride.2*10) + t238]*(all.s0._2 + 155)) + ((all_r$1[(all_r$1.stride.2*11) + t238]*(all.s0._2 + 169)) + ((all_r$1[(all_r$1.stride.2*13) + t238]*(all.s0._2 + 197)) + (all_r$1[(all_r$1.stride.2*12) + t238]*(all.s0._2 + 183))))))))))))))
     }
    }
   }
  }
 }
 let conv_r__0._1.extent_realized.s = (max(((casted.extent.1 + casted.min.1) + 23)/8, 0)*8) - min((casted.min.1/8)*8, 1999)
 let conv_r__0._0.extent_realized.s = max(casted.extent.0 + casted.min.0, -1) - min(casted.min.0, 1999)
 let conv_r__0.stride.2 = (conv_r__0._0.extent_realized.s + 2)*(conv_r__0._1.extent_realized.s + 1)
 allocate conv_r__0[int32 * (conv_r__0._0.extent_realized.s + 2) * (conv_r__0._1.extent_realized.s + 1) * 14]
 produce conv_r__0 {
  for (conv_r__0.s0._2, 0, 14) {
   let t442 = conv_r__0.s0._2*conv_r__0.stride.2
   for (conv_r__0.s0._1.rebased, 0, conv_r__0._1.extent_realized.s + 1) {
    let t443 = ((conv_r__0._0.extent_realized.s + 2)*conv_r__0.s0._1.rebased) + t442
    for (conv_r__0.s0._0.rebased, 0, conv_r__0._0.extent_realized.s + 2) {
     conv_r__0[conv_r__0.s0._0.rebased + t443] = 0
    }
   }
  }
  consume all_r$1 {
   let t444 = min(casted.min.0, 1999) - all_r$1._0.min_realized
   let t445 = all_r$1._0.extent_realized.s.s - all_r$1._0.min_realized
   for (conv_r__0.s1._2, 0, 14) {
    let t446 = conv_r__0.s1._2*conv_r__0.stride.2
    let t447 = (all_r$1.stride.2*conv_r__0.s1._2) + t444
    for (conv_r__0.s1._1.rebased, 0, conv_r__0._1.extent_realized.s + 1) {
     let t449 = ((t445 + 2)*conv_r__0.s1._1.rebased) + t447
     let t448 = ((conv_r__0._0.extent_realized.s + 2)*conv_r__0.s1._1.rebased) + t446
     for (conv_r__0.s1._0.rebased, 0, conv_r__0._0.extent_realized.s + 2) {
      let t451 = conv_r__0.s1._0.rebased + t449
      let t450 = conv_r__0.s1._0.rebased + t448
      for (conv_r__0.s1.r124$x.rebased, 0, 8) {
       conv_r__0[t450] = conv_r__0[t450] + (all_r$1[(conv_r__0.s1.r124$x.rebased + t451) + -3]*40)
      }
     }
    }
   }
  }
  free all_r$1
 }
 allocate sliced$1[int32 * (all._0.extent_realized.s + 2) * (all._1.extent_realized.s + 1) * 1]
 produce sliced$1 {
  consume conv_r__0 {
   consume all {
    let t453 = min((casted.min.1/8)*8, 1999)
    let t452 = min(casted.min.0, 1999)
    for (sliced$1.s0._1.rebased, 0, all._1.extent_realized.s + 1) {
     let t455 = max(t452, 0)
     let t456 = (sliced$1.s0._1.rebased - min(t453, 0))*(conv_r__0._0.extent_realized.s + 2)
     let t454 = (all._0.extent_realized.s + 2)*sliced$1.s0._1.rebased
     for (sliced$1.s0._0.rebased, 0, all._0.extent_realized.s + 2) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t457 = sliced$1.s0._0.rebased + t454
       for (all_r$2.s1.r135$x, 0, 12) {
        all_r$2[0] = all_r$2[0] + (all[(all.stride.2*all_r$2.s1.r135$x) + t457]*((all_r$2.s1.r135$x*12) + 13))
       }
      }
      consume all_r$2 {
       sliced$1[sliced$1.s0._0.rebased + t454] = conv_r__0[((((max(min(all_r$2[0], 13), 0)*conv_r__0.stride.2) + t455) - t452) + t456) + sliced$1.s0._0.rebased]
      }
      free all_r$2
     }
    }
   }
  }
 }
 free all
 let constant_exterior._1.extent_realized.s = (((casted.extent.1 + casted.min.1) + 23)/8) - (casted.min.1/8)
 allocate constant_exterior[int32 * (casted.extent.0 + 2) * ((constant_exterior._1.extent_realized.s*8) + 1) * 1]
 produce constant_exterior {
  consume sliced$1 {
   let constant_exterior.s0._1.prologue = min(max(casted.min.1/8, 0)*8, (((casted.min.1/8) + constant_exterior._1.extent_realized.s)*8) + 1)
   let constant_exterior.s0._1.epilogue = let t801 = ((casted.min.1/8) + constant_exterior._1.extent_realized.s) in max(min(max(casted.min.1/8, 0)*8, (t801*8) + 1), min(t801*8, 1999) + 1)
   let t462 = (casted.min.1/8)*8
   let t460 = max(min(t462, 1999), 0)
   let t461 = max(min(casted.min.0, 1999), 0)
   let t458 = constant_exterior.s0._1.prologue - t462
   for (constant_exterior.s0._1.rebased, 0, t458) {
    let t464 = (casted.extent.0 + 2)*constant_exterior.s0._1.rebased
    let t463 = constant_exterior.s0._1.rebased + t462
    for (constant_exterior.s0._0.rebased, 0, casted.extent.0 + 2) {
     let t285 = casted.min.0 + constant_exterior.s0._0.rebased
     constant_exterior[constant_exterior.s0._0.rebased + t464] = select(((2000 <= t285) || (t285 < 0)) || (t463 < 0), 0, sliced$1[max(min(t285, 1999), 0) + (((max(t463, 0) - t460)*(all._0.extent_realized.s + 2)) - t461)])
    }
   }
   let t472 = casted.extent.0 + casted.min.0
   let t473 = (casted.min.1/8)*8
   let t474 = min(max(casted.min.0, 0), t472 + 2)
   let t467 = max(min(t472, 1998) + 2, t474)
   let t469 = max(min(casted.min.0, 1999), 0)
   let t468 = constant_exterior.s0._1.prologue - max(min(t473, 1999), 0)
   let t470 = constant_exterior.s0._1.prologue - t473
   let t465 = constant_exterior.s0._1.epilogue - constant_exterior.s0._1.prologue
   for (constant_exterior.s0._1.rebased, 0, t465) {
    let t477 = (constant_exterior.s0._1.rebased + t470)*(casted.extent.0 + 2)
    let t476 = ((constant_exterior.s0._1.rebased + t468)*(all._0.extent_realized.s + 2)) - t469
    let t475 = t474 - casted.min.0
    for (constant_exterior.s0._0.rebased, 0, t475) {
     let t288 = casted.min.0 + constant_exterior.s0._0.rebased
     constant_exterior[constant_exterior.s0._0.rebased + t477] = select(t288 < 0, 0, sliced$1[max(t288, 0) + t476])
    }
    let t478 = t467 - t474
    let t480 = ((constant_exterior.s0._1.rebased + t470)*(casted.extent.0 + 2)) + (t474 - casted.min.0)
    let t479 = ((constant_exterior.s0._1.rebased + t468)*(all._0.extent_realized.s + 2)) + (t474 - t469)
    for (constant_exterior.s0._0.rebased, 0, t478) {
     constant_exterior[constant_exterior.s0._0.rebased + t480] = sliced$1[constant_exterior.s0._0.rebased + t479]
    }
    let t482 = ((constant_exterior.s0._1.rebased + t468)*(all._0.extent_realized.s + 2)) - t469
    let t481 = t472 - t467
    let t483 = ((constant_exterior.s0._1.rebased + t470)*(casted.extent.0 + 2)) + (t467 - casted.min.0)
    for (constant_exterior.s0._0.rebased, 0, t481 + 2) {
     let t289 = constant_exterior.s0._0.rebased + t467
     constant_exterior[constant_exterior.s0._0.rebased + t483] = select(t289 < 2000, sliced$1[max(min(t289, 1999), 0) + t482], 0)
    }
   }
   let t488 = casted.min.1/8
   let t489 = t488*8
   let t485 = max(min(t489, 1999), 0)
   let t486 = max(min(casted.min.0, 1999), 0)
   let t484 = ((constant_exterior._1.extent_realized.s + t488)*8) - constant_exterior.s0._1.epilogue
   let t487 = constant_exterior.s0._1.epilogue - t489
   for (constant_exterior.s0._1.rebased, 0, t484 + 1) {
    let t491 = (constant_exterior.s0._1.rebased + t487)*(casted.extent.0 + 2)
    let t490 = constant_exterior.s0._1.epilogue + constant_exterior.s0._1.rebased
    for (constant_exterior.s0._0.rebased, 0, casted.extent.0 + 2) {
     let t290 = casted.min.0 + constant_exterior.s0._0.rebased
     constant_exterior[constant_exterior.s0._0.rebased + t491] = select(((2000 <= t290) || (t290 < 0)) || (2000 <= t490), 0, sliced$1[max(min(t290, 1999), 0) + (((max(min(t490, 1999), 0) - t485)*(all._0.extent_realized.s + 2)) - t486)])
    }
   }
   free sliced$1
  }
 }
 let upsampled_nn__1._1.extent_realized.s = (((casted.extent.1 + casted.min.1) + 7)/8) - (casted.min.1/8)
 allocate upsampled_nn__1[int32 * casted.extent.0 * ((upsampled_nn__1._1.extent_realized.s*64) + 64) * 1]
 produce upsampled_nn__1 {
  consume constant_exterior {
   let t492 = upsampled_nn__1._1.extent_realized.s*64
   for (upsampled_nn__1.s0._1.rebased, 0, t492 + 64) {
    let t493 = ((upsampled_nn__1.s0._1.rebased + 1)/8)*(casted.extent.0 + 2)
    let t494 = casted.extent.0*upsampled_nn__1.s0._1.rebased
    for (upsampled_nn__1.s0._0.rebased, 0, casted.extent.0) {
     upsampled_nn__1[t494 + upsampled_nn__1.s0._0.rebased] = constant_exterior[t493 + upsampled_nn__1.s0._0.rebased]
    }
   }
  }
 }
 allocate downsampled_nn__1[int32 * (casted.extent.0 + 2) * (constant_exterior._1.extent_realized.s + 1) * 1]
 let downsampled_nn__1.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 31)/8) - (casted.min.1/8)
 produce downsampled_nn__1 {
  consume constant_exterior {
   for (downsampled_nn__1.s0._1.rebased, 0, downsampled_nn__1.s0._1.loop_extent) {
    let t495 = (casted.extent.0 + 2)*downsampled_nn__1.s0._1.rebased
    for (downsampled_nn__1.s0._0.rebased, 0, casted.extent.0 + 2) {
     downsampled_nn__1[downsampled_nn__1.s0._0.rebased + t495] = constant_exterior[(t495*8) + downsampled_nn__1.s0._0.rebased]
    }
   }
  }
 }
 free constant_exterior
 let all_r$4.stride.2 = (casted.extent.0 + 2)*(constant_exterior._1.extent_realized.s + 1)
 allocate all_r$4[int32 * (casted.extent.0 + 2) * (constant_exterior._1.extent_realized.s + 1) * 198]
 let all_r$4.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 31)/8) - (casted.min.1/8)
 produce all_r$4 {
  for (all_r$4.s0._2, 0, 198) {
   let t496 = all_r$4.s0._2*all_r$4.stride.2
   for (all_r$4.s0._1.rebased, 0, all_r$4.s0._1.loop_extent) {
    let t497 = ((casted.extent.0 + 2)*all_r$4.s0._1.rebased) + t496
    for (all_r$4.s0._0.rebased, 0, casted.extent.0 + 2) {
     all_r$4[all_r$4.s0._0.rebased + t497] = 0
    }
   }
  }
  consume downsampled_nn__1 {
   for (all_r$4.s1._2, 0, 198) {
    let t498 = all_r$4.s1._2*all_r$4.stride.2
    for (all_r$4.s1._1.rebased, 0, all_r$4.s0._1.loop_extent) {
     let t501 = (casted.extent.0 + 2)*all_r$4.s1._1.rebased
     let t499 = t498 + t501
     for (all_r$4.s1._0.rebased, 0, casted.extent.0 + 2) {
      let t249 = all_r$4.s1._0.rebased + t499
      all_r$4[t249] = all_r$4[t249] + (downsampled_nn__1[all_r$4.s1._0.rebased + t501]*(all_r$4.s1._2 + 2))
     }
    }
   }
  }
  free downsampled_nn__1
 }
 allocate sliced$2[int32 * (casted.extent.0 + 2) * (constant_exterior._1.extent_realized.s + 1) * 1]
 let sliced$2.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 31)/8) - (casted.min.1/8)
 produce sliced$2 {
  consume all_r$4 {
   consume conv_r__0 {
    let t505 = casted.min.1/8
    let t504 = min(t505*8, 1999)
    let t502 = max(casted.min.0, 1999) + -1999
    for (sliced$2.s0._1.rebased, 0, sliced$2.s0._1.loop_extent) {
     let t507 = (casted.extent.0 + 2)*sliced$2.s0._1.rebased
     let t506 = ((((sliced$2.s0._1.rebased + t505)*8) - t504)*(conv_r__0._0.extent_realized.s + 2)) + t502
     for (sliced$2.s0._0.rebased, 0, casted.extent.0 + 2) {
      allocate all_r$5[int32 * 1]
      produce all_r$5 {
       all_r$5[0] = 0
       let t508 = sliced$2.s0._0.rebased + t506
       for (all_r$5.s1.r192$x, 0, 14) {
        all_r$5[0] = all_r$5[0] + (conv_r__0[(all_r$5.s1.r192$x*conv_r__0.stride.2) + t508]*((all_r$5.s1.r192$x*14) + 15))
       }
      }
      consume all_r$5 {
       sliced$2[sliced$2.s0._0.rebased + t507] = all_r$4[((max(min(all_r$5[0], 197), 0)*all_r$4.stride.2) + t507) + sliced$2.s0._0.rebased]
      }
      free all_r$5
     }
    }
   }
  }
 }
 free conv_r__0
 free all_r$4
 allocate conv2D_r__0_1[int32 * casted.extent.0 * (upsampled_nn__1._1.extent_realized.s + 1) * 104]
 let conv2D_r__0_1.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 15)/8) - (casted.min.1/8)
 produce conv2D_r__0_1 {
  let t509 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
  for (conv2D_r__0_1.s0._2, 0, 104) {
   let t510 = conv2D_r__0_1.s0._2*t509
   for (conv2D_r__0_1.s0._1.rebased, 0, conv2D_r__0_1.s0._1.loop_extent) {
    let t511 = (casted.extent.0*conv2D_r__0_1.s0._1.rebased) + t510
    for (conv2D_r__0_1.s0._0.rebased, 0, casted.extent.0) {
     conv2D_r__0_1[conv2D_r__0_1.s0._0.rebased + t511] = 0
    }
   }
  }
  consume sliced$2 {
   let t512 = max(min(int32_weights.min.3, 104), 0)
   let t513 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
   let t514 = (((max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0) - (int32_weights.min.3*int32_weights.stride.3)) - (int32_weights.min.2*int32_weights.stride.2)) - (int32_weights.min.1*int32_weights.stride.1)) - int32_weights.min.0
   let t515 = int32_weights.extent.3 + int32_weights.min.3
   let t516 = int32_weights.extent.2 + int32_weights.min.2
   let t517 = int32_weights.extent.1 + int32_weights.min.1
   for (conv2D_r__0_1.s1._2, 0, t512) {
    let t518 = conv2D_r__0_1.s1._2*t513
    let t519 = (max(min(t515 + -1, conv2D_r__0_1.s1._2), int32_weights.min.3)*int32_weights.stride.3) + t514
    for (conv2D_r__0_1.s1._1.rebased, 0, conv2D_r__0_1.s0._1.loop_extent) {
     let t520 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t518
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t521 = conv2D_r__0_1.s1._0.rebased + t520
      for (conv2D_r__0_1.s1.r206$y, 0, 3) {
       let t522 = (max(min(t516 + -1, conv2D_r__0_1.s1.r206$y), int32_weights.min.2)*int32_weights.stride.2) + t519
       let t523 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r206$y)*(casted.extent.0 + 2)) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r206$x, 0, 3) {
        conv2D_r__0_1[t521] = conv2D_r__0_1[t521] + (int32_weights[(max(min(t517 + -1, conv2D_r__0_1.s1.r206$x), int32_weights.min.1)*int32_weights.stride.1) + t522]*sliced$2[conv2D_r__0_1.s1.r206$x + t523])
       }
      }
     }
    }
   }
   let t536 = int32_weights.extent.1 + int32_weights.min.1
   let t537 = int32_weights.extent.2 + int32_weights.min.2
   let t538 = max(min(t536, 3), 0)
   let t539 = max(min(t537, 3), 0)
   let t540 = max(min(int32_weights.min.1, 3), 0)
   let t541 = max(min(int32_weights.min.2, 3), 0)
   let t542 = max(min(int32_weights.min.3, 104), 0)
   let t526 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
   let t524 = max(min(int32_weights.extent.3 + int32_weights.min.3, 104), 0) - t542
   let t531 = t539 - t541
   let t533 = t538 - t540
   let t528 = (((max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0) - (int32_weights.min.3*int32_weights.stride.3)) - (int32_weights.min.2*int32_weights.stride.2)) - (int32_weights.min.1*int32_weights.stride.1)) - int32_weights.min.0
   let t535 = 3 - t539
   let t534 = 3 - t538
   for (conv2D_r__0_1.s1._2.rebased, 0, t524) {
    let t547 = conv2D_r__0_1.s1._2.rebased + t542
    let t546 = max(min(t537, 3), 0)
    let t545 = max(min(t536, 3), 0)
    let t543 = t526*t547
    let t544 = (int32_weights.stride.3*t547) + t528
    for (conv2D_r__0_1.s1._1.rebased, 0, conv2D_r__0_1.s0._1.loop_extent) {
     let t548 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t543
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t551 = conv2D_r__0_1.s1._0.rebased + t548
      for (conv2D_r__0_1.s1.r206$y, 0, t541) {
       let t552 = (max(min(t537 + -1, conv2D_r__0_1.s1.r206$y), int32_weights.min.2)*int32_weights.stride.2) + t544
       let t553 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r206$y)*(casted.extent.0 + 2)) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r206$x, 0, 3) {
        conv2D_r__0_1[t551] = conv2D_r__0_1[t551] + (int32_weights[(max(min(t536 + -1, conv2D_r__0_1.s1.r206$x), int32_weights.min.1)*int32_weights.stride.1) + t552]*sliced$2[conv2D_r__0_1.s1.r206$x + t553])
       }
      }
      let t555 = conv2D_r__0_1.s1._1.rebased + t541
      let t554 = conv2D_r__0_1.s1._0.rebased + t548
      for (conv2D_r__0_1.s1.r206$y.rebased, 0, t531) {
       let t559 = ((conv2D_r__0_1.s1.r206$y.rebased + t555)*(casted.extent.0 + 2)) + conv2D_r__0_1.s1._0.rebased
       let t558 = ((conv2D_r__0_1.s1.r206$y.rebased + t541)*int32_weights.stride.2) + t544
       for (conv2D_r__0_1.s1.r206$x, 0, t540) {
        conv2D_r__0_1[t554] = conv2D_r__0_1[t554] + (int32_weights[(max(min(t536 + -1, conv2D_r__0_1.s1.r206$x), int32_weights.min.1)*int32_weights.stride.1) + t558]*sliced$2[conv2D_r__0_1.s1.r206$x + t559])
       }
       let t561 = ((conv2D_r__0_1.s1.r206$y.rebased + t555)*(casted.extent.0 + 2)) + (conv2D_r__0_1.s1._0.rebased + t540)
       let t560 = ((conv2D_r__0_1.s1.r206$y.rebased + t541)*int32_weights.stride.2) + t544
       for (conv2D_r__0_1.s1.r206$x.rebased, 0, t533) {
        conv2D_r__0_1[t554] = conv2D_r__0_1[t554] + (int32_weights[((conv2D_r__0_1.s1.r206$x.rebased + t540)*int32_weights.stride.1) + t560]*sliced$2[conv2D_r__0_1.s1.r206$x.rebased + t561])
       }
       let t563 = ((conv2D_r__0_1.s1.r206$y.rebased + t555)*(casted.extent.0 + 2)) + (conv2D_r__0_1.s1._0.rebased + t545)
       let t562 = ((conv2D_r__0_1.s1.r206$y.rebased + t541)*int32_weights.stride.2) + t544
       for (conv2D_r__0_1.s1.r206$x.rebased, 0, t534) {
        conv2D_r__0_1[t554] = conv2D_r__0_1[t554] + (int32_weights[(max(min(t536 + -1, conv2D_r__0_1.s1.r206$x.rebased + t545), int32_weights.min.1)*int32_weights.stride.1) + t562]*sliced$2[conv2D_r__0_1.s1.r206$x.rebased + t563])
       }
      }
      let t565 = conv2D_r__0_1.s1._1.rebased + t546
      let t564 = conv2D_r__0_1.s1._0.rebased + t548
      for (conv2D_r__0_1.s1.r206$y.rebased, 0, t535) {
       let t566 = (max(min(t537 + -1, conv2D_r__0_1.s1.r206$y.rebased + t546), int32_weights.min.2)*int32_weights.stride.2) + t544
       let t567 = ((conv2D_r__0_1.s1.r206$y.rebased + t565)*(casted.extent.0 + 2)) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r206$x, 0, 3) {
        conv2D_r__0_1[t564] = conv2D_r__0_1[t564] + (int32_weights[(max(min(t536 + -1, conv2D_r__0_1.s1.r206$x), int32_weights.min.1)*int32_weights.stride.1) + t566]*sliced$2[conv2D_r__0_1.s1.r206$x + t567])
       }
      }
     }
    }
   }
   let t575 = int32_weights.extent.3 + int32_weights.min.3
   let t576 = max(min(t575, 104), 0)
   let t569 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
   let t572 = (((max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0) - (int32_weights.min.3*int32_weights.stride.3)) - (int32_weights.min.2*int32_weights.stride.2)) - (int32_weights.min.1*int32_weights.stride.1)) - int32_weights.min.0
   let t573 = int32_weights.extent.2 + int32_weights.min.2
   let t574 = int32_weights.extent.1 + int32_weights.min.1
   for (conv2D_r__0_1.s1._2.rebased, 0, 104 - t576) {
    let t577 = (conv2D_r__0_1.s1._2.rebased + t576)*t569
    let t578 = (max(min(t575 + -1, max(min(t575, 104), 0) + conv2D_r__0_1.s1._2.rebased), int32_weights.min.3)*int32_weights.stride.3) + t572
    for (conv2D_r__0_1.s1._1.rebased, 0, conv2D_r__0_1.s0._1.loop_extent) {
     let t579 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t577
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t580 = conv2D_r__0_1.s1._0.rebased + t579
      for (conv2D_r__0_1.s1.r206$y, 0, 3) {
       let t581 = (max(min(t573 + -1, conv2D_r__0_1.s1.r206$y), int32_weights.min.2)*int32_weights.stride.2) + t578
       let t582 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r206$y)*(casted.extent.0 + 2)) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r206$x, 0, 3) {
        conv2D_r__0_1[t580] = conv2D_r__0_1[t580] + (int32_weights[(max(min(t574 + -1, conv2D_r__0_1.s1.r206$x), int32_weights.min.1)*int32_weights.stride.1) + t581]*sliced$2[conv2D_r__0_1.s1.r206$x + t582])
       }
      }
     }
    }
   }
   free sliced$2
  }
 }
 allocate binary_op$2[int32 * casted.extent.0 * (upsampled_nn__1._1.extent_realized.s + 1) * 104]
 let binary_op$2.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 15)/8) - (casted.min.1/8)
 produce binary_op$2 {
  consume conv2D_r__0_1 {
   consume upsampled_nn__1 {
    let t646 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
    for (binary_op$2.s0._2, 0, 104) {
     let t710 = binary_op$2.s0._2*t646
     for (binary_op$2.s0._1.rebased, 0, binary_op$2.s0._1.loop_extent) {
      let t711 = ((binary_op$2.s0._1.rebased*64) + -1)*casted.extent.0
      let t775 = (binary_op$2.s0._1.rebased*casted.extent.0) + t710
      for (binary_op$2.s0._0.rebased, 0, casted.extent.0) {
       allocate all_r$7[int32 * 1]
       produce all_r$7 {
        all_r$7[0] = 0
        all_r$7[0] = all_r$7[0] + ((upsampled_nn__1[((casted.extent.0*2) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[(casted.extent.0 + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*3) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*4) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*5) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*6) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*7) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*8) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*9) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*10) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*11) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*12) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*13) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*14) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*15) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*16) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*17) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*18) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*19) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*20) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*21) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*22) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*23) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*24) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*25) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*26) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*27) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*28) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*29) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*30) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*31) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*32) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*33) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*34) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*35) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*36) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*37) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*38) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*39) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*40) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*41) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*42) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*43) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*44) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*45) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*46) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*47) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*48) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*49) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*50) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*51) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*52) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*53) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*54) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*55) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*56) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*57) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*58) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*59) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*60) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*61) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*62) + t711) + binary_op$2.s0._0.rebased] + (upsampled_nn__1[((casted.extent.0*64) + t711) + binary_op$2.s0._0.rebased] + upsampled_nn__1[((casted.extent.0*63) + t711) + binary_op$2.s0._0.rebased])))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))*(binary_op$2.s0._2 + 2))
       }
       consume all_r$7 {
        let t259 = binary_op$2.s0._0.rebased + t775
        binary_op$2[t259] = conv2D_r__0_1[t259] % all_r$7[0]
       }
       free all_r$7
      }
     }
    }
   }
  }
 }
 free upsampled_nn__1
 free conv2D_r__0_1
 produce casted {
  consume binary_op$2 {
   let t776 = casted.min.1/8
   let t777 = (upsampled_nn__1._1.extent_realized.s + 1)*casted.extent.0
   let t778 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t781 = casted.min.2 + casted.s0._2.rebased
    let t780 = (casted.stride.2*t781) + t778
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t784 = casted.min.1 + casted.s0._1.rebased
     let t782 = (t784/8) - t776
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$8[int32 * 2]
      produce all_r$8 {
       for (all_r$8.s0._1.rebased, 0, 2) {
        all_r$8[all_r$8.s0._1.rebased] = 0
       }
       for (all_r$8.s1._1.rebased, 0, 2) {
        let t785 = ((all_r$8.s1._1.rebased + t782)*casted.extent.0) + casted.s0._0.rebased
        for (all_r$8.s1.r276$x, 0, 104) {
         all_r$8[all_r$8.s1._1.rebased] = all_r$8[all_r$8.s1._1.rebased] + (binary_op$2[(all_r$8.s1.r276$x*t777) + t785]*(((all_r$8.s1.r276$x*104) + t781) + 105))
        }
       }
      }
      consume all_r$8 {
       let t305 = t784 % 8
       casted[((casted.stride.1*t784) + t780) + casted.s0._0.rebased] = int32((int16(((all_r$8[0]*(8 - t305)) + (all_r$8[1]*t305)))/(int16)16))
      }
      free all_r$8
     }
    }
   }
  }
 }
 free binary_op$2
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
add_temp_object_file: /tmp/Xcu3wU/random_pipeline.a.o
Module.compile(): temporary object /tmp/Xcu3wU/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50053_0/random_pipeline.a
file_unlink: /tmp/Xcu3wU/random_pipeline.a.o
dir_rmdir: /tmp/Xcu3wU
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50053_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50053_0/random_pipeline.registration.cpp
