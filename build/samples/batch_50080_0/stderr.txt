Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50080_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
In random expression: (let t10 = mirror_image(_0, _1, _2) in t10)
The following expressions were unused:
all_r$1(_0, _1, _2)
(all_r$1(_0, _1, _2)*mirror_image(_0, _1, _2))
In random expression: (let t13 = all_r$2(_0, _1, _2) in t13)
The following expressions were unused:
mirror_image(_0, _1, _2)
(let t14 = mirror_image(_0, _1, _2) in (let t15 = all_r$2(_0, _1, _2) in ((t14/t15) <= (t14 % t15))))
(let t20 = all_r$3(_0, _1, _2) in (let t21 = binary_op(_0, _1, _2) in int8(max(max(t20, t21), (t20*2) % t21))))
In random expression: (let t26 = all_r$4(_0, _1, _2) in select(t26 == 0, 0, 1))
The following expressions were unused:
mirror_image(_0, _1, _2)
(all_r$4(_0, _1, _2) + mirror_image(_0, _1, _2))
max((int16)pooled2D_w__0_1(_0 + -1, _1, _2), (int16)pooled2D_w__0_1(_0, _1, _2)*(int16)pooled2D_w__0_1(_0 + 1, _1, _2))
In random expression: ((int16)sliced$1(_0, _1 + -1, _2) < (int16)sliced$1(_0, _1 + 1, _2))
The following expressions were unused:
(int16)sliced$1(_0, _1, _2)
In random expression: ((int16)sliced$1(_0, _1 + -1, _2)*(int16)sliced$1(_0, _1, _2))
The following expressions were unused:
(int16)sliced$1(_0, _1 + 1, _2)
In random expression: (let t37 = (int16)sliced$1(_0, _1, _2) in t37)
The following expressions were unused:
(int16)sliced$1(_0, _1 + -1, _2)
(int16)sliced$1(_0, _1 + 1, _2)
In random expression: (int16)0
The following expressions were unused:
(int16)sliced$1(_0, _1, _2)
(int16)sliced$1(_0, _1 + -1, _2)
(int16)sliced$1(_0, _1 + 1, _2)
In random expression: (let t39 = (int16)sliced$1(_0, _1, _2) in (let t40 = (int16)sliced$1(_0, _1 + 1, _2) in min(t39, t40)))
The following expressions were unused:
(int16)sliced$1(_0, _1 + -1, _2)
In random expression: ((int16)sliced$1(_0, _1 + 1, _2)/(int16)sliced$1(_0, _1 + -1, _2))
The following expressions were unused:
(int16)sliced$1(_0, _1, _2)
In random expression: (let t41 = (int16)sliced$1(_0, _1, _2) in (let t42 = (int16)sliced$1(_0, _1 + -1, _2) in min(t41, t42)))
The following expressions were unused:
(int16)sliced$1(_0, _1 + 1, _2)
In random expression: int32(((int16)sliced$1(_0, _1 + -1, _2)/(int16)sliced$1(_0, _1 + 1, _2)))
The following expressions were unused:
(int16)sliced$1(_0, _1, _2)
In random expression: ((int16)sliced$1(_0, _1, _2) <= (int16)sliced$1(_0, _1 + -1, _2))
The following expressions were unused:
(int16)sliced$1(_0, _1 + 1, _2)
In random expression: ((int16)sliced$1(_0, _1 + -1, _2) - (int16)sliced$1(_0, _1, _2))
The following expressions were unused:
(int16)sliced$1(_0, _1 + 1, _2)
((((int16)0 + (int16)sliced$1(_0, _1 + -1, _2)) + (int16)sliced$1(_0, _1, _2)) + (int16)sliced$1(_0, _1 + 1, _2))
(let t45 = all_r$6(_0, _1, _2) in min(t45, int32((int16)constant_exterior(_0, _1, _2))))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$7 }
Injecting realization of { all_w$1 }
Injecting realization of { sum$2 }
Injecting realization of { conv2D_r__0_1 }
Inlining repeat_edge$5
Inlining lambda_6
Inlining int32_weights_im
Injecting realization of { binary_op$4 }
Injecting realization of { constant_exterior }
Inlining repeat_edge$6
Injecting realization of { pooled2D_w__0_1 }
Injecting realization of { sum }
Injecting realization of { binary_op$3 }
Injecting realization of { all_r$4 }
Injecting realization of { all_r$6 }
Injecting realization of { sliced }
Injecting realization of { all_r }
Inlining mirror_image
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)int32_weights.buffer) != (uint64)0, halide_error_buffer_argument_is_null("int32_weights"))
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let int32_weights = (void *)_halide_buffer_get_host((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.min.3 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.extent.3 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.stride.3 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 3)
let sliced.s0._1.max.s = let t1507 = (casted.extent.1 + casted.min.1) in max(max(min(t1507, 1998), -1) + 5, t1507)
let sliced.s0._1.min = min(max(min(casted.min.1, 1999), 0) + -1, casted.min.1)
let sliced.s0._0.max.s = let t1508 = (casted.extent.0 + casted.min.0) in max(max(min(t1508, 1998), -1) + 5, t1508)
let sliced.s0._0.min = min(max(min(casted.min.0, 1999), 0) + -1, casted.min.0)
let input.extent.0.required.s = let t1509 = (input.extent.0 + input.min.0) in (let t1510 = (((t1509 + -1) <= sliced.s0._0.max.s) || (sliced.s0._0.min < input.min.0)) in (let t1511 = max(-1 - (input.extent.0*2), max(input.extent.0*2, 1) + -1) in (let t1512 = (t1511 < input.extent.0) in (let t1513 = (0 < input.extent.0) in (let t1514 = (max(min(max(select(t1512, t1511, (input.extent.0*2) + -1), select(t1513, t1511, (input.extent.0*2) + -1)), input.extent.0 + -1), 0) + input.min.0) in (let t1515 = max(min(sliced.s0._0.max.s + 2, t1509) + -1, input.min.0) in (let t1516 = ((t1509 <= sliced.s0._0.min) || (sliced.s0._0.max.s < (input.min.0 + -1))) in (let t1517 = max(min(casted.min.0, 1999), 0) in (let t1518 = max(min(casted.extent.0 + casted.min.0, 1998), -1) in (let t1519 = (((t1509 + 1) <= t1517) || (t1518 < (input.min.0 + -6))) in (let t1520 = max(min(t1518 + 7, t1509) + -1, input.min.0) in (let t1521 = (((t1509 + -6) <= t1518) || (t1517 < (input.min.0 + 1))) in (let t1522 = ((input.extent.0*2) - t1511) in (let t1523 = (max(min(min(select(t1512, 0, t1522 + -1), select(t1513, 0, t1522 + -1)), input.extent.0 + -1), 0) + input.min.0) in (let t1524 = max(min(t1509 + -1, sliced.s0._0.min), input.min.0) in (let t1525 = max(min(t1517, t1509) + -1, input.min.0) in (max(select(t1510, t1514, t1515), max(select(t1516, t1514, t1515), max(select(t1519, t1514, t1520), select(t1521, t1514, t1520)))) - min(select(t1510, t1523, t1524), min(select(t1516, t1523, t1524), min(select(t1519, t1523, t1525), select(t1521, t1523, t1525)))))))))))))))))))))
let input.min.0.required = let t1526 = (input.extent.0 + input.min.0) in (let t1527 = max(-1 - (input.extent.0*2), max(input.extent.0*2, 1) + -1) in (let t1528 = ((input.extent.0*2) - t1527) in (let t1529 = (max(min(min(select(t1527 < input.extent.0, 0, t1528 + -1), select(0 < input.extent.0, 0, t1528 + -1)), input.extent.0 + -1), 0) + input.min.0) in (let t1530 = max(min(t1526 + -1, sliced.s0._0.min), input.min.0) in (let t1531 = max(min(casted.min.0, 1999), 0) in (let t1532 = max(min(casted.extent.0 + casted.min.0, 1998), -1) in (let t1533 = max(min(t1531, t1526) + -1, input.min.0) in min(select(((t1526 + -1) <= sliced.s0._0.max.s) || (sliced.s0._0.min < input.min.0), t1529, t1530), min(select((t1526 <= sliced.s0._0.min) || (sliced.s0._0.max.s < (input.min.0 + -1)), t1529, t1530), min(select(((t1526 + 1) <= t1531) || (t1532 < (input.min.0 + -6)), t1529, t1533), select(((t1526 + -6) <= t1532) || (t1531 < (input.min.0 + 1)), t1529, t1533)))))))))))
let input.extent.1.required.s = let t1534 = (input.extent.1 + input.min.1) in (let t1535 = (((t1534 + -1) <= sliced.s0._1.max.s) || (sliced.s0._1.min < input.min.1)) in (let t1536 = max(-1 - (input.extent.1*2), max(input.extent.1*2, 1) + -1) in (let t1537 = (t1536 < input.extent.1) in (let t1538 = (0 < input.extent.1) in (let t1539 = (max(min(max(select(t1537, t1536, (input.extent.1*2) + -1), select(t1538, t1536, (input.extent.1*2) + -1)), input.extent.1 + -1), 0) + input.min.1) in (let t1540 = max(min(sliced.s0._1.max.s + 2, t1534) + -1, input.min.1) in (let t1541 = ((t1534 <= sliced.s0._1.min) || (sliced.s0._1.max.s < (input.min.1 + -1))) in (let t1542 = max(min(casted.min.1, 1999), 0) in (let t1543 = max(min(casted.extent.1 + casted.min.1, 1998), -1) in (let t1544 = (((t1534 + 1) <= t1542) || (t1543 < (input.min.1 + -6))) in (let t1545 = max(min(t1543 + 7, t1534) + -1, input.min.1) in (let t1546 = (((t1534 + -6) <= t1543) || (t1542 < (input.min.1 + 1))) in (let t1547 = ((input.extent.1*2) - t1536) in (let t1548 = (max(min(min(select(t1537, 0, t1547 + -1), select(t1538, 0, t1547 + -1)), input.extent.1 + -1), 0) + input.min.1) in (let t1549 = max(min(t1534 + -1, sliced.s0._1.min), input.min.1) in (let t1550 = max(min(t1542, t1534) + -1, input.min.1) in (max(select(t1535, t1539, t1540), max(select(t1541, t1539, t1540), max(select(t1544, t1539, t1545), select(t1546, t1539, t1545)))) - min(select(t1535, t1548, t1549), min(select(t1541, t1548, t1549), min(select(t1544, t1548, t1550), select(t1546, t1548, t1550)))))))))))))))))))))
let input.min.1.required = let t1551 = (input.extent.1 + input.min.1) in (let t1552 = max(-1 - (input.extent.1*2), max(input.extent.1*2, 1) + -1) in (let t1553 = ((input.extent.1*2) - t1552) in (let t1554 = (max(min(min(select(t1552 < input.extent.1, 0, t1553 + -1), select(0 < input.extent.1, 0, t1553 + -1)), input.extent.1 + -1), 0) + input.min.1) in (let t1555 = max(min(t1551 + -1, sliced.s0._1.min), input.min.1) in (let t1556 = max(min(casted.min.1, 1999), 0) in (let t1557 = max(min(casted.extent.1 + casted.min.1, 1998), -1) in (let t1558 = max(min(t1556, t1551) + -1, input.min.1) in min(select(((t1551 + -1) <= sliced.s0._1.max.s) || (sliced.s0._1.min < input.min.1), t1554, t1555), min(select((t1551 <= sliced.s0._1.min) || (sliced.s0._1.max.s < (input.min.1 + -1)), t1554, t1555), min(select(((t1551 + 1) <= t1556) || (t1557 < (input.min.1 + -6)), t1554, t1558), select(((t1551 + -6) <= t1557) || (t1556 < (input.min.1 + 1)), t1554, t1558)))))))))))
let input.extent.2.required.s = let t1559 = (input.extent.2 + input.min.2) in (let t1560 = ((t1559 <= 0) || (2 < input.min.2)) in (let t1561 = max(-1 - (input.extent.2*2), max(input.extent.2*2, 1) + -1) in (let t1562 = (t1561 < input.extent.2) in (let t1563 = (0 < input.extent.2) in (let t1564 = (max(min(max(select(t1562, t1561, (input.extent.2*2) + -1), select(t1563, t1561, (input.extent.2*2) + -1)), input.extent.2 + -1), 0) + input.min.2) in (let t1565 = max(min(t1559, 3) + -1, input.min.2) in (let t1566 = ((t1559 <= 2) || (0 < input.min.2)) in (let t1567 = ((input.extent.2*2) - t1561) in (let t1568 = (max(min(min(select(t1562, 0, t1567 + -1), select(t1563, 0, t1567 + -1)), input.extent.2 + -1), 0) + input.min.2) in (let t1569 = max(min(t1559, 1) + -1, input.min.2) in (max(select(t1560, t1564, t1565), select(t1566, t1564, t1565)) - min(select(t1560, t1568, t1569), select(t1566, t1568, t1569)))))))))))))
let input.min.2.required = let t1570 = (input.extent.2 + input.min.2) in (let t1571 = max(-1 - (input.extent.2*2), max(input.extent.2*2, 1) + -1) in (let t1572 = ((input.extent.2*2) - t1571) in (let t1573 = (max(min(min(select(t1571 < input.extent.2, 0, t1572 + -1), select(0 < input.extent.2, 0, t1572 + -1)), input.extent.2 + -1), 0) + input.min.2) in (let t1574 = max(min(t1570, 1) + -1, input.min.2) in min(select((t1570 <= 0) || (2 < input.min.2), t1573, t1574), select((t1570 <= 2) || (0 < input.min.2), t1573, t1574))))))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
let int32_weights.extent.0.required.s = let t1575 = (int32_weights.extent.0 + int32_weights.min.0) in (min(t1575, 3) - max(min(t1575, 1) + -1, int32_weights.min.0))
let int32_weights.min.0.required = max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0)
let int32_weights.extent.1.required.s = let t1576 = (int32_weights.extent.1 + int32_weights.min.1) in (min(t1576, 3) - max(min(t1576, 1) + -1, int32_weights.min.1))
let int32_weights.min.1.required = max(min(int32_weights.extent.1 + int32_weights.min.1, 1) + -1, int32_weights.min.1)
let int32_weights.extent.2.required.s = let t1577 = (int32_weights.extent.2 + int32_weights.min.2) in (min(t1577, 3) - max(min(t1577, 1) + -1, int32_weights.min.2))
let int32_weights.min.2.required = max(min(int32_weights.extent.2 + int32_weights.min.2, 1) + -1, int32_weights.min.2)
let int32_weights.stride.2.required = max(int32_weights.extent.0.required.s, 1)*max(int32_weights.extent.1.required.s, 1)
let int32_weights.extent.3.required.s = let t1578 = (int32_weights.extent.3 + int32_weights.min.3) in (min(t1578, 25) - max(min(t1578, 1) + -1, int32_weights.min.3))
let int32_weights.min.3.required = max(min(int32_weights.extent.3 + int32_weights.min.3, 1) + -1, int32_weights.min.3)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer)) {
 let t1579 = max(int32_weights.extent.0.required.s, 1) in (let t1580 = max(int32_weights.extent.2.required.s, 1) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)int32_weights.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)int32_weights.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 4, (struct halide_dimension_t *)make_struct(int32_weights.min.0.required, t1579, 1, 0, int32_weights.min.1.required, max(int32_weights.extent.1.required.s, 1), t1579, 0, int32_weights.min.2.required, t1580, int32_weights.stride.2.required, 0, int32_weights.min.3.required, max(int32_weights.extent.3.required.s, 1), t1580*int32_weights.stride.2.required, 0), (uint64)0))
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(int32_weights.type == (uint32)73728, halide_error_bad_type("Input buffer int32_weights", int32_weights.type, (uint32)73728))
 assert(int32_weights.dimensions == 4, halide_error_bad_dimensions("Input buffer int32_weights", int32_weights.dimensions, 4))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((int32_weights.min.0 <= int32_weights.min.0.required) && ((max(int32_weights.extent.0.required.s, 1) + int32_weights.min.0.required) <= (int32_weights.extent.0 + int32_weights.min.0)), halide_error_access_out_of_bounds("Input buffer int32_weights", 0, int32_weights.min.0.required, (max(int32_weights.extent.0.required.s, 1) + int32_weights.min.0.required) + -1, int32_weights.min.0, (int32_weights.extent.0 + int32_weights.min.0) + -1))
 assert(0 <= int32_weights.extent.0, halide_error_buffer_extents_negative("Input buffer int32_weights", 0, int32_weights.extent.0))
 assert((int32_weights.min.1 <= int32_weights.min.1.required) && ((max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) <= (int32_weights.extent.1 + int32_weights.min.1)), halide_error_access_out_of_bounds("Input buffer int32_weights", 1, int32_weights.min.1.required, (max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) + -1, int32_weights.min.1, (int32_weights.extent.1 + int32_weights.min.1) + -1))
 assert(0 <= int32_weights.extent.1, halide_error_buffer_extents_negative("Input buffer int32_weights", 1, int32_weights.extent.1))
 assert((int32_weights.min.2 <= int32_weights.min.2.required) && ((max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) <= (int32_weights.extent.2 + int32_weights.min.2)), halide_error_access_out_of_bounds("Input buffer int32_weights", 2, int32_weights.min.2.required, (max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) + -1, int32_weights.min.2, (int32_weights.extent.2 + int32_weights.min.2) + -1))
 assert(0 <= int32_weights.extent.2, halide_error_buffer_extents_negative("Input buffer int32_weights", 2, int32_weights.extent.2))
 assert((int32_weights.min.3 <= int32_weights.min.3.required) && ((max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) <= (int32_weights.extent.3 + int32_weights.min.3)), halide_error_access_out_of_bounds("Input buffer int32_weights", 3, int32_weights.min.3.required, (max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) + -1, int32_weights.min.3, (int32_weights.extent.3 + int32_weights.min.3) + -1))
 assert(0 <= int32_weights.extent.3, halide_error_buffer_extents_negative("Input buffer int32_weights", 3, int32_weights.extent.3))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(int32_weights.stride.0 == 1, halide_error_constraint_violated("int32_weights.stride.0", int32_weights.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let int32_weights.total_extent.1 = int64(int32_weights.extent.1)*int64(int32_weights.extent.0)
 let int32_weights.total_extent.2 = int32_weights.total_extent.1*int64(int32_weights.extent.2)
 let int32_weights.total_extent.3 = int32_weights.total_extent.2*int64(int32_weights.extent.3)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(uint64(int32_weights.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", uint64(int32_weights.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)), (uint64)2147483647))
 assert(int32_weights.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)), (uint64)2147483647))
 assert(int32_weights.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)), (uint64)2147483647))
 assert(int32_weights.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.3, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!int32_weights.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer int32_weights"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(int32_weights != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer int32_weights"))
 allocate sliced[int32 * ((sliced.s0._0.max.s - sliced.s0._0.min) + 2) * ((sliced.s0._1.max.s - sliced.s0._1.min) + 2) * 1]
 produce sliced {
  let sliced.s0._1.prologue = min(max(input.min.1, sliced.s0._1.min), sliced.s0._1.max.s + 2)
  let sliced.s0._1.epilogue = min(max(max(input.min.1, sliced.s0._1.min), input.extent.1 + input.min.1), sliced.s0._1.max.s + 2)
  let t1018 = input.min.2*input.stride.2
  let t1019 = input.min.1*input.stride.1
  let t1005 = sliced.s0._1.prologue - sliced.s0._1.min
  let t1006 = sliced.s0._0.max.s - sliced.s0._0.min
  let t1015 = (t1018 + t1019) + input.min.0
  for (sliced.s0._1.rebased, 0, t1005) {
   let t1030 = input.extent.1*2
   let t1029 = (t1006 + 2)*sliced.s0._1.rebased
   let t1023 = ((sliced.s0._1.min - input.min.1) + sliced.s0._1.rebased) % t1030
   let t1024 = sliced.s0._1.min + sliced.s0._1.rebased
   for (sliced.s0._0.rebased, 0, t1006 + 2) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t1038 = input.extent.1 + input.min.1
     let t1039 = input.extent.0*2
     let t1032 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % t1039
     let t1034 = (select((t1038 <= t1024) || (t1024 < input.min.1), max(min(select(t1023 < input.extent.1, t1023, (t1030 - t1023) + -1), input.extent.1 + -1), 0) + input.min.1, max(min(t1038 + -1, t1024), input.min.1))*input.stride.1) - t1015
     let t1033 = sliced.s0._0.min + sliced.s0._0.rebased
     for (all_r.s1.r85$x, 0, 3) {
      let t743 = (all_r.s1.r85$x - input.min.2) % (input.extent.2*2)
      let t1581 = input.extent.2 + input.min.2
      let t1582 = input.extent.0 + input.min.0
      all_r[0] = all_r[0] + (input[(select((t1581 <= all_r.s1.r85$x) || (all_r.s1.r85$x < input.min.2), max(min(select(t743 < input.extent.2, t743, ((input.extent.2*2) - t743) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1581 + -1, all_r.s1.r85$x), input.min.2))*input.stride.2) + (select((t1582 <= t1033) || (t1033 < input.min.0), max(min(select(t1032 < input.extent.0, t1032, (t1039 - t1032) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1582 + -1, t1033), input.min.0)) + t1034)]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     let t749.s = all_r[0]
     let t750 = (max(min(t749.s, 2), 0) - input.min.2) % (input.extent.2*2)
     let t752 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % (input.extent.0*2)
     let t913 = max(min(t749.s, 2), 0)
     let t917 = sliced.s0._0.min + sliced.s0._0.rebased
     let t1583 = input.extent.0 + input.min.0
     let t1584 = input.extent.1 + input.min.1
     let t1585 = input.extent.2 + input.min.2
     sliced[sliced.s0._0.rebased + t1029] = input[select((t1583 <= t917) || (t917 < input.min.0), max(min(select(t752 < input.extent.0, t752, ((input.extent.0*2) - t752) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1583 + -1, t917), input.min.0)) + ((select((t1584 <= t1024) || (t1024 < input.min.1), max(min(select(t1023 < input.extent.1, t1023, (t1030 - t1023) + -1), input.extent.1 + -1), 0) + input.min.1, max(min(t1584 + -1, t1024), input.min.1))*input.stride.1) + ((((select((t1585 <= t913) || (t913 < input.min.2), max(min(select(t750 < input.extent.2, t750, ((input.extent.2*2) - t750) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1585 + -1, t913), input.min.2))*input.stride.2) - t1018) - t1019) - input.min.0))]
    }
    free all_r
   }
  }
  let t1057 = input.extent.0 + input.min.0
  let t1058 = input.extent.2 + input.min.2
  let t1059 = input.min.2*input.stride.2
  let t1060 = input.min.1*input.stride.1
  let t1061 = max(min(t1058, 3), 0)
  let t1062 = max(min(input.min.2, 3), 0)
  let t1063 = max(input.min.0, sliced.s0._0.min)
  let t1064 = sliced.s0._0.max.s + 2
  let t1042 = min(max(t1057, t1063), t1064)
  let t1041 = min(t1063, t1064)
  let t1054 = t1061 - t1062
  let t1056 = t1061 - input.min.2
  let t1051 = sliced.s0._1.prologue - sliced.s0._1.min
  let t1040 = sliced.s0._1.epilogue - sliced.s0._1.prologue
  let t1055 = 3 - t1061
  let t1048 = (t1059 + t1060) + input.min.0
  for (sliced.s0._1.rebased, 0, t1040) {
   let t1072 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t1071 = (sliced.s0._1.rebased + t1051)*((sliced.s0._0.max.s - sliced.s0._0.min) + 2)
   let t1069 = t1072 - t1048
   let t1065 = t1041 - sliced.s0._0.min
   for (sliced.s0._0.rebased, 0, t1065) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t1077 = input.extent.0*2
     let t1074 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % t1077
     let t1075 = sliced.s0._0.min + sliced.s0._0.rebased
     for (all_r.s1.r85$x, 0, 3) {
      let t756 = (all_r.s1.r85$x - input.min.2) % (input.extent.2*2)
      all_r[0] = all_r[0] + (input[(select((t1058 <= all_r.s1.r85$x) || (all_r.s1.r85$x < input.min.2), max(min(select(t756 < input.extent.2, t756, ((input.extent.2*2) - t756) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, all_r.s1.r85$x), input.min.2))*input.stride.2) + (select((t1057 <= t1075) || (t1075 < input.min.0), max(min(select(t1074 < input.extent.0, t1074, (t1077 - t1074) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1057 + -1, t1075), input.min.0)) + t1069)]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     let t760.s = all_r[0]
     let t761 = (max(min(t760.s, 2), 0) - input.min.2) % (input.extent.2*2)
     let t763 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % (input.extent.0*2)
     let t922 = max(min(t760.s, 2), 0)
     let t924 = sliced.s0._0.min + sliced.s0._0.rebased
     sliced[sliced.s0._0.rebased + t1071] = input[select((t1057 <= t924) || (t924 < input.min.0), max(min(select(t763 < input.extent.0, t763, ((input.extent.0*2) - t763) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1057 + -1, t924), input.min.0)) + (((((select((t1058 <= t922) || (t922 < input.min.2), max(min(select(t761 < input.extent.2, t761, ((input.extent.2*2) - t761) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, t922), input.min.2))*input.stride.2) - t1059) - t1060) - input.min.0) + t1072)]
    }
    free all_r
   }
   let t1084 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t1081 = max(min(t1058, 3), 0)
   let t1078 = t1042 - t1041
   let t1083 = ((sliced.s0._1.rebased + t1051)*((sliced.s0._0.max.s - sliced.s0._0.min) + 2)) + (t1041 - sliced.s0._0.min)
   let t1080 = (((t1041 - t1059) - t1060) - input.min.0) + t1084
   for (sliced.s0._0.rebased, 0, t1078) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t1086 = sliced.s0._0.rebased + t1080
     for (all_r.s1.r85$x, 0, t1062) {
      let t765 = (all_r.s1.r85$x - input.min.2) % (input.extent.2*2)
      all_r[0] = all_r[0] + (input[(select((t1058 <= all_r.s1.r85$x) || (all_r.s1.r85$x < input.min.2), max(min(select(t765 < input.extent.2, t765, ((input.extent.2*2) - t765) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, all_r.s1.r85$x), input.min.2))*input.stride.2) + t1086]*((all_r.s1.r85$x*3) + 4))
     }
     let t1087 = sliced.s0._0.rebased + t1080
     for (all_r.s1.r85$x.rebased, 0, t1054) {
      let t926 = all_r.s1.r85$x.rebased + t1062
      all_r[0] = all_r[0] + (input[(input.stride.2*t926) + t1087]*((t926*3) + 4))
     }
     let t1089 = sliced.s0._0.rebased + t1080
     for (all_r.s1.r85$x.rebased, 0, t1055) {
      let t767 = (all_r.s1.r85$x.rebased + t1056) % (input.extent.2*2)
      let t928 = all_r.s1.r85$x.rebased + t1081
      all_r[0] = all_r[0] + (input[(select(t928 < t1058, max(min(t1058 + -1, t928), input.min.2), max(min(select(t767 < input.extent.2, t767, ((input.extent.2*2) - t767) + -1), input.extent.2 + -1), 0) + input.min.2)*input.stride.2) + t1089]*((t928*3) + 4))
     }
    }
    consume all_r {
     let t769.s = all_r[0]
     let t770 = (max(min(t769.s, 2), 0) - input.min.2) % (input.extent.2*2)
     let t930 = max(min(t769.s, 2), 0)
     sliced[sliced.s0._0.rebased + t1083] = input[((((((select((t1058 <= t930) || (t930 < input.min.2), max(min(select(t770 < input.extent.2, t770, ((input.extent.2*2) - t770) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, t930), input.min.2))*input.stride.2) + t1041) - t1059) - t1060) - input.min.0) + t1084) + sliced.s0._0.rebased]
    }
    free all_r
   }
   let t1097 = (sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1
   let t1094 = t1097 - t1048
   let t1090 = sliced.s0._0.max.s - t1042
   let t1096 = ((sliced.s0._1.rebased + t1051)*((sliced.s0._0.max.s - sliced.s0._0.min) + 2)) + (t1042 - sliced.s0._0.min)
   for (sliced.s0._0.rebased, 0, t1090 + 2) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t1102 = input.extent.0*2
     let t1099 = ((t1042 - input.min.0) + sliced.s0._0.rebased) % t1102
     let t1100 = sliced.s0._0.rebased + t1042
     for (all_r.s1.r85$x, 0, 3) {
      let t772 = (all_r.s1.r85$x - input.min.2) % (input.extent.2*2)
      all_r[0] = all_r[0] + (input[(select((t1058 <= all_r.s1.r85$x) || (all_r.s1.r85$x < input.min.2), max(min(select(t772 < input.extent.2, t772, ((input.extent.2*2) - t772) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, all_r.s1.r85$x), input.min.2))*input.stride.2) + (select(t1100 < t1057, max(min(t1057 + -1, t1100), input.min.0), max(min(select(t1099 < input.extent.0, t1099, (t1102 - t1099) + -1), input.extent.0 + -1), 0) + input.min.0) + t1094)]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     let t776.s = all_r[0]
     let t777 = (max(min(t776.s, 2), 0) - input.min.2) % (input.extent.2*2)
     let t779 = ((t1042 - input.min.0) + sliced.s0._0.rebased) % (input.extent.0*2)
     let t935 = max(min(t776.s, 2), 0)
     let t936 = sliced.s0._0.rebased + t1042
     sliced[sliced.s0._0.rebased + t1096] = input[select(t936 < t1057, max(min(t1057 + -1, t936), input.min.0), max(min(select(t779 < input.extent.0, t779, ((input.extent.0*2) - t779) + -1), input.extent.0 + -1), 0) + input.min.0) + (((((select((t1058 <= t935) || (t935 < input.min.2), max(min(select(t777 < input.extent.2, t777, ((input.extent.2*2) - t777) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1058 + -1, t935), input.min.2))*input.stride.2) - t1059) - t1060) - input.min.0) + t1097)]
    }
    free all_r
   }
  }
  let t1117 = input.min.2*input.stride.2
  let t1118 = input.min.1*input.stride.1
  let t1103 = sliced.s0._1.max.s - sliced.s0._1.epilogue
  let t1116 = sliced.s0._1.epilogue - sliced.s0._1.min
  let t1104 = sliced.s0._0.max.s - sliced.s0._0.min
  let t1113 = (t1117 + t1118) + input.min.0
  for (sliced.s0._1.rebased, 0, t1103 + 2) {
   let t1129 = input.extent.1*2
   let t1128 = (sliced.s0._1.rebased + t1116)*(t1104 + 2)
   let t1122 = ((sliced.s0._1.epilogue - input.min.1) + sliced.s0._1.rebased) % t1129
   let t1123 = sliced.s0._1.epilogue + sliced.s0._1.rebased
   for (sliced.s0._0.rebased, 0, t1104 + 2) {
    allocate all_r[int32 * 1]
    produce all_r {
     all_r[0] = 0
     let t1137 = input.extent.1 + input.min.1
     let t1138 = input.extent.0*2
     let t1131 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % t1138
     let t1133 = (select(t1123 < t1137, max(min(t1137 + -1, t1123), input.min.1), max(min(select(t1122 < input.extent.1, t1122, (t1129 - t1122) + -1), input.extent.1 + -1), 0) + input.min.1)*input.stride.1) - t1113
     let t1132 = sliced.s0._0.min + sliced.s0._0.rebased
     for (all_r.s1.r85$x, 0, 3) {
      let t781 = (all_r.s1.r85$x - input.min.2) % (input.extent.2*2)
      let t1586 = input.extent.2 + input.min.2
      let t1587 = input.extent.0 + input.min.0
      all_r[0] = all_r[0] + (input[(select((t1586 <= all_r.s1.r85$x) || (all_r.s1.r85$x < input.min.2), max(min(select(t781 < input.extent.2, t781, ((input.extent.2*2) - t781) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1586 + -1, all_r.s1.r85$x), input.min.2))*input.stride.2) + (select((t1587 <= t1132) || (t1132 < input.min.0), max(min(select(t1131 < input.extent.0, t1131, (t1138 - t1131) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1587 + -1, t1132), input.min.0)) + t1133)]*((all_r.s1.r85$x*3) + 4))
     }
    }
    consume all_r {
     let t787.s = all_r[0]
     let t788 = (max(min(t787.s, 2), 0) - input.min.2) % (input.extent.2*2)
     let t790 = ((sliced.s0._0.min - input.min.0) + sliced.s0._0.rebased) % (input.extent.0*2)
     let t944 = max(min(t787.s, 2), 0)
     let t948 = sliced.s0._0.min + sliced.s0._0.rebased
     let t1588 = input.extent.0 + input.min.0
     let t1589 = input.extent.1 + input.min.1
     let t1590 = input.extent.2 + input.min.2
     sliced[sliced.s0._0.rebased + t1128] = input[select((t1588 <= t948) || (t948 < input.min.0), max(min(select(t790 < input.extent.0, t790, ((input.extent.0*2) - t790) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1588 + -1, t948), input.min.0)) + ((select(t1123 < t1589, max(min(t1589 + -1, t1123), input.min.1), max(min(select(t1122 < input.extent.1, t1122, (t1129 - t1122) + -1), input.extent.1 + -1), 0) + input.min.1)*input.stride.1) + ((((select((t1590 <= t944) || (t944 < input.min.2), max(min(select(t788 < input.extent.2, t788, ((input.extent.2*2) - t788) + -1), input.extent.2 + -1), 0) + input.min.2, max(min(t1590 + -1, t944), input.min.2))*input.stride.2) - t1117) - t1118) - input.min.0))]
    }
    free all_r
   }
  }
 }
 let binary_op$3._1.extent_realized.s = max(min(casted.extent.1 + casted.min.1, 1998), -1) - max(min(casted.min.1, 1999), 0)
 let binary_op$3._0.extent_realized.s = max(min(casted.extent.0 + casted.min.0, 1998), -1) - max(min(casted.min.0, 1999), 0)
 let binary_op$3.stride.2 = (binary_op$3._0.extent_realized.s + 8)*(binary_op$3._1.extent_realized.s + 8)
 allocate binary_op$3[int32 * (binary_op$3._0.extent_realized.s + 8) * (binary_op$3._1.extent_realized.s + 8) * 3]
 produce binary_op$3 {
  consume sliced {
   let t1154 = max(min(casted.min.0, 1999), 0)
   let t1155 = max(min(casted.min.1, 1999), 0)
   let t1139 = max(min(input.min.2, 3), 0)
   let t1141 = t1155 - sliced.s0._1.min
   let t1140 = t1154 - sliced.s0._0.min
   let t1142 = sliced.s0._0.max.s - sliced.s0._0.min
   let t1153 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (binary_op$3.s0._2, 0, t1139) {
    let t1167 = input.extent.2*2
    let t1168 = input.extent.2 + input.min.2
    let t1161 = (t1168 <= binary_op$3.s0._2) || (binary_op$3.s0._2 < input.min.2)
    let t1163 = max(min(t1168 + -1, binary_op$3.s0._2), input.min.2)
    let t1166 = binary_op$3.s0._2*binary_op$3.stride.2
    let t1156 = (binary_op$3.s0._2 - input.min.2) % t1167
    for (binary_op$3.s0._1.rebased, 0, binary_op$3._1.extent_realized.s + 8) {
     let t1179 = input.extent.1*2
     let t1172 = (((t1155 - input.min.1) + binary_op$3.s0._1.rebased) + -1) % t1179
     let t1174 = (select(t1161, max(min(select(t1156 < input.extent.2, t1156, (t1167 - t1156) + -1), input.extent.2 + -1), 0) + input.min.2, t1163)*input.stride.2) - t1153
     let t1169 = (((binary_op$3.s0._1.rebased + t1141) + -1)*(t1142 + 2)) + t1140
     let t1178 = ((binary_op$3._0.extent_realized.s + 8)*binary_op$3.s0._1.rebased) + t1166
     let t1173 = binary_op$3.s0._1.rebased + t1155
     for (binary_op$3.s0._0.rebased, 0, binary_op$3._0.extent_realized.s + 8) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[(binary_op$3.s0._0.rebased + t1169) + -1]*(binary_op$3.s0._2 + 2))
      }
      consume all_r$4 {
       let t796 = (((t1154 - input.min.0) + binary_op$3.s0._0.rebased) + -1) % (input.extent.0*2)
       let t953 = binary_op$3.s0._0.rebased + t1154
       let t1591 = input.extent.0 + input.min.0
       let t1592 = input.extent.1 + input.min.1
       binary_op$3[binary_op$3.s0._0.rebased + t1178] = all_r$4[0] + input[select(((t1591 + 1) <= t953) || (t953 < (input.min.0 + 1)), max(min(select(t796 < input.extent.0, t796, ((input.extent.0*2) - t796) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1591, t953) + -1, input.min.0)) + ((select(((t1592 + 1) <= t1173) || (t1173 < (input.min.1 + 1)), max(min(select(t1172 < input.extent.1, t1172, (t1179 - t1172) + -1), input.extent.1 + -1), 0) + input.min.1, max(min(t1592, t1173) + -1, input.min.1))*input.stride.1) + t1174)]
      }
      free all_r$4
     }
    }
   }
   let t1202 = input.extent.0 + input.min.0
   let t1203 = input.extent.1 + input.min.1
   let t1204 = input.min.2*input.stride.2
   let t1205 = input.min.1*input.stride.1
   let t1206 = max(min(casted.min.0, 1999), 0)
   let t1207 = binary_op$3._0.extent_realized.s + t1206
   let t1208 = max(min(casted.min.1, 1999), 0)
   let t1209 = binary_op$3._1.extent_realized.s + t1208
   let t1210 = max(min(input.min.2, 3), 0)
   let t1211 = max(t1206 + -1, input.min.0)
   let t1212 = t1207 + 7
   let t1213 = max(t1208 + -1, input.min.1)
   let t1214 = t1209 + 7
   let t1182 = min(max(t1203, t1213), t1214)
   let t1197 = min(max(t1202, t1211), t1212)
   let t1181 = min(t1213, t1214)
   let t1196 = min(t1211, t1212)
   let t1180 = max(min(input.extent.2 + input.min.2, 3), 0) - t1210
   let t1186 = sliced.s0._0.max.s - sliced.s0._0.min
   let t1195 = (t1204 + t1205) + input.min.0
   for (binary_op$3.s0._2.rebased, 0, t1180) {
    let t1217 = t1208 - sliced.s0._1.min
    let t1216 = t1206 - sliced.s0._0.min
    let t1215 = t1181 - t1208
    let t1218 = binary_op$3.s0._2.rebased + t1210
    for (binary_op$3.s0._1.rebased, 0, t1215 + 1) {
     let t1231 = input.extent.1*2
     let t1226 = (((t1208 - input.min.1) + binary_op$3.s0._1.rebased) + -1) % t1231
     let t1228 = (input.stride.2*t1218) - t1195
     let t1223 = (((binary_op$3.s0._1.rebased + t1217) + -1)*(t1186 + 2)) + t1216
     let t1230 = (binary_op$3.stride.2*t1218) + ((binary_op$3._0.extent_realized.s + 8)*binary_op$3.s0._1.rebased)
     let t1227 = binary_op$3.s0._1.rebased + t1208
     for (binary_op$3.s0._0.rebased, 0, binary_op$3._0.extent_realized.s + 8) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[(binary_op$3.s0._0.rebased + t1223) + -1]*(t1218 + 2))
      }
      consume all_r$4 {
       let t802 = (((t1206 - input.min.0) + binary_op$3.s0._0.rebased) + -1) % (input.extent.0*2)
       let t960 = binary_op$3.s0._0.rebased + t1206
       binary_op$3[binary_op$3.s0._0.rebased + t1230] = all_r$4[0] + input[select(((t1202 + 1) <= t960) || (t960 < (input.min.0 + 1)), max(min(select(t802 < input.extent.0, t802, ((input.extent.0*2) - t802) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1202, t960) + -1, input.min.0)) + ((select(((t1203 + 1) <= t1227) || (t1227 < (input.min.1 + 1)), max(min(select(t1226 < input.extent.1, t1226, (t1231 - t1226) + -1), input.extent.1 + -1), 0) + input.min.1, max(min(t1203, t1227) + -1, input.min.1))*input.stride.1) + t1228)]
      }
      free all_r$4
     }
    }
    let t1242 = ((t1196 - t1204) - t1205) - input.min.0
    let t1243 = t1207 - t1197
    let t1234 = t1206 - sliced.s0._0.min
    let t1240 = t1197 - t1196
    let t1244 = t1197 - sliced.s0._0.min
    let t1233 = t1196 - t1206
    let t1241 = t1196 - sliced.s0._0.min
    let t1232 = t1182 - t1181
    let t1239 = t1181 - t1208
    let t1235 = t1181 - sliced.s0._1.min
    let t1236 = binary_op$3.s0._2.rebased + t1210
    for (binary_op$3.s0._1.rebased, 0, t1232) {
     let t1247 = ((binary_op$3.s0._1.rebased + t1235)*(t1186 + 2)) + t1234
     let t1250 = ((binary_op$3.s0._1.rebased + t1181)*input.stride.1) + ((input.stride.2*t1236) - t1195)
     let t1251 = (binary_op$3.stride.2*t1236) + (((binary_op$3.s0._1.rebased + t1239) + 1)*(binary_op$3._0.extent_realized.s + 8))
     for (binary_op$3.s0._0.rebased, 0, t1233 + 1) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[(binary_op$3.s0._0.rebased + t1247) + -1]*(t1236 + 2))
      }
      consume all_r$4 {
       let t808 = (((t1206 - input.min.0) + binary_op$3.s0._0.rebased) + -1) % (input.extent.0*2)
       let t965 = binary_op$3.s0._0.rebased + t1206
       binary_op$3[binary_op$3.s0._0.rebased + t1251] = all_r$4[0] + input[select(((t1202 + 1) <= t965) || (t965 < (input.min.0 + 1)), max(min(select(t808 < input.extent.0, t808, ((input.extent.0*2) - t808) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1202, t965) + -1, input.min.0)) + t1250]
      }
      free all_r$4
     }
     let t1254 = (((binary_op$3.s0._1.rebased + t1239) + 1)*(binary_op$3._0.extent_realized.s + 8)) + ((binary_op$3.stride.2*t1236) + t1233)
     let t1252 = ((binary_op$3.s0._1.rebased + t1235)*(t1186 + 2)) + t1241
     let t1253 = ((binary_op$3.s0._1.rebased + t1181)*input.stride.1) + ((input.stride.2*t1236) + t1242)
     for (binary_op$3.s0._0.rebased, 0, t1240) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[binary_op$3.s0._0.rebased + t1252]*(t1236 + 2))
      }
      consume all_r$4 {
       binary_op$3[(binary_op$3.s0._0.rebased + t1254) + 1] = all_r$4[0] + input[binary_op$3.s0._0.rebased + t1253]
      }
      free all_r$4
     }
     let t1259 = (((binary_op$3.s0._1.rebased + t1239) + 1)*(binary_op$3._0.extent_realized.s + 8)) + ((binary_op$3.stride.2*t1236) + (t1197 - t1206))
     let t1255 = ((binary_op$3.s0._1.rebased + t1235)*(t1186 + 2)) + t1244
     let t1258 = ((binary_op$3.s0._1.rebased + t1181)*input.stride.1) + ((input.stride.2*t1236) - t1195)
     for (binary_op$3.s0._0.rebased, 0, t1243 + 7) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[binary_op$3.s0._0.rebased + t1255]*(t1236 + 2))
      }
      consume all_r$4 {
       let t810 = ((t1197 - input.min.0) + binary_op$3.s0._0.rebased) % (input.extent.0*2)
       let t968 = binary_op$3.s0._0.rebased + t1197
       binary_op$3[(binary_op$3.s0._0.rebased + t1259) + 1] = all_r$4[0] + input[select(t968 < t1202, max(min(t1202 + -1, t968), input.min.0), max(min(select(t810 < input.extent.0, t810, ((input.extent.0*2) - t810) + -1), input.extent.0 + -1), 0) + input.min.0) + t1258]
      }
      free all_r$4
     }
    }
    let t1260 = t1209 - t1182
    let t1261 = t1206 - sliced.s0._0.min
    let t1268 = t1182 - t1208
    let t1262 = t1182 - sliced.s0._1.min
    let t1263 = binary_op$3.s0._2.rebased + t1210
    for (binary_op$3.s0._1.rebased, 0, t1260 + 7) {
     let t1277 = input.extent.1*2
     let t1272 = ((t1182 - input.min.1) + binary_op$3.s0._1.rebased) % t1277
     let t1274 = (input.stride.2*t1263) - t1195
     let t1269 = ((binary_op$3.s0._1.rebased + t1262)*(t1186 + 2)) + t1261
     let t1276 = (binary_op$3.stride.2*t1263) + (((binary_op$3.s0._1.rebased + t1268) + 1)*(binary_op$3._0.extent_realized.s + 8))
     let t1273 = binary_op$3.s0._1.rebased + t1182
     for (binary_op$3.s0._0.rebased, 0, binary_op$3._0.extent_realized.s + 8) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[(binary_op$3.s0._0.rebased + t1269) + -1]*(t1263 + 2))
      }
      consume all_r$4 {
       let t812 = (((t1206 - input.min.0) + binary_op$3.s0._0.rebased) + -1) % (input.extent.0*2)
       let t974 = binary_op$3.s0._0.rebased + t1206
       binary_op$3[binary_op$3.s0._0.rebased + t1276] = all_r$4[0] + input[select(((t1202 + 1) <= t974) || (t974 < (input.min.0 + 1)), max(min(select(t812 < input.extent.0, t812, ((input.extent.0*2) - t812) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1202, t974) + -1, input.min.0)) + ((select(t1273 < t1203, max(min(t1203 + -1, t1273), input.min.1), max(min(select(t1272 < input.extent.1, t1272, (t1277 - t1272) + -1), input.extent.1 + -1), 0) + input.min.1)*input.stride.1) + t1274)]
      }
      free all_r$4
     }
    }
   }
   let t1295 = input.extent.2 + input.min.2
   let t1296 = max(min(t1295, 3), 0)
   let t1297 = max(min(casted.min.0, 1999), 0)
   let t1298 = max(min(casted.min.1, 1999), 0)
   let t1280 = t1298 - sliced.s0._1.min
   let t1279 = t1297 - sliced.s0._0.min
   let t1281 = sliced.s0._0.max.s - sliced.s0._0.min
   let t1294 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (binary_op$3.s0._2.rebased, 0, 3 - t1296) {
    let t1309 = input.extent.2*2
    let t1300 = ((t1296 - input.min.2) + binary_op$3.s0._2.rebased) % t1309
    let t1305 = max(min(t1295, 3), 0) + binary_op$3.s0._2.rebased
    let t1299 = binary_op$3.s0._2.rebased + t1296
    for (binary_op$3.s0._1.rebased, 0, binary_op$3._1.extent_realized.s + 8) {
     let t1320 = input.extent.1*2
     let t1313 = (((t1298 - input.min.1) + binary_op$3.s0._1.rebased) + -1) % t1320
     let t1315 = (select(t1305 < t1295, max(min(t1295 + -1, t1305), input.min.2), max(min(select(t1300 < input.extent.2, t1300, (t1309 - t1300) + -1), input.extent.2 + -1), 0) + input.min.2)*input.stride.2) - t1294
     let t1310 = (((binary_op$3.s0._1.rebased + t1280) + -1)*(t1281 + 2)) + t1279
     let t1319 = (binary_op$3.stride.2*t1305) + ((binary_op$3._0.extent_realized.s + 8)*binary_op$3.s0._1.rebased)
     let t1314 = binary_op$3.s0._1.rebased + t1298
     for (binary_op$3.s0._0.rebased, 0, binary_op$3._0.extent_realized.s + 8) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       all_r$4[0] = all_r$4[0] + (sliced[(binary_op$3.s0._0.rebased + t1310) + -1]*(t1299 + 2))
      }
      consume all_r$4 {
       let t818 = (((t1297 - input.min.0) + binary_op$3.s0._0.rebased) + -1) % (input.extent.0*2)
       let t980 = binary_op$3.s0._0.rebased + t1297
       let t1593 = input.extent.0 + input.min.0
       let t1594 = input.extent.1 + input.min.1
       binary_op$3[binary_op$3.s0._0.rebased + t1319] = all_r$4[0] + input[select(((t1593 + 1) <= t980) || (t980 < (input.min.0 + 1)), max(min(select(t818 < input.extent.0, t818, ((input.extent.0*2) - t818) + -1), input.extent.0 + -1), 0) + input.min.0, max(min(t1593, t980) + -1, input.min.0)) + ((select(((t1594 + 1) <= t1314) || (t1314 < (input.min.1 + 1)), max(min(select(t1313 < input.extent.1, t1313, (t1320 - t1313) + -1), input.extent.1 + -1), 0) + input.min.1, max(min(t1594, t1314) + -1, input.min.1))*input.stride.1) + t1315)]
      }
      free all_r$4
     }
    }
   }
  }
 }
 let pooled2D_w__0_1.stride.2 = (binary_op$3._0.extent_realized.s + 2)*(binary_op$3._1.extent_realized.s + 2)
 allocate pooled2D_w__0_1[int16 * (binary_op$3._0.extent_realized.s + 2) * (binary_op$3._1.extent_realized.s + 2) * 3]
 produce pooled2D_w__0_1 {
  consume binary_op$3 {
   for (pooled2D_w__0_1.s0._2, 0, 3) {
    let t1322 = pooled2D_w__0_1.s0._2*pooled2D_w__0_1.stride.2
    let t1321 = binary_op$3.stride.2*pooled2D_w__0_1.s0._2
    for (pooled2D_w__0_1.s0._1.rebased, 0, binary_op$3._1.extent_realized.s + 2) {
     let t1323 = ((binary_op$3._0.extent_realized.s + 2)*pooled2D_w__0_1.s0._1.rebased) + t1322
     for (pooled2D_w__0_1.s0._0.rebased, 0, binary_op$3._0.extent_realized.s + 2) {
      allocate sum[int32 * 1]
      produce sum {
       sum[0] = 0
       let t1324 = pooled2D_w__0_1.s0._0.rebased + t1321
       for (sum.s1.r155$y.rebased, 0, 7) {
        let t1325 = ((pooled2D_w__0_1.s0._1.rebased + sum.s1.r155$y.rebased)*(binary_op$3._0.extent_realized.s + 8)) + t1324
        for (sum.s1.r155$x.rebased, 0, 7) {
         sum[0] = sum[0] + binary_op$3[sum.s1.r155$x.rebased + t1325]
        }
       }
      }
      consume sum {
       pooled2D_w__0_1[pooled2D_w__0_1.s0._0.rebased + t1323] = int16(sum[0])/(int16)49
      }
      free sum
     }
    }
   }
  }
 }
 free binary_op$3
 let constant_exterior.stride.2 = (casted.extent.0 + 2)*(casted.extent.1 + 2)
 allocate constant_exterior[int16 * (casted.extent.0 + 2) * (casted.extent.1 + 2) * 3]
 produce constant_exterior {
  consume pooled2D_w__0_1 {
   let t1334 = casted.extent.0 + casted.min.0
   let t1335 = casted.extent.1 + casted.min.1
   let t1336 = min(max(casted.min.0, 0), t1334 + 2)
   let t1337 = min(max(casted.min.1, 0), t1335 + 2)
   let t1327 = max(min(t1335, 1998) + 2, t1337)
   let t1331 = max(min(t1334, 1998) + 2, t1336)
   let t1329 = max(min(casted.min.1, 1999), 0)
   let t1328 = max(min(casted.min.0, 1999), 0)
   for (constant_exterior.s0._2, 0, 3) {
    let t1340 = constant_exterior.s0._2*constant_exterior.stride.2
    let t1339 = (constant_exterior.s0._2*pooled2D_w__0_1.stride.2) - t1328
    let t1338 = t1337 - casted.min.1
    for (constant_exterior.s0._1.rebased, 0, t1338) {
     let t1342 = ((casted.extent.0 + 2)*constant_exterior.s0._1.rebased) + t1340
     let t1341 = casted.min.1 + constant_exterior.s0._1.rebased
     for (constant_exterior.s0._0.rebased, 0, casted.extent.0 + 2) {
      let t982 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t1342] = select(((2000 <= t982) || (t982 < 0)) || (t1341 < 0), (int16)0, pooled2D_w__0_1[max(min(t982, 1999), 0) + (((max(t1341, 0) - t1329)*(binary_op$3._0.extent_realized.s + 2)) + t1339)])
     }
    }
    let t1354 = constant_exterior.s0._2*constant_exterior.stride.2
    let t1355 = t1336 - casted.min.0
    let t1356 = constant_exterior.s0._2*pooled2D_w__0_1.stride.2
    let t1345 = t1356 - t1328
    let t1346 = t1337 - t1329
    let t1348 = t1337 - casted.min.1
    let t1352 = t1334 - t1331
    let t1349 = t1331 - t1336
    let t1343 = t1327 - t1337
    let t1350 = (t1336 - t1328) + t1356
    let t1353 = (t1331 - casted.min.0) + t1354
    for (constant_exterior.s0._1.rebased, 0, t1343) {
     let t1358 = ((constant_exterior.s0._1.rebased + t1348)*(casted.extent.0 + 2)) + t1354
     let t1357 = ((constant_exterior.s0._1.rebased + t1346)*(binary_op$3._0.extent_realized.s + 2)) + t1345
     for (constant_exterior.s0._0.rebased, 0, t1355) {
      let t985 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t1358] = select(t985 < 0, (int16)0, pooled2D_w__0_1[max(t985, 0) + t1357])
     }
     let t1360 = ((constant_exterior.s0._1.rebased + t1348)*(casted.extent.0 + 2)) + (t1354 + t1355)
     let t1359 = ((constant_exterior.s0._1.rebased + t1346)*(binary_op$3._0.extent_realized.s + 2)) + t1350
     for (constant_exterior.s0._0.rebased, 0, t1349) {
      constant_exterior[constant_exterior.s0._0.rebased + t1360] = pooled2D_w__0_1[constant_exterior.s0._0.rebased + t1359]
     }
     let t1362 = ((constant_exterior.s0._1.rebased + t1348)*(casted.extent.0 + 2)) + t1353
     let t1361 = ((constant_exterior.s0._1.rebased + t1346)*(binary_op$3._0.extent_realized.s + 2)) + t1345
     for (constant_exterior.s0._0.rebased, 0, t1352 + 2) {
      let t986 = constant_exterior.s0._0.rebased + t1331
      constant_exterior[constant_exterior.s0._0.rebased + t1362] = select(t986 < 2000, pooled2D_w__0_1[max(min(t986, 1999), 0) + t1361], (int16)0)
     }
    }
    let t1365 = constant_exterior.s0._2*constant_exterior.stride.2
    let t1364 = (constant_exterior.s0._2*pooled2D_w__0_1.stride.2) - t1328
    let t1363 = t1335 - t1327
    let t1366 = t1327 - casted.min.1
    for (constant_exterior.s0._1.rebased, 0, t1363 + 2) {
     let t1368 = ((constant_exterior.s0._1.rebased + t1366)*(casted.extent.0 + 2)) + t1365
     let t1367 = constant_exterior.s0._1.rebased + t1327
     for (constant_exterior.s0._0.rebased, 0, casted.extent.0 + 2) {
      let t987 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t1368] = select(((2000 <= t987) || (t987 < 0)) || (2000 <= t1367), (int16)0, pooled2D_w__0_1[max(min(t987, 1999), 0) + (((max(min(t1367, 1999), 0) - t1329)*(binary_op$3._0.extent_realized.s + 2)) + t1364)])
     }
    }
   }
  }
 }
 free pooled2D_w__0_1
 allocate binary_op$4[int32 * (casted.extent.0 + 2) * (casted.extent.1 + 2) * 3]
 produce binary_op$4 {
  consume constant_exterior {
   consume sliced {
    let t1371 = sliced.s0._0.max.s - sliced.s0._0.min
    let t1370 = casted.min.1 - sliced.s0._1.min
    let t1369 = casted.min.0 - sliced.s0._0.min
    for (binary_op$4.s0._2, 0, 3) {
     let t1372 = binary_op$4.s0._2*constant_exterior.stride.2
     for (binary_op$4.s0._1.rebased, 0, casted.extent.1 + 2) {
      let t1374 = ((casted.extent.0 + 2)*binary_op$4.s0._1.rebased) + t1372
      let t1373 = ((binary_op$4.s0._1.rebased + t1370)*(t1371 + 2)) + t1369
      for (binary_op$4.s0._0.rebased, 0, casted.extent.0 + 2) {
       allocate all_r$6[int32 * 1]
       produce all_r$6 {
        all_r$6[0] = 0
        all_r$6[0] = all_r$6[0] + (sliced[binary_op$4.s0._0.rebased + t1373]*(binary_op$4.s0._2 + 2))
       }
       consume all_r$6 {
        let t823 = binary_op$4.s0._0.rebased + t1374
        binary_op$4[t823] = min(all_r$6[0], int32(constant_exterior[t823]))
       }
       free all_r$6
      }
     }
    }
   }
  }
 }
 free sliced
 free constant_exterior
 allocate conv2D_r__0_1[int32 * casted.extent.0 * casted.extent.1 * 25]
 produce conv2D_r__0_1 {
  for (conv2D_r__0_1.s0._2, 0, 25) {
   let t1376 = (casted.extent.0*casted.extent.1)*conv2D_r__0_1.s0._2
   for (conv2D_r__0_1.s0._1.rebased, 0, casted.extent.1) {
    let t1377 = (casted.extent.0*conv2D_r__0_1.s0._1.rebased) + t1376
    for (conv2D_r__0_1.s0._0.rebased, 0, casted.extent.0) {
     conv2D_r__0_1[conv2D_r__0_1.s0._0.rebased + t1377] = 0
    }
   }
  }
  consume binary_op$4 {
   let t1378 = max(min(int32_weights.min.3, 25), 0)
   let t1381 = ((int32_weights.min.1*int32_weights.stride.1) + ((int32_weights.min.3*int32_weights.stride.3) + (int32_weights.min.2*int32_weights.stride.2))) + int32_weights.min.0
   let t1380 = int32_weights.extent.3 + int32_weights.min.3
   let t1383 = int32_weights.extent.2 + int32_weights.min.2
   let t1384 = int32_weights.extent.1 + int32_weights.min.1
   let t1382 = int32_weights.extent.0 + int32_weights.min.0
   for (conv2D_r__0_1.s1._2, 0, t1378) {
    let t1385 = (casted.extent.0*casted.extent.1)*conv2D_r__0_1.s1._2
    let t1386 = (max(min(t1380 + -1, conv2D_r__0_1.s1._2), int32_weights.min.3)*int32_weights.stride.3) - t1381
    for (conv2D_r__0_1.s1._1.rebased, 0, casted.extent.1) {
     let t1387 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t1385
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t1388 = conv2D_r__0_1.s1._0.rebased + t1387
      for (conv2D_r__0_1.s1.r262$z, 0, 3) {
       let t1389 = max(min(t1382 + -1, conv2D_r__0_1.s1.r262$z), int32_weights.min.0) + t1386
       let t1390 = (constant_exterior.stride.2*conv2D_r__0_1.s1.r262$z) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r262$y, 0, 3) {
        let t1391 = (max(min(t1383 + -1, conv2D_r__0_1.s1.r262$y), int32_weights.min.2)*int32_weights.stride.2) + t1389
        let t1392 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r262$y)*(casted.extent.0 + 2)) + t1390
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1388] = conv2D_r__0_1[t1388] + (int32_weights[(max(min(t1384 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1391]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1392])
        }
       }
      }
     }
    }
   }
   let t1412 = int32_weights.extent.0 + int32_weights.min.0
   let t1413 = int32_weights.extent.1 + int32_weights.min.1
   let t1414 = int32_weights.extent.2 + int32_weights.min.2
   let t1415 = int32_weights.min.1*int32_weights.stride.1
   let t1416 = int32_weights.min.3*int32_weights.stride.3
   let t1417 = int32_weights.min.2*int32_weights.stride.2
   let t1418 = max(min(t1412, 3), 0)
   let t1419 = max(min(t1413, 3), 0)
   let t1420 = max(min(t1414, 3), 0)
   let t1421 = max(min(int32_weights.min.0, 3), 0)
   let t1422 = max(min(int32_weights.min.1, 3), 0)
   let t1423 = max(min(int32_weights.min.2, 3), 0)
   let t1424 = max(min(int32_weights.min.3, 25), 0)
   let t1393 = max(min(int32_weights.extent.3 + int32_weights.min.3, 25), 0) - t1424
   let t1406 = t1420 - t1423
   let t1408 = t1419 - t1422
   let t1401 = t1418 - t1421
   let t1410 = 3 - t1420
   let t1409 = 3 - t1419
   let t1411 = 3 - t1418
   let t1397 = ((t1416 + t1417) + t1415) + int32_weights.min.0
   for (conv2D_r__0_1.s1._2.rebased, 0, t1393) {
    let t1431 = conv2D_r__0_1.s1._2.rebased + t1424
    let t1432 = int32_weights.stride.3*t1431
    let t1429 = max(min(t1414, 3), 0)
    let t1428 = max(min(t1413, 3), 0)
    let t1430 = max(min(t1412, 3), 0)
    let t1425 = (casted.extent.0*casted.extent.1)*t1431
    let t1426 = t1432 - t1397
    let t1427 = ((((t1421 - t1416) - t1417) - t1415) - int32_weights.min.0) + t1432
    for (conv2D_r__0_1.s1._1.rebased, 0, casted.extent.1) {
     let t1433 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t1425
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t1436 = conv2D_r__0_1.s1._0.rebased + t1433
      for (conv2D_r__0_1.s1.r262$z, 0, t1421) {
       let t1437 = max(min(t1412 + -1, conv2D_r__0_1.s1.r262$z), int32_weights.min.0) + t1426
       let t1438 = (constant_exterior.stride.2*conv2D_r__0_1.s1.r262$z) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r262$y, 0, 3) {
        let t1439 = (max(min(t1414 + -1, conv2D_r__0_1.s1.r262$y), int32_weights.min.2)*int32_weights.stride.2) + t1437
        let t1440 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r262$y)*(casted.extent.0 + 2)) + t1438
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1436] = conv2D_r__0_1[t1436] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1439]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1440])
        }
       }
      }
      let t1441 = conv2D_r__0_1.s1._0.rebased + t1433
      for (conv2D_r__0_1.s1.r262$z.rebased, 0, t1401) {
       let t1447 = ((conv2D_r__0_1.s1.r262$z.rebased + t1421)*constant_exterior.stride.2) + conv2D_r__0_1.s1._0.rebased
       let t1446 = conv2D_r__0_1.s1.r262$z.rebased + t1427
       for (conv2D_r__0_1.s1.r262$y, 0, t1423) {
        let t1448 = (max(min(t1414 + -1, conv2D_r__0_1.s1.r262$y), int32_weights.min.2)*int32_weights.stride.2) + t1446
        let t1449 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r262$y)*(casted.extent.0 + 2)) + t1447
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1441] = conv2D_r__0_1[t1441] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1448]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1449])
        }
       }
       let t1455 = (conv2D_r__0_1.s1.r262$z.rebased + t1421)*constant_exterior.stride.2
       let t1454 = (conv2D_r__0_1.s1._0.rebased + t1428) + t1455
       let t1453 = (conv2D_r__0_1.s1._0.rebased + t1422) + t1455
       let t1451 = conv2D_r__0_1.s1._0.rebased + t1455
       let t1450 = conv2D_r__0_1.s1.r262$z.rebased + t1427
       let t1452 = conv2D_r__0_1.s1._1.rebased + t1423
       for (conv2D_r__0_1.s1.r262$y.rebased, 0, t1406) {
        let t1457 = ((conv2D_r__0_1.s1.r262$y.rebased + t1452)*(casted.extent.0 + 2)) + t1451
        let t1456 = ((conv2D_r__0_1.s1.r262$y.rebased + t1423)*int32_weights.stride.2) + t1450
        for (conv2D_r__0_1.s1.r262$x, 0, t1422) {
         conv2D_r__0_1[t1441] = conv2D_r__0_1[t1441] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1456]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1457])
        }
        let t1459 = ((conv2D_r__0_1.s1.r262$y.rebased + t1452)*(casted.extent.0 + 2)) + t1453
        let t1458 = ((conv2D_r__0_1.s1.r262$y.rebased + t1423)*int32_weights.stride.2) + t1450
        for (conv2D_r__0_1.s1.r262$x.rebased, 0, t1408) {
         conv2D_r__0_1[t1441] = conv2D_r__0_1[t1441] + (int32_weights[((conv2D_r__0_1.s1.r262$x.rebased + t1422)*int32_weights.stride.1) + t1458]*binary_op$4[conv2D_r__0_1.s1.r262$x.rebased + t1459])
        }
        let t1461 = ((conv2D_r__0_1.s1.r262$y.rebased + t1452)*(casted.extent.0 + 2)) + t1454
        let t1460 = ((conv2D_r__0_1.s1.r262$y.rebased + t1423)*int32_weights.stride.2) + t1450
        for (conv2D_r__0_1.s1.r262$x.rebased, 0, t1409) {
         conv2D_r__0_1[t1441] = conv2D_r__0_1[t1441] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x.rebased + t1428), int32_weights.min.1)*int32_weights.stride.1) + t1460]*binary_op$4[conv2D_r__0_1.s1.r262$x.rebased + t1461])
        }
       }
       let t1463 = ((conv2D_r__0_1.s1.r262$z.rebased + t1421)*constant_exterior.stride.2) + conv2D_r__0_1.s1._0.rebased
       let t1462 = conv2D_r__0_1.s1.r262$z.rebased + t1427
       let t1464 = conv2D_r__0_1.s1._1.rebased + t1429
       for (conv2D_r__0_1.s1.r262$y.rebased, 0, t1410) {
        let t1465 = (max(min(t1414 + -1, conv2D_r__0_1.s1.r262$y.rebased + t1429), int32_weights.min.2)*int32_weights.stride.2) + t1462
        let t1466 = ((conv2D_r__0_1.s1.r262$y.rebased + t1464)*(casted.extent.0 + 2)) + t1463
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1441] = conv2D_r__0_1[t1441] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1465]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1466])
        }
       }
      }
      let t1467 = conv2D_r__0_1.s1._0.rebased + t1433
      for (conv2D_r__0_1.s1.r262$z.rebased, 0, t1411) {
       let t1468 = conv2D_r__0_1.s1.r262$z.rebased + t1430
       for (conv2D_r__0_1.s1.r262$y, 0, 3) {
        let t1469 = (max(min(t1414 + -1, conv2D_r__0_1.s1.r262$y), int32_weights.min.2)*int32_weights.stride.2) + (max(min(t1412 + -1, t1468), int32_weights.min.0) + t1426)
        let t1470 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r262$y)*(casted.extent.0 + 2)) + ((constant_exterior.stride.2*t1468) + conv2D_r__0_1.s1._0.rebased)
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1467] = conv2D_r__0_1[t1467] + (int32_weights[(max(min(t1413 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1469]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1470])
        }
       }
      }
     }
    }
   }
   let t1479 = int32_weights.extent.3 + int32_weights.min.3
   let t1480 = max(min(t1479, 25), 0)
   let t1475 = ((int32_weights.min.1*int32_weights.stride.1) + ((int32_weights.min.3*int32_weights.stride.3) + (int32_weights.min.2*int32_weights.stride.2))) + int32_weights.min.0
   let t1477 = int32_weights.extent.2 + int32_weights.min.2
   let t1478 = int32_weights.extent.1 + int32_weights.min.1
   let t1476 = int32_weights.extent.0 + int32_weights.min.0
   for (conv2D_r__0_1.s1._2.rebased, 0, 25 - t1480) {
    let t1481 = (casted.extent.0*casted.extent.1)*(conv2D_r__0_1.s1._2.rebased + t1480)
    let t1482 = (max(min(t1479 + -1, max(min(t1479, 25), 0) + conv2D_r__0_1.s1._2.rebased), int32_weights.min.3)*int32_weights.stride.3) - t1475
    for (conv2D_r__0_1.s1._1.rebased, 0, casted.extent.1) {
     let t1483 = (casted.extent.0*conv2D_r__0_1.s1._1.rebased) + t1481
     for (conv2D_r__0_1.s1._0.rebased, 0, casted.extent.0) {
      let t1484 = conv2D_r__0_1.s1._0.rebased + t1483
      for (conv2D_r__0_1.s1.r262$z, 0, 3) {
       let t1485 = max(min(t1476 + -1, conv2D_r__0_1.s1.r262$z), int32_weights.min.0) + t1482
       let t1486 = (constant_exterior.stride.2*conv2D_r__0_1.s1.r262$z) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r262$y, 0, 3) {
        let t1487 = (max(min(t1477 + -1, conv2D_r__0_1.s1.r262$y), int32_weights.min.2)*int32_weights.stride.2) + t1485
        let t1488 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r262$y)*(casted.extent.0 + 2)) + t1486
        for (conv2D_r__0_1.s1.r262$x, 0, 3) {
         conv2D_r__0_1[t1484] = conv2D_r__0_1[t1484] + (int32_weights[(max(min(t1478 + -1, conv2D_r__0_1.s1.r262$x), int32_weights.min.1)*int32_weights.stride.1) + t1487]*binary_op$4[conv2D_r__0_1.s1.r262$x + t1488])
        }
       }
      }
     }
    }
   }
   free binary_op$4
  }
 }
 allocate all_w$1[int32 * casted.extent.0 * casted.extent.1 * 17]
 produce all_w$1 {
  consume conv2D_r__0_1 {
   for (all_w$1.s0._2, 0, 17) {
    let t1492 = casted.extent.0*casted.extent.1
    for (all_w$1.s0._1.rebased, 0, casted.extent.1) {
     let t1495 = all_w$1.s0._1.rebased*casted.extent.0
     let t1494 = (all_w$1.s0._2*t1492) + t1495
     for (all_w$1.s0._0.rebased, 0, casted.extent.0) {
      allocate sum$2[int32 * 1]
      produce sum$2 {
       sum$2[0] = 0
       let t1496 = all_w$1.s0._0.rebased + t1495
       for (sum$2.s1.r273$x, 0, 25) {
        sum$2[0] = sum$2[0] + (conv2D_r__0_1[(sum$2.s1.r273$x*t1492) + t1496]*(((sum$2.s1.r273$x*25) + all_w$1.s0._2) + 26))
       }
      }
      consume sum$2 {
       all_w$1[all_w$1.s0._0.rebased + t1494] = sum$2[0]
      }
      free sum$2
     }
    }
   }
  }
 }
 free conv2D_r__0_1
 produce casted {
  consume all_w$1 {
   let t1498 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t1502 = casted.min.2 + casted.s0._2.rebased
    let t1501 = (casted.stride.2*t1502) + t1498
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t1503 = casted.extent.0*casted.s0._1.rebased
     let t1504 = casted.extent.0*casted.extent.1
     let t1505 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t1501
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$7[int32 * 1]
      produce all_r$7 {
       all_r$7[0] = 0
       let t1506 = casted.s0._0.rebased + t1503
       for (all_r$7.s1.r295$x, 0, 17) {
        all_r$7[0] = all_r$7[0] + (all_w$1[(all_r$7.s1.r295$x*t1504) + t1506]*(((all_r$7.s1.r295$x*17) + t1502) + 18))
       }
      }
      consume all_r$7 {
       casted[casted.s0._0.rebased + t1505] = all_r$7[0]
      }
      free all_r$7
     }
    }
   }
  }
 }
 free all_w$1
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1030 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1039 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1077 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1102 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1129 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1138 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.2*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1167 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1179 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1231 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1277 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1309 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t1320 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
((input.extent.0*2) != 0)
add_temp_object_file: /tmp/PI2c2Z/random_pipeline.a.o
Module.compile(): temporary object /tmp/PI2c2Z/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50080_0/random_pipeline.a
file_unlink: /tmp/PI2c2Z/random_pipeline.a.o
dir_rmdir: /tmp/PI2c2Z
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50080_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50080_0/random_pipeline.registration.cpp
