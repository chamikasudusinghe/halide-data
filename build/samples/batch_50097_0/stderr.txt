Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50097_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(all(_0, _1, _2) % all_r(_0, _1, _2))
(repeat_image(_0, _1, _2) < conv_w__1(_0, _1, _2))
(let t13 = all_r$1(_0, _1, _2) in (max(all$2(_0, _1, _2), t13)/t13))
In random expression: (let t21 = conv_r__0(_0, _1, _2) in max(t21*t21, t21))
The following expressions were unused:
all_r$4(_0, _1, _2)
(let t22 = all_r$4(_0, _1, _2) in (let t23 = conv_r__0(_0, _1, _2) in (min(select(t22 == 0, 0, 1), t22) < ((t22 + t23) % t23))))
In random expression: ((uint1)binary_op$1(_0, _1, _2) && (uint1)binary_op$1(_0 + 2, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0 + 1, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0 + 1, _1, _2) && (uint1)binary_op$1(_0 + 2, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0 + 2, _1, _2) && (uint1)binary_op$1(_0 + 3, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(uint1)binary_op$1(_0 + 1, _1, _2)
In random expression: uint32(((uint1)binary_op$1(_0 + 1, _1, _2) && (uint1)binary_op$1(_0 + 3, _1, _2)))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(uint1)binary_op$1(_0 + 2, _1, _2)
In random expression: ((uint1)binary_op$1(_0, _1, _2) && (uint1)binary_op$1(_0 + 1, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0 + 2, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0, _1, _2) && (uint1)binary_op$1(_0 + 2, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0 + 1, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: (let t26 = (uint1)binary_op$1(_0 + 1, _1, _2) in select((uint1)binary_op$1(_0, _1, _2) == t26, (uint1)binary_op$1(_0 + 2, _1, _2), t26))
The following expressions were unused:
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0 + 1, _1, _2) && (uint1)binary_op$1(_0 + 2, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0, _1, _2) && (uint1)binary_op$1(_0 + 2, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0 + 1, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
In random expression: ((uint1)binary_op$1(_0 + 2, _1, _2) || (uint1)binary_op$1(_0 + 1, _1, _2))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(uint1)binary_op$1(_0 + 3, _1, _2)
(((((uint8)0 + uint8((uint1)binary_op$1(_0, _1, _2))) + uint8((uint1)binary_op$1(_0 + 1, _1, _2))) + uint8((uint1)binary_op$1(_0 + 2, _1, _2))) + uint8((uint1)binary_op$1(_0 + 3, _1, _2)))
(let t29 = all$2(_0, _1, _2) in (max(t29, 0)/(all_r$5(_0, _1, _2)*t29)))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$6 }
Injecting realization of { binary_op$4 }
Injecting realization of { all_r$5 }
Injecting realization of { conv__0 }
Injecting realization of { binary_op$1 }
Injecting realization of { all$2 }
Injecting realization of { binary_op }
Injecting realization of { all_r }
Injecting realization of { all }
Injecting realization of { conv_w__1 }
Injecting realization of { sum }
Inlining repeat_image
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required.s = let t777 = (input.extent.0 + input.min.0) in (let t778 = (casted.extent.0 + casted.min.0) in (let t779 = ((t777 <= casted.min.0) || (t778 < (input.min.0 + -2))) in (let t780 = (input.min.0 + max(-1 - input.extent.0, max(input.extent.0, 1) + -1)) in (let t781 = max(min(t778 + 3, t777) + -1, input.min.0) in (let t782 = (((t777 + -2) <= t778) || (casted.min.0 < input.min.0)) in (let t783 = max(min(t777 + -1, casted.min.0), input.min.0) in (max(select(t779, t780, t781), select(t782, t780, t781)) - min(select(t779, input.min.0, t783), select(t782, input.min.0, t783)))))))))
let input.min.0.required = let t784 = (input.extent.0 + input.min.0) in (let t785 = (casted.extent.0 + casted.min.0) in (let t786 = max(min(t784 + -1, casted.min.0), input.min.0) in min(select((t784 <= casted.min.0) || (t785 < (input.min.0 + -2)), input.min.0, t786), select(((t784 + -2) <= t785) || (casted.min.0 < input.min.0), input.min.0, t786))))
let input.extent.1.required.s = let t787 = (input.extent.1 + input.min.1) in (let t788 = (casted.extent.1 + casted.min.1) in (let t789 = (((t787 + 1) <= t788) || (casted.min.1 < input.min.1)) in (let t790 = (input.min.1 + max(-1 - input.extent.1, max(input.extent.1, 1) + -1)) in (let t791 = max(min(t788, t787) + -1, input.min.1) in (let t792 = ((t787 <= casted.min.1) || (t788 < (input.min.1 + 1))) in (let t793 = (((t787 + 8) <= casted.min.1) || (t788 < (input.min.1 + -6))) in (let t794 = max(min(t788 + 7, t787) + -1, input.min.1) in (let t795 = (((t787 + -6) <= t788) || (casted.min.1 < (input.min.1 + 8))) in (let t796 = max(min(t787 + -1, casted.min.1), input.min.1) in (let t797 = max(min(t787 + 7, casted.min.1) + -8, input.min.1) in (max(select(t789, t790, t791), max(select(t792, t790, t791), max(select(t793, t790, t794), select(t795, t790, t794)))) - min(select(t789, input.min.1, t796), min(select(t792, input.min.1, t796), min(select(t793, input.min.1, t797), select(t795, input.min.1, t797)))))))))))))))
let input.min.1.required = let t798 = (input.extent.1 + input.min.1) in (let t799 = (casted.extent.1 + casted.min.1) in (let t800 = max(min(t798 + -1, casted.min.1), input.min.1) in (let t801 = max(min(t798 + 7, casted.min.1) + -8, input.min.1) in min(select(((t798 + 1) <= t799) || (casted.min.1 < input.min.1), input.min.1, t800), min(select((t798 <= casted.min.1) || (t799 < (input.min.1 + 1)), input.min.1, t800), min(select(((t798 + 8) <= casted.min.1) || (t799 < (input.min.1 + -6)), input.min.1, t801), select(((t798 + -6) <= t799) || (casted.min.1 < (input.min.1 + 8)), input.min.1, t801)))))))
let input.extent.2.required.s = let t802 = (input.extent.2 + input.min.2) in (let t803 = ((t802 <= 0) || (2 < input.min.2)) in (let t804 = (input.min.2 + max(-1 - input.extent.2, max(input.extent.2, 1) + -1)) in (let t805 = max(min(t802, 3) + -1, input.min.2) in (let t806 = ((t802 <= 2) || (0 < input.min.2)) in (let t807 = max(min(t802, 1) + -1, input.min.2) in (max(select(t803, t804, t805), select(t806, t804, t805)) - min(select(t803, input.min.2, t807), select(t806, input.min.2, t807))))))))
let input.min.2.required = let t808 = (input.extent.2 + input.min.2) in (let t809 = max(min(t808, 1) + -1, input.min.2) in min(select((t808 <= 0) || (2 < input.min.2), input.min.2, t809), select((t808 <= 2) || (0 < input.min.2), input.min.2, t809)))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 allocate conv_w__1[int32 * (casted.extent.0 + 3) * casted.extent.1 * 3]
 produce conv_w__1 {
  let t470 = max(min(input.min.2, 3), 0)
  let t477 = (casted.extent.0 + 3)*casted.extent.1
  let t474 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (conv_w__1.s0._2, 0, t470) {
   let t484 = input.extent.2 + input.min.2
   let t483 = conv_w__1.s0._2*t477
   let t478 = (select((t484 <= conv_w__1.s0._2) || (conv_w__1.s0._2 < input.min.2), ((conv_w__1.s0._2 - input.min.2) % input.extent.2) + input.min.2, max(min(t484 + -1, conv_w__1.s0._2), input.min.2))*input.stride.2) - t474
   for (conv_w__1.s0._1.rebased, 0, casted.extent.1) {
    let t490 = ((casted.extent.0 + 3)*conv_w__1.s0._1.rebased) + t483
    let t489 = (casted.min.1 - input.min.1) + conv_w__1.s0._1.rebased
    let t485 = casted.min.1 + conv_w__1.s0._1.rebased
    for (conv_w__1.s0._0.rebased, 0, casted.extent.0 + 3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t493 = (((casted.min.0 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t492 = input.extent.0 + input.min.0
      let t491 = casted.min.0 + conv_w__1.s0._0.rebased
      for (sum.s1.r85$x.rebased, 0, 16) {
       let t422 = sum.s1.r85$x.rebased + t485
       let t810 = input.extent.1 + input.min.1
       sum[0] = sum[0] + (input[(select(((t810 + 8) <= t422) || (t422 < (input.min.1 + 8)), (((sum.s1.r85$x.rebased + t489) + -8) % input.extent.1) + input.min.1, max(min(t810 + 7, t422) + -8, input.min.1))*input.stride.1) + (select((t492 <= t491) || (t491 < input.min.0), t493, max(min(t492 + -1, t491), input.min.0)) + t478)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t490] = sum[0]
     }
     free sum
    }
   }
  }
  let t511 = casted.extent.0 + casted.min.0
  let t512 = casted.extent.1 + casted.min.1
  let t513 = input.extent.0 + input.min.0
  let t514 = input.extent.1 + input.min.1
  let t515 = input.min.2*input.stride.2
  let t516 = input.min.1*input.stride.1
  let t517 = max(min(input.min.2, 3), 0)
  let t518 = max(casted.min.0, input.min.0)
  let t519 = t511 + 3
  let t520 = max(input.min.1 + 8, casted.min.1)
  let t497 = min(max(t514 + -7, t520), t512)
  let t506 = min(max(t513, t518), t519)
  let t496 = min(t512, t520)
  let t505 = min(t518, t519)
  let t504 = (casted.extent.0 + 3)*casted.extent.1
  let t495 = max(min(input.extent.2 + input.min.2, 3), 0) - t517
  let t501 = (t515 + t516) + input.min.0
  for (conv_w__1.s0._2.rebased, 0, t495) {
   let t526 = conv_w__1.s0._2.rebased + t517
   let t525 = t504*t526
   let t522 = (input.stride.2*t526) - t501
   let t521 = t496 - casted.min.1
   for (conv_w__1.s0._1.rebased, 0, t521) {
    let t530 = ((casted.extent.0 + 3)*conv_w__1.s0._1.rebased) + t525
    let t529 = (casted.min.1 - input.min.1) + conv_w__1.s0._1.rebased
    let t527 = casted.min.1 + conv_w__1.s0._1.rebased
    for (conv_w__1.s0._0.rebased, 0, casted.extent.0 + 3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t532 = (((casted.min.0 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t531 = casted.min.0 + conv_w__1.s0._0.rebased
      for (sum.s1.r85$x.rebased, 0, 16) {
       let t426 = sum.s1.r85$x.rebased + t527
       sum[0] = sum[0] + (input[(select(((t514 + 8) <= t426) || (t426 < (input.min.1 + 8)), (((sum.s1.r85$x.rebased + t529) + -8) % input.extent.1) + input.min.1, max(min(t514 + 7, t426) + -8, input.min.1))*input.stride.1) + (select((t513 <= t531) || (t531 < input.min.0), t532, max(min(t513 + -1, t531), input.min.0)) + t522)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t530] = sum[0]
     }
     free sum
    }
   }
   let t545 = conv_w__1.s0._2.rebased + t517
   let t546 = input.stride.2*t545
   let t547 = t504*t545
   let t548 = t505 - casted.min.0
   let t535 = t546 - t501
   let t542 = t511 - t506
   let t539 = t506 - t505
   let t533 = t497 - t496
   let t538 = t496 - casted.min.1
   let t544 = (t506 - casted.min.0) + t547
   let t540 = (((t505 - t515) - t516) - input.min.0) + t546
   for (conv_w__1.s0._1.rebased, 0, t533) {
    let t551 = ((conv_w__1.s0._1.rebased + t538)*(casted.extent.0 + 3)) + t547
    let t550 = conv_w__1.s0._1.rebased + t496
    for (conv_w__1.s0._0.rebased, 0, t548) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t553 = (((casted.min.0 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t552 = casted.min.0 + conv_w__1.s0._0.rebased
      for (sum.s1.r85$x.rebased, 0, 16) {
       sum[0] = sum[0] + (input[(((sum.s1.r85$x.rebased + t550) + -8)*input.stride.1) + (select((t513 <= t552) || (t552 < input.min.0), t553, max(min(t513 + -1, t552), input.min.0)) + t535)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t551] = sum[0]
     }
     free sum
    }
    let t555 = ((conv_w__1.s0._1.rebased + t538)*(casted.extent.0 + 3)) + (t547 + t548)
    let t554 = conv_w__1.s0._1.rebased + t496
    for (conv_w__1.s0._0.rebased, 0, t539) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t556 = conv_w__1.s0._0.rebased + t540
      for (sum.s1.r85$x.rebased, 0, 16) {
       sum[0] = sum[0] + (input[(((sum.s1.r85$x.rebased + t554) + -8)*input.stride.1) + t556]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t555] = sum[0]
     }
     free sum
    }
    let t559 = ((conv_w__1.s0._1.rebased + t538)*(casted.extent.0 + 3)) + t544
    let t558 = conv_w__1.s0._1.rebased + t496
    for (conv_w__1.s0._0.rebased, 0, t542 + 3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t561 = (((t506 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t560 = conv_w__1.s0._0.rebased + t506
      for (sum.s1.r85$x.rebased, 0, 16) {
       sum[0] = sum[0] + (input[(((sum.s1.r85$x.rebased + t558) + -8)*input.stride.1) + (select(t560 < t513, max(min(t513 + -1, t560), input.min.0), t561) + t535)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t559] = sum[0]
     }
     free sum
    }
   }
   let t568 = conv_w__1.s0._2.rebased + t517
   let t566 = t504*t568
   let t563 = (input.stride.2*t568) - t501
   let t562 = t512 - t497
   let t567 = t497 - casted.min.1
   for (conv_w__1.s0._1.rebased, 0, t562) {
    let t572 = ((conv_w__1.s0._1.rebased + t567)*(casted.extent.0 + 3)) + t566
    let t571 = (t497 - input.min.1) + conv_w__1.s0._1.rebased
    let t569 = conv_w__1.s0._1.rebased + t497
    for (conv_w__1.s0._0.rebased, 0, casted.extent.0 + 3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t574 = (((casted.min.0 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t573 = casted.min.0 + conv_w__1.s0._0.rebased
      for (sum.s1.r85$x.rebased, 0, 16) {
       let t433 = sum.s1.r85$x.rebased + t569
       sum[0] = sum[0] + (input[(select(t433 < (t514 + 8), max(min(t514 + 7, t433) + -8, input.min.1), (((sum.s1.r85$x.rebased + t571) + -8) % input.extent.1) + input.min.1)*input.stride.1) + (select((t513 <= t573) || (t573 < input.min.0), t574, max(min(t513 + -1, t573), input.min.0)) + t563)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t572] = sum[0]
     }
     free sum
    }
   }
  }
  let t584 = input.extent.2 + input.min.2
  let t585 = max(min(t584, 3), 0)
  let t582 = (casted.extent.0 + 3)*casted.extent.1
  let t579 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (conv_w__1.s0._2.rebased, 0, 3 - t585) {
   let t586 = max(min(t584, 3), 0)
   let t591 = (conv_w__1.s0._2.rebased + t585)*t582
   for (conv_w__1.s0._1.rebased, 0, casted.extent.1) {
    let t599 = ((casted.extent.0 + 3)*conv_w__1.s0._1.rebased) + t591
    let t594 = (((t586 - input.min.2) + conv_w__1.s0._2.rebased) % input.extent.2) + input.min.2
    let t598 = (casted.min.1 - input.min.1) + conv_w__1.s0._1.rebased
    let t592 = conv_w__1.s0._2.rebased + t586
    let t593 = casted.min.1 + conv_w__1.s0._1.rebased
    for (conv_w__1.s0._0.rebased, 0, casted.extent.0 + 3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t601 = (select(t592 < t584, max(min(t584 + -1, t592), input.min.2), t594)*input.stride.2) - t579
      let t603 = (((casted.min.0 - input.min.0) + conv_w__1.s0._0.rebased) % input.extent.0) + input.min.0
      let t602 = input.extent.0 + input.min.0
      let t600 = casted.min.0 + conv_w__1.s0._0.rebased
      for (sum.s1.r85$x.rebased, 0, 16) {
       let t441 = sum.s1.r85$x.rebased + t593
       let t811 = input.extent.1 + input.min.1
       sum[0] = sum[0] + (input[(select(((t811 + 8) <= t441) || (t441 < (input.min.1 + 8)), (((sum.s1.r85$x.rebased + t598) + -8) % input.extent.1) + input.min.1, max(min(t811 + 7, t441) + -8, input.min.1))*input.stride.1) + (select((t602 <= t600) || (t600 < input.min.0), t603, max(min(t602 + -1, t600), input.min.0)) + t601)]*18)
      }
     }
     consume sum {
      conv_w__1[conv_w__1.s0._0.rebased + t599] = sum[0]
     }
     free sum
    }
   }
  }
 }
 allocate all[int32 * casted.extent.0 * casted.extent.1 * 8]
 produce all {
  consume conv_w__1 {
   let t605 = (casted.extent.0 + 3)*casted.extent.1
   for (all.s0._2, 0, 8) {
    let t608 = (casted.extent.0*casted.extent.1)*all.s0._2
    for (all.s0._1.rebased, 0, casted.extent.1) {
     let t609 = (casted.extent.0 + 3)*all.s0._1.rebased
     let t611 = (all.s0._1.rebased*casted.extent.0) + t608
     for (all.s0._0.rebased, 0, casted.extent.0) {
      all[all.s0._0.rebased + t611] = (conv_w__1[(t605 + t609) + all.s0._0.rebased]*(all.s0._2 + 7)) + ((conv_w__1[((t605*2) + t609) + all.s0._0.rebased]*(all.s0._2 + 10)) + (conv_w__1[all.s0._0.rebased + t609]*(all.s0._2 + 4)))
     }
    }
   }
  }
 }
 allocate binary_op[int32 * casted.extent.0 * casted.extent.1 * 8]
 produce binary_op {
  consume all {
   consume conv_w__1 {
    let t612 = (casted.extent.0 + 3)*casted.extent.1
    for (binary_op.s0._2, 0, 8) {
     let t614 = (casted.extent.0*casted.extent.1)*binary_op.s0._2
     for (binary_op.s0._1.rebased, 0, casted.extent.1) {
      let t615 = (casted.extent.0 + 3)*binary_op.s0._1.rebased
      let t616 = (binary_op.s0._1.rebased*casted.extent.0) + t614
      for (binary_op.s0._0.rebased, 0, casted.extent.0) {
       allocate all_r[int32 * 1]
       produce all_r {
        all_r[0] = 0
        let t617 = binary_op.s0._0.rebased + t615
        for (all_r.s1.r110$x, 0, 3) {
         all_r[0] = all_r[0] + (conv_w__1[(all_r.s1.r110$x*t612) + t617]*(((all_r.s1.r110$x*3) + binary_op.s0._2) + 4))
        }
       }
       consume all_r {
        let t358 = binary_op.s0._0.rebased + t616
        binary_op[t358] = all[t358] % all_r[0]
       }
       free all_r
      }
     }
    }
   }
  }
 }
 free all
 allocate all$2[int32 * casted.extent.0 * casted.extent.1 * 12]
 produce all$2 {
  consume binary_op {
   for (all$2.s0._2, 0, 12) {
    let t627 = casted.extent.0*casted.extent.1
    for (all$2.s0._1.rebased, 0, casted.extent.1) {
     let t628 = all$2.s0._1.rebased*casted.extent.0
     for (all$2.s0._0.rebased, 0, casted.extent.0) {
      all$2[((all$2.s0._2*t627) + t628) + all$2.s0._0.rebased] = (binary_op[(t627 + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 17)) + ((binary_op[all$2.s0._0.rebased + t628]*(all$2.s0._2 + 9)) + ((binary_op[((t627*2) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 25)) + ((binary_op[((t627*3) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 33)) + ((binary_op[((t627*4) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 41)) + ((binary_op[((t627*5) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 49)) + ((binary_op[((t627*7) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 65)) + (binary_op[((t627*6) + t628) + all$2.s0._0.rebased]*(all$2.s0._2 + 57))))))))
     }
    }
   }
  }
 }
 free binary_op
 allocate binary_op$1[uint8 * (casted.extent.0 + 3) * casted.extent.1 * 3]
 produce binary_op$1 {
  consume conv_w__1 {
   let t636 = max(min(input.min.2, 3), 0)
   let t637 = (casted.extent.0 + 3)*casted.extent.1
   let t641 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (binary_op$1.s0._2, 0, t636) {
    let t650 = input.extent.2 + input.min.2
    let t644 = binary_op$1.s0._2*t637
    let t645 = (select((t650 <= binary_op$1.s0._2) || (binary_op$1.s0._2 < input.min.2), ((binary_op$1.s0._2 - input.min.2) % input.extent.2) + input.min.2, max(min(t650 + -1, binary_op$1.s0._2), input.min.2))*input.stride.2) - t641
    for (binary_op$1.s0._1.rebased, 0, casted.extent.1) {
     let t651 = ((casted.extent.0 + 3)*binary_op$1.s0._1.rebased) + t644
     let t654 = (((casted.min.1 - input.min.1) + binary_op$1.s0._1.rebased) % input.extent.1) + input.min.1
     let t653 = input.extent.1 + input.min.1
     let t652 = binary_op$1.s0._1.rebased + casted.min.1
     for (binary_op$1.s0._0.rebased, 0, casted.extent.0 + 3) {
      let t364 = binary_op$1.s0._0.rebased + t651
      let t450 = binary_op$1.s0._0.rebased + casted.min.0
      let t812 = input.extent.0 + input.min.0
      binary_op$1[t364] = uint8((input[select((t812 <= t450) || (t450 < input.min.0), (((casted.min.0 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0, max(min(t812 + -1, t450), input.min.0)) + ((select((t653 <= t652) || (t652 < input.min.1), t654, max(min(t653 + -1, t652), input.min.1))*input.stride.1) + t645)] < conv_w__1[t364]))
     }
    }
   }
   let t673 = casted.extent.0 + casted.min.0
   let t674 = casted.extent.1 + casted.min.1
   let t675 = input.extent.0 + input.min.0
   let t676 = input.extent.1 + input.min.1
   let t677 = input.min.2*input.stride.2
   let t678 = input.min.1*input.stride.1
   let t679 = max(min(input.min.2, 3), 0)
   let t680 = max(casted.min.0, input.min.0)
   let t681 = t673 + 3
   let t682 = max(casted.min.1, input.min.1)
   let t659 = min(max(t676, t682), t674)
   let t668 = min(max(t675, t680), t681)
   let t658 = min(t674, t682)
   let t667 = min(t680, t681)
   let t660 = (casted.extent.0 + 3)*casted.extent.1
   let t657 = max(min(input.extent.2 + input.min.2, 3), 0) - t679
   let t664 = (t677 + t678) + input.min.0
   for (binary_op$1.s0._2.rebased, 0, t657) {
    let t688 = binary_op$1.s0._2.rebased + t679
    let t684 = t660*t688
    let t685 = (input.stride.2*t688) - t664
    let t683 = t658 - casted.min.1
    for (binary_op$1.s0._1.rebased, 0, t683) {
     let t689 = ((casted.extent.0 + 3)*binary_op$1.s0._1.rebased) + t684
     let t691 = (((casted.min.1 - input.min.1) + binary_op$1.s0._1.rebased) % input.extent.1) + input.min.1
     let t690 = binary_op$1.s0._1.rebased + casted.min.1
     for (binary_op$1.s0._0.rebased, 0, casted.extent.0 + 3) {
      let t367 = binary_op$1.s0._0.rebased + t689
      let t454 = binary_op$1.s0._0.rebased + casted.min.0
      binary_op$1[t367] = uint8((input[select((t675 <= t454) || (t454 < input.min.0), (((casted.min.0 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0, max(min(t675 + -1, t454), input.min.0)) + ((select((t676 <= t690) || (t690 < input.min.1), t691, max(min(t676 + -1, t690), input.min.1))*input.stride.1) + t685)] < conv_w__1[t367]))
     }
    }
    let t705 = binary_op$1.s0._2.rebased + t679
    let t706 = input.stride.2*t705
    let t707 = t660*t705
    let t708 = t667 - casted.min.0
    let t697 = t706 - t664
    let t702 = t673 - t668
    let t699 = t668 - t667
    let t693 = t659 - t658
    let t696 = t658 - casted.min.1
    let t703 = (t668 - casted.min.0) + t707
    let t701 = (((t667 - t677) - t678) - input.min.0) + t706
    for (binary_op$1.s0._1.rebased, 0, t693) {
     let t709 = ((binary_op$1.s0._1.rebased + t696)*(casted.extent.0 + 3)) + t707
     let t710 = ((binary_op$1.s0._1.rebased + t658)*input.stride.1) + t697
     for (binary_op$1.s0._0.rebased, 0, t708) {
      let t369 = binary_op$1.s0._0.rebased + t709
      let t456 = binary_op$1.s0._0.rebased + casted.min.0
      binary_op$1[t369] = uint8((input[select((t675 <= t456) || (t456 < input.min.0), (((casted.min.0 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0, max(min(t675 + -1, t456), input.min.0)) + t710] < conv_w__1[t369]))
     }
     let t712 = ((binary_op$1.s0._1.rebased + t696)*(casted.extent.0 + 3)) + (t707 + t708)
     let t713 = ((binary_op$1.s0._1.rebased + t658)*input.stride.1) + t701
     for (binary_op$1.s0._0.rebased, 0, t699) {
      let t370 = binary_op$1.s0._0.rebased + t712
      binary_op$1[t370] = uint8((input[binary_op$1.s0._0.rebased + t713] < conv_w__1[t370]))
     }
     let t714 = ((binary_op$1.s0._1.rebased + t696)*(casted.extent.0 + 3)) + t703
     let t715 = ((binary_op$1.s0._1.rebased + t658)*input.stride.1) + t697
     for (binary_op$1.s0._0.rebased, 0, t702 + 3) {
      let t372 = binary_op$1.s0._0.rebased + t714
      let t457 = binary_op$1.s0._0.rebased + t668
      binary_op$1[t372] = uint8((input[select(t457 < t675, max(min(t675 + -1, t457), input.min.0), (((t668 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0) + t715] < conv_w__1[t372]))
     }
    }
    let t723 = binary_op$1.s0._2.rebased + t679
    let t718 = t660*t723
    let t720 = (input.stride.2*t723) - t664
    let t717 = t674 - t659
    let t719 = t659 - casted.min.1
    for (binary_op$1.s0._1.rebased, 0, t717) {
     let t724 = ((binary_op$1.s0._1.rebased + t719)*(casted.extent.0 + 3)) + t718
     let t726 = (((t659 - input.min.1) + binary_op$1.s0._1.rebased) % input.extent.1) + input.min.1
     let t725 = binary_op$1.s0._1.rebased + t659
     for (binary_op$1.s0._0.rebased, 0, casted.extent.0 + 3) {
      let t375 = binary_op$1.s0._0.rebased + t724
      let t462 = binary_op$1.s0._0.rebased + casted.min.0
      binary_op$1[t375] = uint8((input[select((t675 <= t462) || (t462 < input.min.0), (((casted.min.0 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0, max(min(t675 + -1, t462), input.min.0)) + ((select(t725 < t676, max(min(t676 + -1, t725), input.min.1), t726)*input.stride.1) + t720)] < conv_w__1[t375]))
     }
    }
   }
   let t737 = input.extent.2 + input.min.2
   let t738 = max(min(t737, 3), 0)
   let t729 = (casted.extent.0 + 3)*casted.extent.1
   let t734 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (binary_op$1.s0._2.rebased, 0, 3 - t738) {
    let t740 = max(min(t737, 3), 0)
    let t739 = (binary_op$1.s0._2.rebased + t738)*t729
    for (binary_op$1.s0._1.rebased, 0, casted.extent.1) {
     let t745 = ((casted.extent.0 + 3)*binary_op$1.s0._1.rebased) + t739
     let t748 = (((t740 - input.min.2) + binary_op$1.s0._2.rebased) % input.extent.2) + input.min.2
     let t750 = (((casted.min.1 - input.min.1) + binary_op$1.s0._1.rebased) % input.extent.1) + input.min.1
     let t749 = input.extent.1 + input.min.1
     let t746 = binary_op$1.s0._2.rebased + t740
     let t747 = binary_op$1.s0._1.rebased + casted.min.1
     for (binary_op$1.s0._0.rebased, 0, casted.extent.0 + 3) {
      let t379 = binary_op$1.s0._0.rebased + t745
      let t469 = binary_op$1.s0._0.rebased + casted.min.0
      let t813 = input.extent.0 + input.min.0
      binary_op$1[t379] = uint8((input[select((t813 <= t469) || (t469 < input.min.0), (((casted.min.0 - input.min.0) + binary_op$1.s0._0.rebased) % input.extent.0) + input.min.0, max(min(t813 + -1, t469), input.min.0)) + ((select((t749 <= t747) || (t747 < input.min.1), t750, max(min(t749 + -1, t747), input.min.1))*input.stride.1) + ((select(t746 < t737, max(min(t737 + -1, t746), input.min.2), t748)*input.stride.2) - t734))] < conv_w__1[t379]))
     }
    }
   }
   free conv_w__1
  }
 }
 allocate conv__0[uint8 * casted.extent.0 * casted.extent.1 * 3]
 produce conv__0 {
  consume binary_op$1 {
   let t753 = (casted.extent.0 + 3)*casted.extent.1
   for (conv__0.s0._2, 0, 3) {
    let t756 = (casted.extent.0*casted.extent.1)*conv__0.s0._2
    let t755 = conv__0.s0._2*t753
    for (conv__0.s0._1.rebased, 0, casted.extent.1) {
     let t757 = ((casted.extent.0 + 3)*conv__0.s0._1.rebased) + t755
     let t758 = (casted.extent.0*conv__0.s0._1.rebased) + t756
     for (conv__0.s0._0.rebased, 0, casted.extent.0) {
      let t382 = conv__0.s0._0.rebased + t757
      conv__0[conv__0.s0._0.rebased + t758] = ((uint8(uint1(binary_op$1[t382])) + uint8(uint1(binary_op$1[t382 + 1]))) + uint8(uint1(binary_op$1[t382 + 2]))) + uint8(uint1(binary_op$1[t382 + 3]))
     }
    }
   }
  }
 }
 free binary_op$1
 allocate binary_op$4[int32 * casted.extent.0 * casted.extent.1 * 12]
 produce binary_op$4 {
  consume conv__0 {
   consume all$2 {
    for (binary_op$4.s0._2, 0, 12) {
     let t762 = casted.extent.0*casted.extent.1
     for (binary_op$4.s0._1.rebased, 0, casted.extent.1) {
      let t765 = binary_op$4.s0._1.rebased*casted.extent.0
      let t764 = (binary_op$4.s0._2*t762) + t765
      for (binary_op$4.s0._0.rebased, 0, casted.extent.0) {
       allocate all_r$5[int32 * 1]
       produce all_r$5 {
        all_r$5[0] = 0
        let t766 = binary_op$4.s0._0.rebased + t765
        for (all_r$5.s1.r232$x, 0, 3) {
         all_r$5[0] = all_r$5[0] + ((((all_r$5.s1.r232$x*3) + binary_op$4.s0._2) + 4)*int32(conv__0[(all_r$5.s1.r232$x*t762) + t766]))
        }
       }
       consume all_r$5 {
        let t383 = binary_op$4.s0._0.rebased + t764
        let t384 = all$2[t383]
        binary_op$4[t383] = max(t384, 0)/(all_r$5[0]*t384)
       }
       free all_r$5
      }
     }
    }
   }
  }
 }
 free all$2
 free conv__0
 produce casted {
  consume binary_op$4 {
   let t768 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t772 = casted.min.2 + casted.s0._2.rebased
    let t771 = (casted.stride.2*t772) + t768
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t773 = casted.extent.0*casted.s0._1.rebased
     let t774 = casted.extent.0*casted.extent.1
     let t775 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t771
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$6[int32 * 1]
      produce all_r$6 {
       all_r$6[0] = 0
       let t776 = casted.s0._0.rebased + t773
       for (all_r$6.s1.r246$x, 0, 12) {
        all_r$6[0] = all_r$6[0] + (binary_op$4[(all_r$6.s1.r246$x*t774) + t776]*(((all_r$6.s1.r246$x*12) + t772) + 13))
       }
      }
      consume all_r$6 {
       casted[casted.s0._0.rebased + t775] = all_r$6[0]
      }
      free all_r$6
     }
    }
   }
  }
 }
 free binary_op$4
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
add_temp_object_file: /tmp/SsDBA1/random_pipeline.a.o
Module.compile(): temporary object /tmp/SsDBA1/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50097_0/random_pipeline.a
file_unlink: /tmp/SsDBA1/random_pipeline.a.o
dir_rmdir: /tmp/SsDBA1
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50097_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50097_0/random_pipeline.registration.cpp
