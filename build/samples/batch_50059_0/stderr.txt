Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50059_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(all_r$1(_0, _1, _2) != all(_0, _1, _2))
In random expression: min(all_r$3(_0, _1, _2), 0)
The following expressions were unused:
all_r(_0, _1, _2)
(let t31 = all_r$3(_0, _1, _2) in ((t31*t31)/all_r(_0, _1, _2)))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$4 }
Injecting realization of { all_w$1 }
Injecting realization of { sum$4 }
Injecting realization of { relu$1 }
Injecting realization of { conv_r__0 }
Injecting realization of { binary_op }
Injecting realization of { all_r$1 }
Injecting realization of { all }
Injecting realization of { all_r }
Injecting realization of { all_w }
Injecting realization of { sum }
Inlining constant_exterior
Inlining repeat_edge
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required = let t367 = (input.extent.0 + input.min.0) in (max(min((casted.extent.0 + casted.min.0) + 10, t367), input.min.0 + 1) - max(min(t367 + 8, casted.min.0) + -9, input.min.0))
let input.min.0.required = max(min((input.extent.0 + input.min.0) + 8, casted.min.0) + -9, input.min.0)
let input.extent.1.required = let t368 = (input.extent.1 + input.min.1) in (max(min(casted.extent.1 + casted.min.1, t368), input.min.1 + 1) - max(min(t368 + -1, casted.min.1), input.min.1))
let input.min.1.required = max(min((input.extent.1 + input.min.1) + -1, casted.min.1), input.min.1)
let input.extent.2.required.s = let t369 = (input.extent.2 + input.min.2) in (min(t369, 3) - max(min(t369, 1) + -1, input.min.2))
let input.min.2.required = max(min(input.extent.2 + input.min.2, 1) + -1, input.min.2)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required, 0, input.min.2.required, max(input.extent.2.required.s, 1), input.extent.0.required*input.extent.1.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && ((max(input.extent.2.required.s, 1) + input.min.2.required) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, (max(input.extent.2.required.s, 1) + input.min.2.required) + -1, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 allocate all_w[int32 * (casted.extent.0 + 19) * casted.extent.1 * 11]
 produce all_w {
  let t250 = casted.extent.0 + casted.min.0
  let t251 = casted.extent.1 + casted.min.1
  let t252 = input.extent.0 + input.min.0
  let t253 = input.extent.1 + input.min.1
  let t254 = input.extent.2 + input.min.2
  let t255 = input.min.2*input.stride.2
  let t256 = input.min.1*input.stride.1
  let t257 = max(min(t254, 3), 0)
  let t258 = max(min(input.min.2, 3), 0)
  let t259 = max(casted.min.1, input.min.1)
  let t260 = max(casted.min.0 + -9, input.min.0)
  let t261 = t250 + 10
  let t242 = min(max(t252, t260), t261)
  let t235 = min(max(t253, t259), t251)
  let t241 = min(t260, t261)
  let t234 = min(t251, t259)
  let t240 = (casted.extent.0 + 19)*casted.extent.1
  let t246 = t257 - t258
  let t247 = 3 - t257
  let t239 = (t255 + t256) + input.min.0
  for (all_w.s0._2, 0, 11) {
   let t263 = all_w.s0._2*t240
   let t262 = t234 - casted.min.1
   for (all_w.s0._1.rebased, 0, t262) {
    let t265 = ((casted.extent.0 + 19)*all_w.s0._1.rebased) + t263
    let t264 = all_w.s0._1.rebased + casted.min.1
    for (all_w.s0._0.rebased, 0, casted.extent.0 + 19) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t268 = t253 <= t264
      let t267 = t264 < input.min.1
      let t269 = (max(min(t253 + -1, t264), input.min.1)*input.stride.1) - t239
      let t266 = all_w.s0._0.rebased + casted.min.0
      for (sum.s1.r88$x, 0, 3) {
       sum[0] = sum[0] + (select(((((((t252 + 9) <= t266) || (t266 < (input.min.0 + 9))) || t267) || t268) || (sum.s1.r88$x < input.min.2)) || (t254 <= sum.s1.r88$x), 7, input[(max(min(t254 + -1, sum.s1.r88$x), input.min.2)*input.stride.2) + (max(min(t252 + 8, t266) + -9, input.min.0) + t269)])*(((sum.s1.r88$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t265] = sum[0]
     }
     free sum
    }
   }
   let t280 = all_w.s0._2*t240
   let t281 = t241 - casted.min.0
   let t276 = max(min(t254, 3), 0)
   let t275 = ((t241 - t255) - t256) - input.min.0
   let t278 = t250 - t242
   let t274 = t242 - t241
   let t270 = t235 - t234
   let t273 = t234 - casted.min.1
   let t279 = (t242 - casted.min.0) + t280
   for (all_w.s0._1.rebased, 0, t270) {
    let t282 = ((all_w.s0._1.rebased + t234)*input.stride.1) - t239
    let t283 = ((all_w.s0._1.rebased + t273)*(casted.extent.0 + 19)) + t280
    for (all_w.s0._0.rebased, 0, t281 + 9) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t284 = all_w.s0._0.rebased + casted.min.0
      for (sum.s1.r88$x, 0, 3) {
       sum[0] = sum[0] + (select(((((t252 + 9) <= t284) || (t284 < (input.min.0 + 9))) || (sum.s1.r88$x < input.min.2)) || (t254 <= sum.s1.r88$x), 7, input[(max(min(t254 + -1, sum.s1.r88$x), input.min.2)*input.stride.2) + (max(min(t252 + 8, t284) + -9, input.min.0) + t282)])*(((sum.s1.r88$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t283] = sum[0]
     }
     free sum
    }
    let t286 = ((all_w.s0._1.rebased + t273)*(casted.extent.0 + 19)) + (t280 + t281)
    let t285 = ((all_w.s0._1.rebased + t234)*input.stride.1) + t275
    for (all_w.s0._0.rebased, 0, t274) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t287 = all_w.s0._0.rebased + t285
      for (sum.s1.r88$x, 0, t258) {
       sum[0] = sum[0] + (select((t254 <= sum.s1.r88$x) || (sum.s1.r88$x < input.min.2), 7, input[(max(min(t254 + -1, sum.s1.r88$x), input.min.2)*input.stride.2) + t287])*(((sum.s1.r88$x*3) + all_w.s0._2) + 4))
      }
      let t288 = all_w.s0._0.rebased + t285
      for (sum.s1.r88$x.rebased, 0, t246) {
       let t221 = sum.s1.r88$x.rebased + t258
       sum[0] = sum[0] + (input[(input.stride.2*t221) + t288]*(((t221*3) + all_w.s0._2) + 4))
      }
      let t289 = all_w.s0._0.rebased + t285
      for (sum.s1.r88$x.rebased, 0, t247) {
       let t223 = sum.s1.r88$x.rebased + t276
       sum[0] = sum[0] + (select(t223 < t254, input[(max(min(t254 + -1, t223), input.min.2)*input.stride.2) + t289], 7)*(((t223*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[(all_w.s0._0.rebased + t286) + 9] = sum[0]
     }
     free sum
    }
    let t290 = ((all_w.s0._1.rebased + t234)*input.stride.1) - t239
    let t291 = ((all_w.s0._1.rebased + t273)*(casted.extent.0 + 19)) + t279
    for (all_w.s0._0.rebased, 0, t278 + 10) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t292 = all_w.s0._0.rebased + t242
      for (sum.s1.r88$x, 0, 3) {
       sum[0] = sum[0] + (select(((t252 <= t292) || (sum.s1.r88$x < input.min.2)) || (t254 <= sum.s1.r88$x), 7, input[(max(min(t254 + -1, sum.s1.r88$x), input.min.2)*input.stride.2) + (max(min(t252 + -1, t292), input.min.0) + t290)])*(((sum.s1.r88$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[(all_w.s0._0.rebased + t291) + 9] = sum[0]
     }
     free sum
    }
   }
   let t294 = all_w.s0._2*t240
   let t293 = t251 - t235
   let t295 = t235 - casted.min.1
   for (all_w.s0._1.rebased, 0, t293) {
    let t297 = ((all_w.s0._1.rebased + t295)*(casted.extent.0 + 19)) + t294
    let t296 = all_w.s0._1.rebased + t235
    for (all_w.s0._0.rebased, 0, casted.extent.0 + 19) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t299 = t253 <= t296
      let t300 = (max(min(t253 + -1, t296), input.min.1)*input.stride.1) - t239
      let t298 = all_w.s0._0.rebased + casted.min.0
      for (sum.s1.r88$x, 0, 3) {
       sum[0] = sum[0] + (select((((((t252 + 9) <= t298) || (t298 < (input.min.0 + 9))) || t299) || (sum.s1.r88$x < input.min.2)) || (t254 <= sum.s1.r88$x), 7, input[(max(min(t254 + -1, sum.s1.r88$x), input.min.2)*input.stride.2) + (max(min(t252 + 8, t298) + -9, input.min.0) + t300)])*(((sum.s1.r88$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t297] = sum[0]
     }
     free sum
    }
   }
  }
 }
 allocate all_r[int32 * (casted.extent.0 + 19) * casted.extent.1 * 9]
 produce all_r {
  let t301 = (casted.extent.0 + 19)*casted.extent.1
  for (all_r.s0._2, 0, 9) {
   let t302 = all_r.s0._2*t301
   for (all_r.s0._1.rebased, 0, casted.extent.1) {
    let t303 = ((casted.extent.0 + 19)*all_r.s0._1.rebased) + t302
    for (all_r.s0._0.rebased, 0, casted.extent.0 + 19) {
     all_r[all_r.s0._0.rebased + t303] = 0
    }
   }
  }
  consume all_w {
   let t304 = (casted.extent.0 + 19)*casted.extent.1
   for (all_r.s1._2, 0, 9) {
    for (all_r.s1._1.rebased, 0, casted.extent.1) {
     let t308 = (casted.extent.0 + 19)*all_r.s1._1.rebased
     let t306 = (all_r.s1._2*t304) + t308
     for (all_r.s1._0.rebased, 0, casted.extent.0 + 19) {
      let t310 = all_r.s1._0.rebased + t308
      let t309 = all_r.s1._0.rebased + t306
      for (all_r.s1.r110$x, 0, 11) {
       all_r[t309] = all_r[t309] + (all_w[(all_r.s1.r110$x*t304) + t310]*(((all_r.s1.r110$x*11) + all_r.s1._2) + 12))
      }
     }
    }
   }
  }
  free all_w
 }
 allocate all[int32 * (casted.extent.0 + 19) * casted.extent.1 * 12]
 produce all {
  consume all_r {
   let t311 = (casted.extent.0 + 19)*casted.extent.1
   for (all.s0._2, 0, 12) {
    for (all.s0._1.rebased, 0, casted.extent.1) {
     let t320 = (casted.extent.0 + 19)*all.s0._1.rebased
     for (all.s0._0.rebased, 0, casted.extent.0 + 19) {
      all[((all.s0._2*t311) + t320) + all.s0._0.rebased] = (all_r[(t311 + t320) + all.s0._0.rebased]*(all.s0._2 + 19)) + ((all_r[all.s0._0.rebased + t320]*(all.s0._2 + 10)) + ((all_r[((t311*2) + t320) + all.s0._0.rebased]*(all.s0._2 + 28)) + ((all_r[((t311*3) + t320) + all.s0._0.rebased]*(all.s0._2 + 37)) + ((all_r[((t311*4) + t320) + all.s0._0.rebased]*(all.s0._2 + 46)) + ((all_r[((t311*5) + t320) + all.s0._0.rebased]*(all.s0._2 + 55)) + ((all_r[((t311*6) + t320) + all.s0._0.rebased]*(all.s0._2 + 64)) + ((all_r[((t311*8) + t320) + all.s0._0.rebased]*(all.s0._2 + 82)) + (all_r[((t311*7) + t320) + all.s0._0.rebased]*(all.s0._2 + 73)))))))))
     }
    }
   }
  }
 }
 allocate binary_op[uint8 * (casted.extent.0 + 19) * casted.extent.1 * 12]
 produce binary_op {
  consume all {
   consume all_r {
    let t329 = (casted.extent.0 + 19)*casted.extent.1
    for (binary_op.s0._2, 0, 12) {
     for (binary_op.s0._1.rebased, 0, casted.extent.1) {
      let t333 = (casted.extent.0 + 19)*binary_op.s0._1.rebased
      let t332 = (binary_op.s0._2*t329) + t333
      for (binary_op.s0._0.rebased, 0, casted.extent.0 + 19) {
       allocate all_r$1[int32 * 1]
       produce all_r$1 {
        all_r$1[0] = 0
        let t334 = binary_op.s0._0.rebased + t333
        for (all_r$1.s1.r146$x, 0, 9) {
         all_r$1[0] = all_r$1[0] + (all_r[(all_r$1.s1.r146$x*t329) + t334]*(((all_r$1.s1.r146$x*9) + binary_op.s0._2) + 10))
        }
       }
       consume all_r$1 {
        let t205.s = binary_op.s0._0.rebased + t332
        binary_op[t205.s] = uint8((all_r$1[0] != all[t205.s]))
       }
       free all_r$1
      }
     }
    }
   }
  }
 }
 free all_r
 free all
 allocate conv_r__0[uint8 * casted.extent.0 * casted.extent.1 * 12]
 produce conv_r__0 {
  for (conv_r__0.s0._2, 0, 12) {
   let t336 = (casted.extent.0*casted.extent.1)*conv_r__0.s0._2
   for (conv_r__0.s0._1.rebased, 0, casted.extent.1) {
    let t337 = (casted.extent.0*conv_r__0.s0._1.rebased) + t336
    for (conv_r__0.s0._0.rebased, 0, casted.extent.0) {
     conv_r__0[conv_r__0.s0._0.rebased + t337] = (uint8)0
    }
   }
  }
  consume binary_op {
   let t339 = (casted.extent.0 + 19)*casted.extent.1
   for (conv_r__0.s1._2, 0, 12) {
    let t340 = (casted.extent.0*casted.extent.1)*conv_r__0.s1._2
    let t341 = conv_r__0.s1._2*t339
    for (conv_r__0.s1._1.rebased, 0, casted.extent.1) {
     let t343 = ((casted.extent.0 + 19)*conv_r__0.s1._1.rebased) + t341
     let t342 = (casted.extent.0*conv_r__0.s1._1.rebased) + t340
     for (conv_r__0.s1._0.rebased, 0, casted.extent.0) {
      let t345 = conv_r__0.s1._0.rebased + t343
      let t344 = conv_r__0.s1._0.rebased + t342
      for (conv_r__0.s1.r174$x.rebased, 0, 20) {
       conv_r__0[t344] = uint8((uint1(conv_r__0[t344]) + uint1(binary_op[conv_r__0.s1.r174$x.rebased + t345])))
      }
     }
    }
   }
  }
  free binary_op
 }
 allocate relu$1[uint8 * casted.extent.0 * casted.extent.1 * 12]
 produce relu$1 {
  consume conv_r__0 {
   for (relu$1.s0._2, 0, 12) {
    let t347 = (casted.extent.0*casted.extent.1)*relu$1.s0._2
    for (relu$1.s0._1.rebased, 0, casted.extent.1) {
     let t348 = (casted.extent.0*relu$1.s0._1.rebased) + t347
     for (relu$1.s0._0.rebased, 0, casted.extent.0) {
      let t208 = relu$1.s0._0.rebased + t348
      relu$1[t208] = uint8(uint1(conv_r__0[t208]))
     }
    }
   }
  }
 }
 free conv_r__0
 allocate all_w$1[int32 * casted.extent.0 * casted.extent.1 * 4]
 produce all_w$1 {
  consume relu$1 {
   for (all_w$1.s0._2, 0, 4) {
    let t352 = casted.extent.0*casted.extent.1
    for (all_w$1.s0._1.rebased, 0, casted.extent.1) {
     let t355 = all_w$1.s0._1.rebased*casted.extent.0
     let t354 = (all_w$1.s0._2*t352) + t355
     for (all_w$1.s0._0.rebased, 0, casted.extent.0) {
      allocate sum$4[int32 * 1]
      produce sum$4 {
       sum$4[0] = 0
       let t356 = all_w$1.s0._0.rebased + t355
       for (sum$4.s1.r283$x, 0, 12) {
        sum$4[0] = sum$4[0] + ((((sum$4.s1.r283$x*12) + all_w$1.s0._2) + 13)*int32(uint1(relu$1[(sum$4.s1.r283$x*t352) + t356])))
       }
      }
      consume sum$4 {
       all_w$1[all_w$1.s0._0.rebased + t354] = sum$4[0]
      }
      free sum$4
     }
    }
   }
  }
 }
 free relu$1
 produce casted {
  consume all_w$1 {
   let t358 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t362 = casted.min.2 + casted.s0._2.rebased
    let t361 = (casted.stride.2*t362) + t358
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t363 = casted.extent.0*casted.s0._1.rebased
     let t364 = casted.extent.0*casted.extent.1
     let t365 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t361
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       let t366 = casted.s0._0.rebased + t363
       for (all_r$4.s1.r305$x, 0, 4) {
        all_r$4[0] = all_r$4[0] + (all_w$1[(all_r$4.s1.r305$x*t364) + t366]*(((all_r$4.s1.r305$x*4) + t362) + 5))
       }
      }
      consume all_r$4 {
       casted[casted.s0._0.rebased + t365] = all_r$4[0]
      }
      free all_r$4
     }
    }
   }
  }
 }
 free all_w$1
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
add_temp_object_file: /tmp/oxRzXc/random_pipeline.a.o
Module.compile(): temporary object /tmp/oxRzXc/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50059_0/random_pipeline.a
file_unlink: /tmp/oxRzXc/random_pipeline.a.o
dir_rmdir: /tmp/oxRzXc
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50059_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50059_0/random_pipeline.registration.cpp
