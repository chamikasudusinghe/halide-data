Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50037_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(let t8 = upsampled_linear__1(_0, _1, _2) in (let t9 = upsampled_nn__1(_0, _1, _2) in select(t8 == t9, t9 % t8, t8)))
max(upsampled_nn__1$1(_0, _1, _2), binary_op(_0, _1, _2))
In random expression: (uint1)1
The following expressions were unused:
binary_op(_0, _1, _2)
relu(_0, _1, _2)
int8(max(relu(_0, _1, _2), binary_op(_0, _1, _2)))
(let t19 = (int8)binary_op$2(_0, _1, _2) in (int32(t19)/upsampled_linear__1$1(_0, _1, _2)))
In random expression: max(sliced(_0 + -1, _1, _2), sliced(_0 + -2, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: (let t28 = sliced(_0 + -2, _1, _2) in t28)
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + -1, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: (sliced(_0 + -1, _1, _2) + sliced(_0 + -2, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: (sliced(_0 + -2, _1, _2) - sliced(_0, _1, _2))
The following expressions were unused:
sliced(_0 + -1, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: (sliced(_0, _1, _2) < sliced(_0 + -1, _1, _2))
The following expressions were unused:
sliced(_0 + -2, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: max(sliced(_0 + -1, _1, _2), sliced(_0 + 1, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + -2, _1, _2)
In random expression: (sliced(_0, _1, _2)/sliced(_0 + -2, _1, _2))
The following expressions were unused:
sliced(_0 + -1, _1, _2)
sliced(_0 + 1, _1, _2)
In random expression: (sliced(_0 + 1, _1, _2) - sliced(_0 + -1, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + -2, _1, _2)
In random expression: (sliced(_0 + 1, _1, _2)/sliced(_0 + -2, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + -1, _1, _2)
In random expression: (sliced(_0 + -1, _1, _2) % sliced(_0 + 1, _1, _2))
The following expressions were unused:
sliced(_0, _1, _2)
sliced(_0 + -2, _1, _2)
((((0 + sliced(_0 + -2, _1, _2)) + sliced(_0 + -1, _1, _2)) + sliced(_0, _1, _2)) + sliced(_0 + 1, _1, _2))
(let t32 = upsampled_linear__0$2(_0, _1, _2) in (min(t32, int32((int16)pooled2D_w__0_1(_0, _1, _2))) + t32))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$5 }
Inlining downsampled_nn__1
Inlining downsampled_nn__0$1
Injecting realization of { constant_exterior$1 }
Inlining repeat_edge$7
Injecting realization of { binary_op$4 }
Inlining upsampled_linear__0$2
Injecting realization of { all_r$4 }
Injecting realization of { downsampled_nn__0 }
Injecting realization of { pooled2D_w__0_1 }
Injecting realization of { sum }
Injecting realization of { sliced }
Inlining upsampled_nn__1$2
Inlining upsampled_nn__0$2
Injecting realization of { all_r$3 }
Injecting realization of { relu }
Injecting realization of { binary_op$1 }
Inlining upsampled_nn__1$1
Inlining upsampled_linear__0$1
Injecting realization of { all_r$1 }
Injecting realization of { binary_op }
Injecting realization of { upsampled_nn__1 }
Injecting realization of { upsampled_linear__0 }
Injecting realization of { all }
Injecting realization of { pool2D_r__0_1 }
Inlining upsampled_linear__1
Inlining upsampled_nn__0
Injecting realization of { all_r }
Inlining constant_exterior
Inlining repeat_edge
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s0._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s0._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: (min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: (min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) - min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: (((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - (min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2)*2))) + -5)/2)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((min(max(((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -1)/2) + all_r.s1._1.rebased) - (((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2))
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s0._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Warning: expression is non-monotonic in loop variable binary_op.s0._1.rebased: ((((max(min(casted.min.1*2, 3999), 0) + (binary_op.s0._1.rebased - ((((max(min(casted.min.1*2, 3999), 0) + binary_op.s0._1.rebased) + -5)/2)*2))) + -5)/2) + all_r.s1._1.rebased)
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let relu.s0._0.min = let t1144 = max(min(casted.min.0*4, 7999), 0) in min((t1144/8)*8, t1144 + -5)
let pool2D_r__0_1.s1._0.max.s = let t1145 = max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) in max(t1145/4, (((t1145 + 4)/8)*2) + 2)
let pool2D_r__0_1.s1._0.min.s = min(max(min(casted.min.0*4, 7999), 0) + -5, relu.s0._0.min)
let input.extent.0.required.s = let t1146 = (input.extent.0 + input.min.0) in (max(min(max(((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*2, pool2D_r__0_1.s1._0.max.s), t1146 + -1), input.min.0) - max(min(min(relu.s0._0.min/4, t1146 + -1), min(pool2D_r__0_1.s1._0.min.s/4, t1146 + 3) + -4), input.min.0))
let input.min.0.required = let t1147 = (input.extent.0 + input.min.0) in max(min(min(relu.s0._0.min/4, t1147 + -1), min(pool2D_r__0_1.s1._0.min.s/4, t1147 + 3) + -4), input.min.0)
let input.extent.1.required.s = let t1148 = (input.extent.1 + input.min.1) in (max(min(max(min((casted.extent.1 + casted.min.1)*2, 4001), 2)/2, t1148 + -1), input.min.1) - max(min((max(min(casted.min.1*2, 3999), 0) + -13)/2, t1148 + -1), input.min.1))
let input.min.1.required = max(min((max(min(casted.min.1*2, 3999), 0) + -13)/2, (input.extent.1 + input.min.1) + -1), input.min.1)
let input.extent.2.required.s = let t1149 = (input.extent.2 + input.min.2) in (min(t1149, 3) - max(min(t1149, 1) + -1, input.min.2))
let input.min.2.required = max(min(input.extent.2 + input.min.2, 1) + -1, input.min.2)
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, max(input.extent.2.required.s, 1), input.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && ((max(input.extent.2.required.s, 1) + input.min.2.required) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, (max(input.extent.2.required.s, 1) + input.min.2.required) + -1, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 let pool2D_r__0_1._1.extent_realized = (max(min((casted.extent.1 + casted.min.1)*2, 4001), 2)/2) - ((max(min(casted.min.1*2, 3999), 0) + -5)/2)
 let pool2D_r__0_1._0.min_realized.s = min(min(pool2D_r__0_1.s1._0.min.s, relu.s0._0.min), max(min(casted.min.0*4, 7999), 0) + -5)
 let pool2D_r__0_1._0.extent_realized = let t1150 = max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) in (max(max((((t1150 + 4)/8)*2) + 2, pool2D_r__0_1.s1._0.max.s), t1150/4) - (pool2D_r__0_1._0.min_realized.s/4))
 allocate pool2D_r__0_1[int16 * pool2D_r__0_1._0.extent_realized * pool2D_r__0_1._1.extent_realized * 3]
 let pool2D_r__0_1.s0._0.loop_extent = pool2D_r__0_1.s1._0.max.s - (pool2D_r__0_1.s1._0.min.s/4)
 produce pool2D_r__0_1 {
  let t812 = (pool2D_r__0_1.s1._0.min.s/4) - (pool2D_r__0_1._0.min_realized.s/4)
  for (pool2D_r__0_1.s0._2, 0, 3) {
   let t814 = ((pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized)*pool2D_r__0_1.s0._2) + t812
   for (pool2D_r__0_1.s0._1.rebased, 0, pool2D_r__0_1._1.extent_realized) {
    let t815 = (pool2D_r__0_1._0.extent_realized*pool2D_r__0_1.s0._1.rebased) + t814
    for (pool2D_r__0_1.s0._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     pool2D_r__0_1[pool2D_r__0_1.s0._0.rebased + t815] = (int16)0
    }
   }
  }
  let t825 = pool2D_r__0_1.s1._0.min.s/4
  let t816 = max(min(input.min.2, 3), 0)
  let t821 = (max(min(casted.min.1*2, 3999), 0) + -5)/2
  let t817 = t825 - (pool2D_r__0_1._0.min_realized.s/4)
  let t824 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t823 = input.extent.2 + input.min.2
  let t822 = input.extent.1 + input.min.1
  let t819 = input.extent.0 + input.min.0
  for (pool2D_r__0_1.s1._2, 0, t816) {
   let t828 = t823 <= pool2D_r__0_1.s1._2
   let t827 = pool2D_r__0_1.s1._2 < input.min.2
   let t829 = (max(min(t823 + -1, pool2D_r__0_1.s1._2), input.min.2)*input.stride.2) - t824
   let t826 = ((pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized)*pool2D_r__0_1.s1._2) + t817
   for (pool2D_r__0_1.s1._1.rebased, 0, pool2D_r__0_1._1.extent_realized) {
    let t830 = (pool2D_r__0_1._0.extent_realized*pool2D_r__0_1.s1._1.rebased) + t826
    let t831 = pool2D_r__0_1.s1._1.rebased + t821
    for (pool2D_r__0_1.s1._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     let t832 = pool2D_r__0_1.s1._0.rebased + t830
     let t833 = pool2D_r__0_1.s1._0.rebased + t825
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t834 = pool2D_r__0_1.s1.r88$y.rebased + t831
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t727 = pool2D_r__0_1.s1.r88$x.rebased + t833
       pool2D_r__0_1[t832] = pool2D_r__0_1[t832] + (int16(select(((((((t819 + 4) <= t727) || (t727 < (input.min.0 + 4))) || (t834 < (input.min.1 + 4))) || ((t822 + 4) <= t834)) || t827) || t828, 7, input[max(min(t819 + 3, t727) + -4, input.min.0) + ((max(min(t822 + 3, t834) + -4, input.min.1)*input.stride.1) + t829)]))/(int16)36)
      }
     }
    }
   }
  }
  let t853 = input.extent.0 + input.min.0
  let t854 = input.extent.1 + input.min.1
  let t855 = input.min.2*input.stride.2
  let t856 = input.min.1*input.stride.1
  let t857 = pool2D_r__0_1.s1._0.min.s/4
  let t858 = pool2D_r__0_1.s0._0.loop_extent + t857
  let t859 = max(min(casted.min.1*2, 3999), 0)
  let t860 = (t859 + -5)/2
  let t861 = pool2D_r__0_1._1.extent_realized + t860
  let t862 = pool2D_r__0_1._0.min_realized.s/4
  let t863 = max(min(input.min.2, 3), 0)
  let t864 = max(input.min.0 + 4, t857)
  let t865 = min(max(input.min.1 + 4, t860), t861)
  let t837 = max(min(t854 + -2, ((t859 + -7)/2) + pool2D_r__0_1._1.extent_realized) + 1, t865)
  let t847 = min(max(t853 + -1, t864), t858)
  let t846 = min(t858, t864)
  let t840 = pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized
  let t835 = max(min(input.extent.2 + input.min.2, 3), 0) - t863
  let t845 = (t855 + t856) + input.min.0
  for (pool2D_r__0_1.s1._2.rebased, 0, t835) {
   let t869 = pool2D_r__0_1.s1._2.rebased + t863
   let t868 = (input.stride.2*t869) - t845
   let t866 = t865 - t860
   let t867 = (t840*t869) + (t857 - t862)
   for (pool2D_r__0_1.s1._1.rebased, 0, t866) {
    let t870 = (pool2D_r__0_1._0.extent_realized*pool2D_r__0_1.s1._1.rebased) + t867
    let t871 = pool2D_r__0_1.s1._1.rebased + t860
    for (pool2D_r__0_1.s1._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     let t872 = pool2D_r__0_1.s1._0.rebased + t870
     let t873 = pool2D_r__0_1.s1._0.rebased + t857
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t874 = pool2D_r__0_1.s1.r88$y.rebased + t871
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t734 = pool2D_r__0_1.s1.r88$x.rebased + t873
       pool2D_r__0_1[t872] = pool2D_r__0_1[t872] + (int16(select(((((t853 + 4) <= t734) || (t734 < (input.min.0 + 4))) || (t874 < (input.min.1 + 4))) || ((t854 + 4) <= t874), 7, input[max(min(t853 + 3, t734) + -4, input.min.0) + ((max(min(t854 + 3, t874) + -4, input.min.1)*input.stride.1) + t868)]))/(int16)36)
      }
     }
    }
   }
   let t885 = pool2D_r__0_1.s1._2.rebased + t863
   let t886 = input.stride.2*t885
   let t887 = t840*t885
   let t879 = t886 - t845
   let t878 = t865 - t860
   let t883 = t858 - t847
   let t880 = t847 - t846
   let t876 = t846 - t857
   let t875 = t837 - t865
   let t877 = (t857 - t862) + t887
   let t884 = (t847 - t862) + t887
   let t881 = (t846 - t862) + t887
   let t882 = (((t846 - t855) - t856) - input.min.0) + t886
   for (pool2D_r__0_1.s1._1.rebased, 0, t875) {
    let t888 = ((pool2D_r__0_1.s1._1.rebased + t878)*pool2D_r__0_1._0.extent_realized) + t877
    let t889 = pool2D_r__0_1.s1._1.rebased + t865
    for (pool2D_r__0_1.s1._0.rebased, 0, t876) {
     let t890 = pool2D_r__0_1.s1._0.rebased + t888
     let t891 = pool2D_r__0_1.s1._0.rebased + t857
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t892 = (((pool2D_r__0_1.s1.r88$y.rebased + t889) + -4)*input.stride.1) + t879
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t738 = pool2D_r__0_1.s1.r88$x.rebased + t891
       pool2D_r__0_1[t890] = pool2D_r__0_1[t890] + (int16(select(((t853 + 4) <= t738) || (t738 < (input.min.0 + 4)), 7, input[max(min(t853 + 3, t738) + -4, input.min.0) + t892]))/(int16)36)
      }
     }
    }
    let t893 = ((pool2D_r__0_1.s1._1.rebased + t878)*pool2D_r__0_1._0.extent_realized) + t881
    let t894 = pool2D_r__0_1.s1._1.rebased + t865
    for (pool2D_r__0_1.s1._0.rebased, 0, t880) {
     let t895 = pool2D_r__0_1.s1._0.rebased + t893
     let t896 = pool2D_r__0_1.s1._0.rebased + t882
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t897 = (((pool2D_r__0_1.s1.r88$y.rebased + t894) + -4)*input.stride.1) + t896
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       pool2D_r__0_1[t895] = pool2D_r__0_1[t895] + (int16(input[(pool2D_r__0_1.s1.r88$x.rebased + t897) + -4])/(int16)36)
      }
     }
    }
    let t898 = ((pool2D_r__0_1.s1._1.rebased + t878)*pool2D_r__0_1._0.extent_realized) + t884
    let t899 = pool2D_r__0_1.s1._1.rebased + t865
    for (pool2D_r__0_1.s1._0.rebased, 0, t883) {
     let t900 = pool2D_r__0_1.s1._0.rebased + t898
     let t901 = pool2D_r__0_1.s1._0.rebased + t847
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t902 = (((pool2D_r__0_1.s1.r88$y.rebased + t899) + -4)*input.stride.1) + t879
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t739 = pool2D_r__0_1.s1.r88$x.rebased + t901
       pool2D_r__0_1[t900] = pool2D_r__0_1[t900] + (int16(select(t739 < (t853 + 4), input[max(min(t853 + 3, t739) + -4, input.min.0) + t902], 7))/(int16)36)
      }
     }
    }
   }
   let t907 = pool2D_r__0_1.s1._2.rebased + t863
   let t906 = (input.stride.2*t907) - t845
   let t903 = t861 - t837
   let t905 = t837 - t860
   let t904 = (t840*t907) + (t857 - t862)
   for (pool2D_r__0_1.s1._1.rebased, 0, t903) {
    let t908 = ((pool2D_r__0_1.s1._1.rebased + t905)*pool2D_r__0_1._0.extent_realized) + t904
    let t909 = pool2D_r__0_1.s1._1.rebased + t837
    for (pool2D_r__0_1.s1._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     let t910 = pool2D_r__0_1.s1._0.rebased + t908
     let t911 = pool2D_r__0_1.s1._0.rebased + t857
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t912 = pool2D_r__0_1.s1.r88$y.rebased + t909
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t742 = pool2D_r__0_1.s1.r88$x.rebased + t911
       pool2D_r__0_1[t910] = pool2D_r__0_1[t910] + (int16(select((((t853 + 4) <= t742) || (t742 < (input.min.0 + 4))) || ((t854 + 4) <= t912), 7, input[max(min(t853 + 3, t742) + -4, input.min.0) + ((max(min(t854 + 3, t912) + -4, input.min.1)*input.stride.1) + t906)]))/(int16)36)
      }
     }
    }
   }
  }
  let t923 = input.extent.2 + input.min.2
  let t924 = max(min(t923, 3), 0)
  let t925 = pool2D_r__0_1.s1._0.min.s/4
  let t919 = (max(min(casted.min.1*2, 3999), 0) + -5)/2
  let t914 = t925 - (pool2D_r__0_1._0.min_realized.s/4)
  let t922 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t920 = input.extent.1 + input.min.1
  let t917 = input.extent.0 + input.min.0
  for (pool2D_r__0_1.s1._2.rebased, 0, 3 - t924) {
   let t927 = max(min(t923, 3), 0) + pool2D_r__0_1.s1._2.rebased
   let t926 = ((pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized)*(pool2D_r__0_1.s1._2.rebased + t924)) + t914
   for (pool2D_r__0_1.s1._1.rebased, 0, pool2D_r__0_1._1.extent_realized) {
    let t930 = t923 <= t927
    let t931 = (max(min(t923 + -1, t927), input.min.2)*input.stride.2) - t922
    let t928 = (pool2D_r__0_1._0.extent_realized*pool2D_r__0_1.s1._1.rebased) + t926
    let t929 = pool2D_r__0_1.s1._1.rebased + t919
    for (pool2D_r__0_1.s1._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     let t932 = pool2D_r__0_1.s1._0.rebased + t928
     let t933 = pool2D_r__0_1.s1._0.rebased + t925
     for (pool2D_r__0_1.s1.r88$y.rebased, 0, 6) {
      let t934 = pool2D_r__0_1.s1.r88$y.rebased + t929
      for (pool2D_r__0_1.s1.r88$x.rebased, 0, 6) {
       let t746 = pool2D_r__0_1.s1.r88$x.rebased + t933
       pool2D_r__0_1[t932] = pool2D_r__0_1[t932] + (int16(select((((((t917 + 4) <= t746) || (t746 < (input.min.0 + 4))) || (t934 < (input.min.1 + 4))) || ((t920 + 4) <= t934)) || t930, 7, input[max(min(t917 + 3, t746) + -4, input.min.0) + ((max(min(t920 + 3, t934) + -4, input.min.1)*input.stride.1) + t931)]))/(int16)36)
      }
     }
    }
   }
  }
 }
 let all._0.extent_realized.s = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*2) - (relu.s0._0.min/4)
 allocate all[int32 * (all._0.extent_realized.s + 2) * pool2D_r__0_1._1.extent_realized * 4]
 produce all {
  consume pool2D_r__0_1 {
   let t937 = (all._0.extent_realized.s + 2)*pool2D_r__0_1._1.extent_realized
   let t935 = (relu.s0._0.min/4) - (pool2D_r__0_1._0.min_realized.s/4)
   for (all.s0._2, 0, 4) {
    let t941 = pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized
    let t940 = all.s0._2*t937
    for (all.s0._1.rebased, 0, pool2D_r__0_1._1.extent_realized) {
     let t944 = ((all._0.extent_realized.s + 2)*all.s0._1.rebased) + t940
     let t942 = (all.s0._1.rebased*pool2D_r__0_1._0.extent_realized) + t935
     for (all.s0._0.rebased, 0, all._0.extent_realized.s + 2) {
      let t656 = all.s0._0.rebased + t942
      all[all.s0._0.rebased + t944] = ((all.s0._2 + 7)*int32(pool2D_r__0_1[t656 + t941])) + (((all.s0._2 + 10)*int32(pool2D_r__0_1[(t941*2) + t656])) + ((all.s0._2 + 4)*int32(pool2D_r__0_1[t656])))
     }
    }
   }
  }
 }
 allocate upsampled_linear__0[int32 * (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1) * pool2D_r__0_1._1.extent_realized * 4]
 produce upsampled_linear__0 {
  consume all {
   let t946 = (all._0.extent_realized.s + 2)*pool2D_r__0_1._1.extent_realized
   let t947 = relu.s0._0.min % 4
   let t945 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
   for (upsampled_linear__0.s0._2, 0, 4) {
    let t949 = ((t945 + 1)*pool2D_r__0_1._1.extent_realized)*upsampled_linear__0.s0._2
    let t948 = t946*upsampled_linear__0.s0._2
    for (upsampled_linear__0.s0._1.rebased, 0, pool2D_r__0_1._1.extent_realized) {
     let t951 = ((t945 + 1)*upsampled_linear__0.s0._1.rebased) + t949
     let t950 = ((all._0.extent_realized.s + 2)*upsampled_linear__0.s0._1.rebased) + t948
     for (upsampled_linear__0.s0._0.rebased, 0, t945 + 1) {
      let t658 = ((t947 + upsampled_linear__0.s0._0.rebased)/4) + t950
      let t752 = (relu.s0._0.min + upsampled_linear__0.s0._0.rebased) % 4
      upsampled_linear__0[t951 + upsampled_linear__0.s0._0.rebased] = int32((int16(((all[t658]*(4 - t752)) + (all[t658 + 1]*t752)))/(int16)8))
     }
    }
   }
  }
 }
 free all
 let upsampled_nn__1._1.extent_realized.s = max(min((casted.extent.1 + casted.min.1)*2, 4001), 2) - max(min(casted.min.1*2, 3999), 0)
 let upsampled_nn__1.stride.2 = (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1)*(upsampled_nn__1._1.extent_realized.s + 4)
 allocate upsampled_nn__1[int32 * (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1) * (upsampled_nn__1._1.extent_realized.s + 4) * 4]
 produce upsampled_nn__1 {
  consume upsampled_linear__0 {
   let t953 = max(min(casted.min.1*2, 3999), 0)
   let t952 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
   for (upsampled_nn__1.s0._2, 0, 4) {
    let t955 = (t953 + -5)/2
    let t954 = ((t952 + 1)*pool2D_r__0_1._1.extent_realized)*upsampled_nn__1.s0._2
    let t956 = upsampled_nn__1.s0._2*upsampled_nn__1.stride.2
    for (upsampled_nn__1.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + 4) {
     let t959 = t952 + 1
     let t957 = (((((t953 + upsampled_nn__1.s0._1.rebased) + -5)/2) - t955)*t959) + t954
     let t958 = (t959*upsampled_nn__1.s0._1.rebased) + t956
     for (upsampled_nn__1.s0._0.rebased, 0, t952 + 1) {
      upsampled_nn__1[t958 + upsampled_nn__1.s0._0.rebased] = upsampled_linear__0[t957 + upsampled_nn__1.s0._0.rebased]
     }
    }
   }
  }
 }
 free upsampled_linear__0
 let binary_op.stride.2 = (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1)*(upsampled_nn__1._1.extent_realized.s + 4)
 allocate binary_op[int32 * (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1) * (upsampled_nn__1._1.extent_realized.s + 4) * 4]
 produce binary_op {
  consume upsampled_nn__1 {
   let t972 = input.extent.0 + input.min.0
   let t973 = input.extent.2 + input.min.2
   let t974 = max(min(t973, 3), 0)
   let t975 = ((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8
   let t976 = max(min(input.min.2, 3), 0)
   let t977 = max(input.min.0*4, relu.s0._0.min)
   let t978 = t975 + 1
   let t962 = max(min(casted.min.1*2, 3999), 0)
   let t961 = min(max(t972*4, t977), t978)
   let t960 = min(t977, t978)
   let t969 = t974 - t976
   let t970 = 3 - t974
   let t966 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   let t964 = input.extent.1 + input.min.1
   for (binary_op.s0._2, 0, 4) {
    let t984 = max(min(t973, 3), 0)
    let t980 = binary_op.s0._2*upsampled_nn__1.stride.2
    let t982 = binary_op.s0._2*binary_op.stride.2
    let t985 = t975 - t961
    let t981 = t975 - relu.s0._0.min
    for (binary_op.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + 4) {
     let t994 = binary_op.s0._1.rebased + t962
     let t995 = (t994 + 1) % 2
     let t996 = (t981 + 1)*binary_op.s0._1.rebased
     let t990 = (t994 + -5)/2
     let t987 = t960 - relu.s0._0.min
     let t993 = t982 + t996
     let t992 = t980 + t996
     for (binary_op.s0._0.rebased, 0, t987) {
      allocate all_r[int32 * 2]
      produce all_r {
       let t997 = ((t994 + 1) % 2)/2
       for (all_r.s0._1.rebased, 0, 2) {
        all_r[all_r.s0._1.rebased + t997] = 0
       }
       let t998 = t995/2
       let t999 = binary_op.s0._0.rebased + relu.s0._0.min
       for (all_r.s1._1.rebased, 0, 2) {
        let t1004 = t999/4
        let t1002 = (t972 <= t1004) || (t1004 < input.min.0)
        let t1003 = max(min(t972 + -1, t1004), input.min.0) - t966
        let t1000 = all_r.s1._1.rebased + t998
        let t1001 = all_r.s1._1.rebased + t990
        for (all_r.s1.r108$x, 0, 3) {
         all_r[t1000] = all_r[t1000] + (select(((((t1001 < input.min.1) || t1002) || (t964 <= t1001)) || (all_r.s1.r108$x < input.min.2)) || (t973 <= all_r.s1.r108$x), 7, input[(max(min(t973 + -1, all_r.s1.r108$x), input.min.2)*input.stride.2) + ((max(min(t964 + -1, t1001), input.min.1)*input.stride.1) + t1003)])*(((all_r.s1.r108$x*3) + binary_op.s0._2) + 4))
        }
       }
      }
      consume all_r {
       let t671 = int16(((all_r[0]*(2 - t995)) + (all_r[1]*t995)))
       let t673 = upsampled_nn__1[binary_op.s0._0.rebased + t992]
       binary_op[binary_op.s0._0.rebased + t993] = select(int32((t671/(int16)4)) == t673, t673 % int32((t671/(int16)4)), int32((t671/(int16)4)))
      }
      free all_r
     }
     let t1016 = binary_op.s0._1.rebased + t962
     let t1017 = (t1016 + 1) % 2
     let t1018 = (t1016 + -5)/2
     let t1019 = max(input.min.1, t1018)
     let t1020 = (t1016 + -1)/2
     let t1021 = min(t1019, t1020)
     let t1022 = max(t1018, t964)
     let t1013 = max(t1020 - t1022, 0)
     let t1008 = min(max(t1019, t964), t1020)
     let t1012 = min(t1020, t1022) - t1021
     let t1005 = t961 - t960
     let t1015 = ((t981 + 1)*binary_op.s0._1.rebased) + (t960 - relu.s0._0.min)
     for (binary_op.s0._0.rebased, 0, t1005) {
      allocate all_r[int32 * 2]
      produce all_r {
       let t1023 = ((t1016 + 1) % 2)/2
       for (all_r.s0._1.rebased, 0, 2) {
        all_r[all_r.s0._1.rebased + t1023] = 0
       }
       let t1025 = t1017/2
       let t1026 = ((binary_op.s0._0.rebased + t960)/4) - t966
       let t1024 = t1021 - t1018
       for (all_r.s1._1.rebased, 0, t1024) {
        let t1027 = all_r.s1._1.rebased + t1025
        let t1028 = all_r.s1._1.rebased + t1018
        for (all_r.s1.r108$x, 0, 3) {
         all_r[t1027] = all_r[t1027] + (select((((t964 <= t1028) || (t1028 < input.min.1)) || (all_r.s1.r108$x < input.min.2)) || (t973 <= all_r.s1.r108$x), 7, input[(max(min(t973 + -1, all_r.s1.r108$x), input.min.2)*input.stride.2) + ((max(min(t964 + -1, t1028), input.min.1)*input.stride.1) + t1026)])*(((all_r.s1.r108$x*3) + binary_op.s0._2) + 4))
        }
       }
       let t1031 = (t1016 + -5)/2
       let t1029 = min(max(input.min.1, t1031), (t1016 + -1)/2) - t1031
       let t1030 = ((binary_op.s0._0.rebased + t960)/4) - t966
       for (all_r.s1._1.rebased, 0, t1012) {
        let t1033 = ((all_r.s1._1.rebased + t1021)*input.stride.1) + t1030
        let t1032 = all_r.s1._1.rebased + t1029
        for (all_r.s1.r108$x, 0, t976) {
         all_r[t1032] = all_r[t1032] + (select((t973 <= all_r.s1.r108$x) || (all_r.s1.r108$x < input.min.2), 7, input[(max(min(t973 + -1, all_r.s1.r108$x), input.min.2)*input.stride.2) + t1033])*(((all_r.s1.r108$x*3) + binary_op.s0._2) + 4))
        }
        let t1035 = ((all_r.s1._1.rebased + t1021)*input.stride.1) + t1030
        let t1034 = all_r.s1._1.rebased + t1029
        for (all_r.s1.r108$x.rebased, 0, t969) {
         let t778 = all_r.s1.r108$x.rebased + t976
         all_r[t1034] = all_r[t1034] + (input[(input.stride.2*t778) + t1035]*(((t778*3) + binary_op.s0._2) + 4))
        }
        let t1037 = ((all_r.s1._1.rebased + t1021)*input.stride.1) + t1030
        let t1036 = all_r.s1._1.rebased + t1029
        for (all_r.s1.r108$x.rebased, 0, t970) {
         let t781 = all_r.s1.r108$x.rebased + t984
         all_r[t1036] = all_r[t1036] + (select(t781 < t973, input[(max(min(t973 + -1, t781), input.min.2)*input.stride.2) + t1037], 7)*(((t781*3) + binary_op.s0._2) + 4))
        }
       }
       let t1040 = (t1016 + -5)/2
       let t1038 = min(max(t1040, t964), (t1016 + -1)/2) - t1040
       let t1039 = ((binary_op.s0._0.rebased + t960)/4) - t966
       for (all_r.s1._1.rebased, 0, t1013) {
        let t1041 = all_r.s1._1.rebased + t1038
        let t1042 = all_r.s1._1.rebased + t1008
        for (all_r.s1.r108$x, 0, 3) {
         all_r[t1041] = all_r[t1041] + (select(((t964 <= t1042) || (all_r.s1.r108$x < input.min.2)) || (t973 <= all_r.s1.r108$x), 7, input[(max(min(t973 + -1, all_r.s1.r108$x), input.min.2)*input.stride.2) + ((max(min(t964 + -1, t1042), input.min.1)*input.stride.1) + t1039)])*(((all_r.s1.r108$x*3) + binary_op.s0._2) + 4))
        }
       }
      }
      consume all_r {
       let t696 = int16(((all_r[0]*(2 - t1017)) + (all_r[1]*t1017)))
       let t697 = binary_op.s0._0.rebased + t1015
       let t698 = upsampled_nn__1[t697 + t980]
       binary_op[t697 + t982] = select(int32((t696/(int16)4)) == t698, t698 % int32((t696/(int16)4)), int32((t696/(int16)4)))
      }
      free all_r
     }
     let t1048 = binary_op.s0._1.rebased + t962
     let t1049 = (t1048 + 1) % 2
     let t1045 = (t1048 + -5)/2
     let t1047 = ((t981 + 1)*binary_op.s0._1.rebased) + (t961 - relu.s0._0.min)
     for (binary_op.s0._0.rebased, 0, t985 + 1) {
      allocate all_r[int32 * 2]
      produce all_r {
       let t1050 = ((t1048 + 1) % 2)/2
       for (all_r.s0._1.rebased, 0, 2) {
        all_r[all_r.s0._1.rebased + t1050] = 0
       }
       let t1051 = t1049/2
       let t1052 = binary_op.s0._0.rebased + t961
       for (all_r.s1._1.rebased, 0, 2) {
        let t1057 = t1052/4
        let t1055 = t972 <= t1057
        let t1056 = max(min(t972 + -1, t1057), input.min.0) - t966
        let t1053 = all_r.s1._1.rebased + t1051
        let t1054 = all_r.s1._1.rebased + t1045
        for (all_r.s1.r108$x, 0, 3) {
         all_r[t1053] = all_r[t1053] + (select(((((t1054 < input.min.1) || t1055) || (t964 <= t1054)) || (all_r.s1.r108$x < input.min.2)) || (t973 <= all_r.s1.r108$x), 7, input[(max(min(t973 + -1, all_r.s1.r108$x), input.min.2)*input.stride.2) + ((max(min(t964 + -1, t1054), input.min.1)*input.stride.1) + t1056)])*(((all_r.s1.r108$x*3) + binary_op.s0._2) + 4))
        }
       }
      }
      consume all_r {
       let t706 = int16(((all_r[0]*(2 - t1049)) + (all_r[1]*t1049)))
       let t707 = binary_op.s0._0.rebased + t1047
       let t708 = upsampled_nn__1[t707 + t980]
       binary_op[t707 + t982] = select(int32((t706/(int16)4)) == t708, t708 % int32((t706/(int16)4)), int32((t706/(int16)4)))
      }
      free all_r
     }
    }
   }
  }
 }
 free upsampled_nn__1
 allocate binary_op$1[int32 * (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1) * (upsampled_nn__1._1.extent_realized.s + 4) * 4]
 produce binary_op$1 {
  consume binary_op {
   consume pool2D_r__0_1 {
    let t1059 = max(min(casted.min.1*2, 3999), 0)
    let t1060 = pool2D_r__0_1._0.min_realized.s/4
    let t1061 = pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized
    let t1058 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
    for (binary_op$1.s0._2, 0, 4) {
     let t1062 = (t1059 + -5)/2
     let t1063 = binary_op$1.s0._2*binary_op.stride.2
     for (binary_op$1.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + 4) {
      let t1064 = (((((binary_op$1.s0._1.rebased + t1059) + -5)/2) - t1062)*pool2D_r__0_1._0.extent_realized) - t1060
      let t1065 = ((t1058 + 1)*binary_op$1.s0._1.rebased) + t1063
      for (binary_op$1.s0._0.rebased, 0, t1058 + 1) {
       allocate all_r$1[int32 * 2]
       produce all_r$1 {
        for (all_r$1.s0._0.rebased, 0, 2) {
         all_r$1[all_r$1.s0._0.rebased] = 0
        }
        let t1066 = ((binary_op$1.s0._0.rebased + relu.s0._0.min)/4) + t1064
        for (all_r$1.s1._0.rebased, 0, 2) {
         let t1067 = all_r$1.s1._0.rebased + t1066
         for (all_r$1.s1.r128$x, 0, 3) {
          all_r$1[all_r$1.s1._0.rebased] = all_r$1[all_r$1.s1._0.rebased] + ((((all_r$1.s1.r128$x*3) + binary_op$1.s0._2) + 4)*int32(pool2D_r__0_1[(all_r$1.s1.r128$x*t1061) + t1067]))
         }
        }
       }
       consume all_r$1 {
        let t709 = binary_op$1.s0._0.rebased + t1065
        let t798 = (binary_op$1.s0._0.rebased + relu.s0._0.min) % 4
        binary_op$1[t709] = max(binary_op[t709], int32((int16(((all_r$1[0]*(4 - t798)) + (all_r$1[1]*t798)))/(int16)8)))
       }
       free all_r$1
      }
     }
    }
   }
  }
 }
 free binary_op
 let relu.stride.2 = (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1)*(upsampled_nn__1._1.extent_realized.s + 4)
 allocate relu[int32 * (((((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min) + 1) * (upsampled_nn__1._1.extent_realized.s + 4) * 4]
 produce relu {
  consume binary_op$1 {
   let t1068 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
   for (relu.s0._2, 0, 4) {
    let t1070 = relu.s0._2*relu.stride.2
    let t1069 = binary_op.stride.2*relu.s0._2
    for (relu.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + 4) {
     let t1071 = (t1068 + 1)*relu.s0._1.rebased
     for (relu.s0._0.rebased, 0, t1068 + 1) {
      relu[(t1070 + t1071) + relu.s0._0.rebased] = max(binary_op$1[(t1069 + t1071) + relu.s0._0.rebased], 0)
     }
    }
   }
  }
 }
 free binary_op$1
 let sliced._0.extent_realized.s = max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) - max(min(casted.min.0*4, 7999), 0)
 allocate sliced[int32 * (sliced._0.extent_realized.s + 2) * (upsampled_nn__1._1.extent_realized.s + 4) * 1]
 produce sliced {
  consume relu {
   consume pool2D_r__0_1 {
    let t1072 = max(min(casted.min.1*2, 3999), 0)
    let t1074 = max(min(casted.min.0*4, 7999), 0)
    let t1073 = pool2D_r__0_1._0.min_realized.s/4
    let t1075 = pool2D_r__0_1._0.extent_realized*pool2D_r__0_1._1.extent_realized
    let t1076 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
    for (sliced.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + 4) {
     let t1078 = (t1076 + 1)*sliced.s0._1.rebased
     let t1079 = (sliced._0.extent_realized.s + 2)*sliced.s0._1.rebased
     let t1077 = (((((sliced.s0._1.rebased + t1072) + -5)/2) - ((t1072 + -5)/2))*pool2D_r__0_1._0.extent_realized) - t1073
     for (sliced.s0._0.rebased, 0, sliced._0.extent_realized.s + 2) {
      allocate all_r$3[int32 * 1]
      produce all_r$3 {
       all_r$3[0] = 0
       let t1080 = (((sliced.s0._0.rebased + t1074) + -5)/4) + t1077
       for (all_r$3.s1.r174$x, 0, 3) {
        all_r$3[0] = all_r$3[0] + (((all_r$3.s1.r174$x*3) + 4)*int32(pool2D_r__0_1[(all_r$3.s1.r174$x*t1075) + t1080]))
       }
      }
      consume all_r$3 {
       sliced[sliced.s0._0.rebased + t1079] = relu[(((((max(min(all_r$3[0], 3), 0)*relu.stride.2) + t1074) - relu.s0._0.min) + t1078) + sliced.s0._0.rebased) + -5]
      }
      free all_r$3
     }
    }
   }
  }
 }
 free pool2D_r__0_1
 allocate pooled2D_w__0_1[int16 * (sliced._0.extent_realized.s + -3) * (upsampled_nn__1._1.extent_realized.s + -1) * 1]
 produce pooled2D_w__0_1 {
  consume sliced {
   for (pooled2D_w__0_1.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + -1) {
    let t1081 = (sliced._0.extent_realized.s + -3)*pooled2D_w__0_1.s0._1.rebased
    for (pooled2D_w__0_1.s0._0.rebased, 0, sliced._0.extent_realized.s + -3) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r194$y.rebased, 0, 6) {
       let t1082 = ((pooled2D_w__0_1.s0._1.rebased + sum.s1.r194$y.rebased)*(sliced._0.extent_realized.s + 2)) + pooled2D_w__0_1.s0._0.rebased
       for (sum.s1.r194$x.rebased, 0, 6) {
        sum[0] = sum[0] + sliced[sum.s1.r194$x.rebased + t1082]
       }
      }
     }
     consume sum {
      pooled2D_w__0_1[pooled2D_w__0_1.s0._0.rebased + t1081] = int16(sum[0])/(int16)36
     }
     free sum
    }
   }
  }
 }
 free sliced
 let downsampled_nn__0._0.extent_realized.s = ((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8) - (max(min(casted.min.0*4, 7999), 0)/8)
 let downsampled_nn__0.stride.2 = (downsampled_nn__0._0.extent_realized.s + 1)*(upsampled_nn__1._1.extent_realized.s + -1)
 allocate downsampled_nn__0[int32 * (downsampled_nn__0._0.extent_realized.s + 1) * (upsampled_nn__1._1.extent_realized.s + -1) * 4]
 let downsampled_nn__0.s0._0.loop_extent = ((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 12)/8) - (max(min(casted.min.0*4, 7999), 0)/8)
 produce downsampled_nn__0 {
  consume relu {
   let t1084 = max(min(casted.min.0*4, 7999), 0)/8
   let t1083 = (((max(min((casted.extent.0 + casted.min.0)*4, 8003), 4) + 4)/8)*8) - relu.s0._0.min
   for (downsampled_nn__0.s0._2, 0, 4) {
    let t1086 = downsampled_nn__0.s0._2*downsampled_nn__0.stride.2
    let t1085 = (downsampled_nn__0.s0._2*relu.stride.2) - relu.s0._0.min
    for (downsampled_nn__0.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + -1) {
     let t1087 = ((downsampled_nn__0.s0._1.rebased + 5)*(t1083 + 1)) + t1085
     let t1088 = ((downsampled_nn__0._0.extent_realized.s + 1)*downsampled_nn__0.s0._1.rebased) + t1086
     for (downsampled_nn__0.s0._0.rebased, 0, downsampled_nn__0.s0._0.loop_extent) {
      downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t1088] = relu[((downsampled_nn__0.s0._0.rebased + t1084)*8) + t1087]
     }
    }
   }
  }
 }
 free relu
 allocate binary_op$4[int32 * (sliced._0.extent_realized.s + -3) * (upsampled_nn__1._1.extent_realized.s + -1) * 1]
 produce binary_op$4 {
  consume downsampled_nn__0 {
   consume pooled2D_w__0_1 {
    let t1089 = max(min(casted.min.0*4, 7999), 0)
    for (binary_op$4.s0._1.rebased, 0, upsampled_nn__1._1.extent_realized.s + -1) {
     let t1091 = (sliced._0.extent_realized.s + -3)*binary_op$4.s0._1.rebased
     let t1090 = ((downsampled_nn__0._0.extent_realized.s + 1)*binary_op$4.s0._1.rebased) - (t1089/8)
     for (binary_op$4.s0._0.rebased, 0, sliced._0.extent_realized.s + -3) {
      allocate all_r$4[int32 * 2]
      produce all_r$4 {
       for (all_r$4.s0._0.rebased, 0, 2) {
        all_r$4[all_r$4.s0._0.rebased] = 0
       }
       let t1092 = ((binary_op$4.s0._0.rebased + t1089)/8) + t1090
       for (all_r$4.s1._0.rebased, 0, 2) {
        let t1093 = all_r$4.s1._0.rebased + t1092
        for (all_r$4.s1.r250$x, 0, 4) {
         all_r$4[all_r$4.s1._0.rebased] = all_r$4[all_r$4.s1._0.rebased] + (downsampled_nn__0[(all_r$4.s1.r250$x*downsampled_nn__0.stride.2) + t1093]*((all_r$4.s1.r250$x*4) + 5))
        }
       }
      }
      consume all_r$4 {
       let t715 = let t1151 = ((binary_op$4.s0._0.rebased + t1089) % 8) in int16(((all_r$4[0]*(8 - t1151)) + (all_r$4[1]*t1151)))
       let t803 = binary_op$4.s0._0.rebased + t1091
       binary_op$4[t803] = min(int32((t715/(int16)16)), int32(pooled2D_w__0_1[t803])) + int32((t715/(int16)16))
      }
      free all_r$4
     }
    }
   }
  }
 }
 free pooled2D_w__0_1
 free downsampled_nn__0
 allocate constant_exterior$1[int32 * ((casted.extent.0*4) + -3) * ((casted.extent.1*2) + -1) * 1]
 produce constant_exterior$1 {
  consume binary_op$4 {
   let constant_exterior$1.s0._1.prologue = min(max(casted.min.1, 0)*2, ((casted.extent.1 + casted.min.1)*2) + -1)
   let constant_exterior$1.s0._1.epilogue = let t1152 = (casted.extent.1 + casted.min.1) in max(min(max(casted.min.1, 0)*2, (t1152*2) + -1), min(t1152*2, 4001) + -1)
   let t1100 = casted.min.1*2
   let t1101 = casted.min.0*4
   let t1098 = max(min(t1100, 3999), 0)
   let t1099 = max(min(t1101, 7999), 0)
   let t1095 = casted.extent.0*4
   let t1094 = constant_exterior$1.s0._1.prologue - t1100
   for (constant_exterior$1.s0._1.rebased, 0, t1094) {
    let t1103 = (t1095 + -3)*constant_exterior$1.s0._1.rebased
    let t1102 = constant_exterior$1.s0._1.rebased + t1100
    for (constant_exterior$1.s0._0.rebased, 0, t1095 + -3) {
     let t805 = constant_exterior$1.s0._0.rebased + t1101
     constant_exterior$1[constant_exterior$1.s0._0.rebased + t1103] = select(((8000 <= t805) || (t805 < 0)) || (t1102 < 0), 0, binary_op$4[max(min(t805, 7999), 0) + (((max(t1102, 0) - t1098)*(sliced._0.extent_realized.s + -3)) - t1099)])
    }
   }
   let t1113 = casted.min.1*2
   let t1114 = casted.min.0*4
   let t1115 = (casted.extent.0 + casted.min.0)*4
   let t1116 = min(max(casted.min.0, 0)*4, t1115 + -3)
   let t1106 = max(min(t1115, 8003) + -3, t1116)
   let t1109 = max(min(t1114, 7999), 0)
   let t1111 = casted.extent.0*4
   let t1108 = constant_exterior$1.s0._1.prologue - max(min(t1113, 3999), 0)
   let t1110 = constant_exterior$1.s0._1.prologue - t1113
   let t1104 = constant_exterior$1.s0._1.epilogue - constant_exterior$1.s0._1.prologue
   for (constant_exterior$1.s0._1.rebased, 0, t1104) {
    let t1119 = (constant_exterior$1.s0._1.rebased + t1110)*(t1111 + -3)
    let t1118 = ((constant_exterior$1.s0._1.rebased + t1108)*(sliced._0.extent_realized.s + -3)) - t1109
    let t1117 = t1116 - t1114
    for (constant_exterior$1.s0._0.rebased, 0, t1117) {
     let t808 = constant_exterior$1.s0._0.rebased + t1114
     constant_exterior$1[constant_exterior$1.s0._0.rebased + t1119] = select(t808 < 0, 0, binary_op$4[max(t808, 0) + t1118])
    }
    let t1120 = t1106 - t1116
    let t1122 = ((constant_exterior$1.s0._1.rebased + t1110)*(t1111 + -3)) + (t1116 - t1114)
    let t1121 = ((constant_exterior$1.s0._1.rebased + t1108)*(sliced._0.extent_realized.s + -3)) + (t1116 - t1109)
    for (constant_exterior$1.s0._0.rebased, 0, t1120) {
     constant_exterior$1[constant_exterior$1.s0._0.rebased + t1122] = binary_op$4[constant_exterior$1.s0._0.rebased + t1121]
    }
    let t1124 = ((constant_exterior$1.s0._1.rebased + t1108)*(sliced._0.extent_realized.s + -3)) - t1109
    let t1123 = t1115 - t1106
    let t1125 = ((constant_exterior$1.s0._1.rebased + t1110)*(t1111 + -3)) + (t1106 - t1114)
    for (constant_exterior$1.s0._0.rebased, 0, t1123 + -3) {
     let t809 = constant_exterior$1.s0._0.rebased + t1106
     constant_exterior$1[constant_exterior$1.s0._0.rebased + t1125] = select(t809 < 8000, binary_op$4[max(min(t809, 7999), 0) + t1124], 0)
    }
   }
   let t1132 = casted.min.1*2
   let t1133 = casted.min.0*4
   let t1129 = max(min(t1132, 3999), 0)
   let t1130 = max(min(t1133, 7999), 0)
   let t1127 = casted.extent.0*4
   let t1126 = ((casted.extent.1 + casted.min.1)*2) - constant_exterior$1.s0._1.epilogue
   let t1131 = constant_exterior$1.s0._1.epilogue - t1132
   for (constant_exterior$1.s0._1.rebased, 0, t1126 + -1) {
    let t1135 = (constant_exterior$1.s0._1.rebased + t1131)*(t1127 + -3)
    let t1134 = constant_exterior$1.s0._1.epilogue + constant_exterior$1.s0._1.rebased
    for (constant_exterior$1.s0._0.rebased, 0, t1127 + -3) {
     let t810 = constant_exterior$1.s0._0.rebased + t1133
     constant_exterior$1[constant_exterior$1.s0._0.rebased + t1135] = select(((8000 <= t810) || (t810 < 0)) || (4000 <= t1134), 0, binary_op$4[max(min(t810, 7999), 0) + (((max(min(t1134, 3999), 0) - t1129)*(sliced._0.extent_realized.s + -3)) - t1130)])
    }
   }
   free binary_op$4
  }
 }
 produce casted {
  consume constant_exterior$1 {
   let t1137 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t1141 = casted.min.2 + casted.s0._2.rebased
    let t1140 = (casted.stride.2*t1141) + t1137
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t1142 = ((casted.extent.0*4) + -3)*casted.s0._1.rebased
     let t1143 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t1140
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$5[int32 * 1]
      produce all_r$5 {
       all_r$5[0] = 0
       all_r$5[0] = all_r$5[0] + (constant_exterior$1[((casted.s0._0.rebased*2) + t1142)*2]*(t1141 + 2))
      }
      consume all_r$5 {
       casted[casted.s0._0.rebased + t1143] = all_r$5[0]
      }
      free all_r$5
     }
    }
   }
  }
 }
 free constant_exterior$1
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (int32(((int16)v0/(int16)4)) != 0)
Original expression:
(int32(((int16)t671/(int16)4)) != 0)
Failed to prove, but could not find a counter-example:
 (int32(((int16)v0/(int16)4)) != 0)
Original expression:
(int32(((int16)t696/(int16)4)) != 0)
Failed to prove, but could not find a counter-example:
 (int32(((int16)v0/(int16)4)) != 0)
Original expression:
(int32(((int16)t706/(int16)4)) != 0)
add_temp_object_file: /tmp/YYyuEp/random_pipeline.a.o
Module.compile(): temporary object /tmp/YYyuEp/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50037_0/random_pipeline.a
file_unlink: /tmp/YYyuEp/random_pipeline.a.o
dir_rmdir: /tmp/YYyuEp
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50037_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50037_0/random_pipeline.registration.cpp
