Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50043_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(all_r(_0, _1, _2)/all_r$1(_0, _1, _2))
In random expression: (uint1)0
The following expressions were unused:
all_r(_0, _1, _2)
binary_op(_0, _1, _2)
(let t7 = binary_op(_0, _1, _2) in (let t8 = all_r(_0, _1, _2) in (select(t7 == t8, t8, t7) <= max(t7, t8))))
(int32((uint1)binary_op$1(_0, _1, _2)) != binary_op(_0, _1, _2))
In random expression: (let t17 = conv_r__0(_0 + -1, _1, _2) in select(t17 == 0, 0, 1))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + 1, _1, _2)
conv_r__0(_0 + 2, _1, _2)
In random expression: uint16((conv_r__0(_0 + 2, _1, _2) % conv_r__0(_0 + 1, _1, _2)))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + -1, _1, _2)
In random expression: (conv_r__0(_0 + 1, _1, _2) + conv_r__0(_0 + -1, _1, _2))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + 2, _1, _2)
In random expression: (conv_r__0(_0 + 2, _1, _2) % conv_r__0(_0, _1, _2))
The following expressions were unused:
conv_r__0(_0 + -1, _1, _2)
conv_r__0(_0 + 1, _1, _2)
In random expression: (conv_r__0(_0 + 2, _1, _2) % conv_r__0(_0, _1, _2))
The following expressions were unused:
conv_r__0(_0 + -1, _1, _2)
conv_r__0(_0 + 1, _1, _2)
In random expression: (conv_r__0(_0 + 1, _1, _2)/conv_r__0(_0, _1, _2))
The following expressions were unused:
conv_r__0(_0 + -1, _1, _2)
conv_r__0(_0 + 2, _1, _2)
In random expression: (conv_r__0(_0, _1, _2)/conv_r__0(_0 + 2, _1, _2))
The following expressions were unused:
conv_r__0(_0 + -1, _1, _2)
conv_r__0(_0 + 1, _1, _2)
In random expression: (conv_r__0(_0 + 1, _1, _2) % conv_r__0(_0 + 2, _1, _2))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + -1, _1, _2)
In random expression: (conv_r__0(_0 + -1, _1, _2)*conv_r__0(_0 + 2, _1, _2))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + 1, _1, _2)
In random expression: max(conv_r__0(_0 + -1, _1, _2), conv_r__0(_0 + 1, _1, _2))
The following expressions were unused:
conv_r__0(_0, _1, _2)
conv_r__0(_0 + 2, _1, _2)
((((0 + conv_r__0(_0 + -1, _1, _2)) + conv_r__0(_0, _1, _2)) + conv_r__0(_0 + 1, _1, _2)) + conv_r__0(_0 + 2, _1, _2))
In random expression: (let t18 = (uint1)binary_op$1(_0, _1, _2) in t18)
The following expressions were unused:
(int16)pooled2D_w__0_1(_0, _1, _2)
In random expression: (int16)0
The following expressions were unused:
(int16)pooled2D_w__0_1(_0, _1, _2)
(uint1)binary_op$1(_0, _1, _2)
(let t20 = (int16)pooled2D_w__0_1(_0, _1, _2) in (int16((t20 <= int16((uint1)binary_op$1(_0, _1, _2))))/t20))
In random expression: (let t22 = constant_exterior$1(_0, _1, _2) in (t22*2))
The following expressions were unused:
constant_exterior$1(_0, _1 + 1, _2)
constant_exterior$1(_0, _1 + 2, _2)
max(constant_exterior$1(_0, _1 + 1, _2), min(constant_exterior$1(_0, _1, _2), constant_exterior$1(_0, _1 + 2, _2)))
(let t23 = constant_exterior$1(_0, _1, _2) in (conv__0(_0, _1, _2) + t23))
In random expression: (let t24 = (uint1)binary_op$1(_0, _1, _2) in t24)
The following expressions were unused:
constant_exterior(_0, _1, _2)
In random expression: (uint1)0
The following expressions were unused:
constant_exterior(_0, _1, _2)
(uint1)binary_op$1(_0, _1, _2)
In random expression: (let t26 = constant_exterior(_0, _1, _2) in (t26*t26))
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
In random expression: (let t27 = (uint1)binary_op$1(_0, _1, _2) in t27)
The following expressions were unused:
constant_exterior(_0, _1, _2)
In random expression: (let t28 = (uint1)binary_op$1(_0, _1, _2) in t28)
The following expressions were unused:
constant_exterior(_0, _1, _2)
In random expression: 0
The following expressions were unused:
constant_exterior(_0, _1, _2)
(uint1)binary_op$1(_0, _1, _2)
In random expression: (let t30 = constant_exterior(_0, _1, _2) in t30)
The following expressions were unused:
(uint1)binary_op$1(_0, _1, _2)
(int32((uint1)binary_op$1(_0, _1, _2))/constant_exterior(_0, _1, _2))
(let t35 = (int16)binary_op$3(_0, _1, _2) in ((t35/int16((uint1)binary_op$1(_0, _1, _2))) % t35))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Inlining upsampled_nn__0
Injecting realization of { all_r$2 }
Injecting realization of { downsampled_box__0 }
Injecting realization of { binary_op }
Injecting realization of { all_r$1 }
Injecting realization of { all_r }
Inlining repeat_edge
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required = let t339 = (input.extent.0 + input.min.0) in (max(min(((((casted.extent.0 + casted.min.0) + -1)/8)*8) + 9, t339), input.min.0 + 1) - max(min(((casted.min.0/8)*8) + 2, t339) + -1, input.min.0))
let input.min.0.required = max(min(((casted.min.0/8)*8) + 2, input.extent.0 + input.min.0) + -1, input.min.0)
let input.extent.1.required = let t340 = (input.extent.1 + input.min.1) in (max(min(casted.extent.1 + casted.min.1, t340), input.min.1 + 1) - max(min(t340 + -1, casted.min.1), input.min.1))
let input.min.1.required = max(min((input.extent.1 + input.min.1) + -1, casted.min.1), input.min.1)
let input.extent.2.required.s = let t341 = (input.extent.2 + input.min.2) in (min(t341, 3) - max(min(t341, 1) + -1, input.min.2))
let input.min.2.required = max(min(input.extent.2 + input.min.2, 1) + -1, input.min.2)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required, 0, input.min.2.required, max(input.extent.2.required.s, 1), input.extent.0.required*input.extent.1.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && ((max(input.extent.2.required.s, 1) + input.min.2.required) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, (max(input.extent.2.required.s, 1) + input.min.2.required) + -1, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 let all_r._0.extent_realized.s = (((casted.extent.0 + casted.min.0) + -1)/8) - (casted.min.0/8)
 allocate all_r[int32 * ((all_r._0.extent_realized.s*8) + 8) * casted.extent.1 * 24]
 produce all_r {
  let t178 = all_r._0.extent_realized.s*8
  let t177 = (t178 + 8)*casted.extent.1
  for (all_r.s0._2, 0, 24) {
   let t179 = all_r.s0._2*t177
   for (all_r.s0._1.rebased, 0, casted.extent.1) {
    let t180 = ((t178 + 8)*all_r.s0._1.rebased) + t179
    for (all_r.s0._0.rebased, 0, t178 + 8) {
     all_r[all_r.s0._0.rebased + t180] = 0
    }
   }
  }
  let t199 = casted.extent.1 + casted.min.1
  let t200 = input.extent.0 + input.min.0
  let t201 = input.extent.1 + input.min.1
  let t202 = input.extent.2 + input.min.2
  let t203 = input.min.2*input.stride.2
  let t204 = input.min.1*input.stride.1
  let t205 = max(min(t202, 3), 0)
  let t206 = max(min(input.min.2, 3), 0)
  let t207 = all_r._0.extent_realized.s*8
  let t208 = casted.min.0/8
  let t209 = (all_r._0.extent_realized.s + t208)*8
  let t210 = t208*8
  let t211 = max(casted.min.1, input.min.1)
  let t212 = max(t210 + 1, input.min.0)
  let t213 = t209 + 9
  let t191 = min(max(t200, t212), t213)
  let t182 = min(max(t201, t211), t199)
  let t190 = min(t212, t213)
  let t181 = min(t199, t211)
  let t184 = (t207 + 8)*casted.extent.1
  let t195 = t205 - t206
  let t196 = 3 - t205
  let t186 = (t203 + t204) + input.min.0
  for (all_r.s1._2, 0, 24) {
   let t215 = all_r.s1._2*t184
   let t214 = t181 - casted.min.1
   for (all_r.s1._1.rebased, 0, t214) {
    let t217 = (max(min(t201 + -1, all_r.s1._1.rebased + casted.min.1), input.min.1)*input.stride.1) - t186
    let t216 = ((t207 + 8)*all_r.s1._1.rebased) + t215
    for (all_r.s1._0.rebased, 0, t207 + 8) {
     let t219 = max(min((all_r.s1._0.rebased + t210) + 2, t200) + -1, input.min.0) + t217
     let t218 = all_r.s1._0.rebased + t216
     for (all_r.s1.r85$x, 0, 3) {
      all_r[t218] = all_r[t218] + (input[(max(min(t202 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t219]*(((all_r.s1.r85$x*3) + all_r.s1._2) + 4))
     }
    }
   }
   let t230 = all_r.s1._2*t184
   let t231 = t190 - t210
   let t227 = max(min(t202, 3), 0)
   let t226 = ((t190 - t203) - t204) - input.min.0
   let t228 = t209 - t191
   let t224 = t191 - t190
   let t220 = t182 - t181
   let t223 = t181 - casted.min.1
   let t229 = (t191 - t210) + t230
   for (all_r.s1._1.rebased, 0, t220) {
    let t233 = ((all_r.s1._1.rebased + t181)*input.stride.1) - t186
    let t232 = ((all_r.s1._1.rebased + t223)*(t207 + 8)) + t230
    for (all_r.s1._0.rebased, 0, t231 + -1) {
     let t235 = max(min((all_r.s1._0.rebased + t210) + 2, t200) + -1, input.min.0) + t233
     let t234 = all_r.s1._0.rebased + t232
     for (all_r.s1.r85$x, 0, 3) {
      all_r[t234] = all_r[t234] + (input[(max(min(t202 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t235]*(((all_r.s1.r85$x*3) + all_r.s1._2) + 4))
     }
    }
    let t236 = ((all_r.s1._1.rebased + t223)*(t207 + 8)) + (t230 + t231)
    let t237 = ((all_r.s1._1.rebased + t181)*input.stride.1) + t226
    for (all_r.s1._0.rebased, 0, t224) {
     let t239 = all_r.s1._0.rebased + t237
     let t238 = all_r.s1._0.rebased + t236
     for (all_r.s1.r85$x, 0, t206) {
      all_r[t238 + -1] = all_r[t238 + -1] + (input[(max(min(t202 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t239]*(((all_r.s1.r85$x*3) + all_r.s1._2) + 4))
     }
     let t241 = all_r.s1._0.rebased + t237
     let t240 = all_r.s1._0.rebased + t236
     for (all_r.s1.r85$x.rebased, 0, t195) {
      let t170 = all_r.s1.r85$x.rebased + t206
      all_r[t240 + -1] = all_r[t240 + -1] + (input[(input.stride.2*t170) + t241]*(((t170*3) + all_r.s1._2) + 4))
     }
     let t243 = all_r.s1._0.rebased + t237
     let t242 = all_r.s1._0.rebased + t236
     for (all_r.s1.r85$x.rebased, 0, t196) {
      let t172 = all_r.s1.r85$x.rebased + t227
      all_r[t242 + -1] = all_r[t242 + -1] + (input[(max(min(t202 + -1, t172), input.min.2)*input.stride.2) + t243]*(((t172*3) + all_r.s1._2) + 4))
     }
    }
    let t245 = ((all_r.s1._1.rebased + t181)*input.stride.1) - t186
    let t244 = ((all_r.s1._1.rebased + t223)*(t207 + 8)) + t229
    for (all_r.s1._0.rebased, 0, t228 + 9) {
     let t247 = max(min(t200 + -1, all_r.s1._0.rebased + t191), input.min.0) + t245
     let t246 = all_r.s1._0.rebased + t244
     for (all_r.s1.r85$x, 0, 3) {
      all_r[t246 + -1] = all_r[t246 + -1] + (input[(max(min(t202 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t247]*(((all_r.s1.r85$x*3) + all_r.s1._2) + 4))
     }
    }
   }
   let t249 = all_r.s1._2*t184
   let t248 = t199 - t182
   let t250 = t182 - casted.min.1
   for (all_r.s1._1.rebased, 0, t248) {
    let t252 = (max(min(t201 + -1, all_r.s1._1.rebased + t182), input.min.1)*input.stride.1) - t186
    let t251 = ((all_r.s1._1.rebased + t250)*(t207 + 8)) + t249
    for (all_r.s1._0.rebased, 0, t207 + 8) {
     let t254 = max(min((all_r.s1._0.rebased + t210) + 2, t200) + -1, input.min.0) + t252
     let t253 = all_r.s1._0.rebased + t251
     for (all_r.s1.r85$x, 0, 3) {
      all_r[t253] = all_r[t253] + (input[(max(min(t202 + -1, all_r.s1.r85$x), input.min.2)*input.stride.2) + t254]*(((all_r.s1.r85$x*3) + all_r.s1._2) + 4))
     }
    }
   }
  }
 }
 allocate binary_op[int32 * ((all_r._0.extent_realized.s*8) + 8) * casted.extent.1 * 24]
 produce binary_op {
  consume all_r {
   let t273 = casted.extent.1 + casted.min.1
   let t274 = input.extent.0 + input.min.0
   let t275 = input.extent.1 + input.min.1
   let t276 = input.extent.2 + input.min.2
   let t277 = input.min.2*input.stride.2
   let t278 = input.min.1*input.stride.1
   let t279 = max(min(t276, 3), 0)
   let t280 = max(min(input.min.2, 3), 0)
   let t281 = all_r._0.extent_realized.s*8
   let t282 = casted.min.0/8
   let t283 = (all_r._0.extent_realized.s + t282)*8
   let t284 = t282*8
   let t285 = max(casted.min.1, input.min.1)
   let t286 = max(t284 + 1, input.min.0)
   let t287 = t283 + 9
   let t265 = min(max(t274, t286), t287)
   let t256 = min(max(t275, t285), t273)
   let t264 = min(t286, t287)
   let t255 = min(t273, t285)
   let t263 = (t281 + 8)*casted.extent.1
   let t269 = t279 - t280
   let t270 = 3 - t279
   let t259 = (t277 + t278) + input.min.0
   for (binary_op.s0._2, 0, 24) {
    let t289 = binary_op.s0._2*t263
    let t288 = t255 - casted.min.1
    for (binary_op.s0._1.rebased, 0, t288) {
     let t290 = (max(min(t275 + -1, binary_op.s0._1.rebased + casted.min.1), input.min.1)*input.stride.1) - t259
     let t291 = ((t281 + 8)*binary_op.s0._1.rebased) + t289
     for (binary_op.s0._0.rebased, 0, t281 + 8) {
      allocate all_r$1[int32 * 1]
      produce all_r$1 {
       all_r$1[0] = 0
       let t292 = max(min((binary_op.s0._0.rebased + t284) + 2, t274) + -1, input.min.0) + t290
       for (all_r$1.s1.r118$x, 0, 3) {
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, all_r$1.s1.r118$x), input.min.2)*input.stride.2) + t292]*(((all_r$1.s1.r118$x*3) + binary_op.s0._2) + 4))
       }
      }
      consume all_r$1 {
       let t159.s = binary_op.s0._0.rebased + t291
       binary_op[t159.s] = all_r[t159.s]/all_r$1[0]
      }
      free all_r$1
     }
    }
    let t303 = binary_op.s0._2*t263
    let t304 = t264 - t284
    let t299 = max(min(t276, 3), 0)
    let t298 = ((t264 - t277) - t278) - input.min.0
    let t301 = t283 - t265
    let t297 = t265 - t264
    let t293 = t256 - t255
    let t296 = t255 - casted.min.1
    let t302 = (t265 - t284) + t303
    for (binary_op.s0._1.rebased, 0, t293) {
     let t305 = ((binary_op.s0._1.rebased + t255)*input.stride.1) - t259
     let t306 = ((binary_op.s0._1.rebased + t296)*(t281 + 8)) + t303
     for (binary_op.s0._0.rebased, 0, t304 + -1) {
      allocate all_r$1[int32 * 1]
      produce all_r$1 {
       all_r$1[0] = 0
       let t307 = max(min((binary_op.s0._0.rebased + t284) + 2, t274) + -1, input.min.0) + t305
       for (all_r$1.s1.r118$x, 0, 3) {
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, all_r$1.s1.r118$x), input.min.2)*input.stride.2) + t307]*(((all_r$1.s1.r118$x*3) + binary_op.s0._2) + 4))
       }
      }
      consume all_r$1 {
       let t160.s = binary_op.s0._0.rebased + t306
       binary_op[t160.s] = all_r[t160.s]/all_r$1[0]
      }
      free all_r$1
     }
     let t309 = ((binary_op.s0._1.rebased + t296)*(t281 + 8)) + (t303 + t304)
     let t308 = ((binary_op.s0._1.rebased + t255)*input.stride.1) + t298
     for (binary_op.s0._0.rebased, 0, t297) {
      allocate all_r$1[int32 * 1]
      produce all_r$1 {
       all_r$1[0] = 0
       let t310 = binary_op.s0._0.rebased + t308
       for (all_r$1.s1.r118$x, 0, t280) {
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, all_r$1.s1.r118$x), input.min.2)*input.stride.2) + t310]*(((all_r$1.s1.r118$x*3) + binary_op.s0._2) + 4))
       }
       let t311 = binary_op.s0._0.rebased + t308
       for (all_r$1.s1.r118$x.rebased, 0, t269) {
        let t173 = all_r$1.s1.r118$x.rebased + t280
        all_r$1[0] = all_r$1[0] + (input[(input.stride.2*t173) + t311]*(((t173*3) + binary_op.s0._2) + 4))
       }
       let t312 = binary_op.s0._0.rebased + t308
       for (all_r$1.s1.r118$x.rebased, 0, t270) {
        let t175 = all_r$1.s1.r118$x.rebased + t299
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, t175), input.min.2)*input.stride.2) + t312]*(((t175*3) + binary_op.s0._2) + 4))
       }
      }
      consume all_r$1 {
       let t161 = binary_op.s0._0.rebased + t309
       binary_op[t161 + -1] = all_r[t161 + -1]/all_r$1[0]
      }
      free all_r$1
     }
     let t313 = ((binary_op.s0._1.rebased + t255)*input.stride.1) - t259
     let t314 = ((binary_op.s0._1.rebased + t296)*(t281 + 8)) + t302
     for (binary_op.s0._0.rebased, 0, t301 + 9) {
      allocate all_r$1[int32 * 1]
      produce all_r$1 {
       all_r$1[0] = 0
       let t315 = max(min(t274 + -1, binary_op.s0._0.rebased + t265), input.min.0) + t313
       for (all_r$1.s1.r118$x, 0, 3) {
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, all_r$1.s1.r118$x), input.min.2)*input.stride.2) + t315]*(((all_r$1.s1.r118$x*3) + binary_op.s0._2) + 4))
       }
      }
      consume all_r$1 {
       let t162 = binary_op.s0._0.rebased + t314
       binary_op[t162 + -1] = all_r[t162 + -1]/all_r$1[0]
      }
      free all_r$1
     }
    }
    let t317 = binary_op.s0._2*t263
    let t316 = t273 - t256
    let t318 = t256 - casted.min.1
    for (binary_op.s0._1.rebased, 0, t316) {
     let t319 = (max(min(t275 + -1, binary_op.s0._1.rebased + t256), input.min.1)*input.stride.1) - t259
     let t320 = ((binary_op.s0._1.rebased + t318)*(t281 + 8)) + t317
     for (binary_op.s0._0.rebased, 0, t281 + 8) {
      allocate all_r$1[int32 * 1]
      produce all_r$1 {
       all_r$1[0] = 0
       let t321 = max(min((binary_op.s0._0.rebased + t284) + 2, t274) + -1, input.min.0) + t319
       for (all_r$1.s1.r118$x, 0, 3) {
        all_r$1[0] = all_r$1[0] + (input[(max(min(t276 + -1, all_r$1.s1.r118$x), input.min.2)*input.stride.2) + t321]*(((all_r$1.s1.r118$x*3) + binary_op.s0._2) + 4))
       }
      }
      consume all_r$1 {
       let t163.s = binary_op.s0._0.rebased + t320
       binary_op[t163.s] = all_r[t163.s]/all_r$1[0]
      }
      free all_r$1
     }
    }
   }
  }
 }
 free all_r
 allocate downsampled_box__0[int32 * (all_r._0.extent_realized.s + 1) * casted.extent.1 * 24]
 let downsampled_box__0.s0._0.loop_extent = (((casted.extent.0 + casted.min.0) + 7)/8) - (casted.min.0/8)
 produce downsampled_box__0 {
  consume binary_op {
   let t325 = all_r._0.extent_realized.s*8
   let t322 = (t325 + 8)*casted.extent.1
   let t324 = (all_r._0.extent_realized.s + 1)*casted.extent.1
   for (downsampled_box__0.s0._2, 0, 24) {
    let t327 = downsampled_box__0.s0._2*t324
    let t326 = downsampled_box__0.s0._2*t322
    for (downsampled_box__0.s0._1.rebased, 0, casted.extent.1) {
     let t328 = ((t325 + 8)*downsampled_box__0.s0._1.rebased) + t326
     let t329 = ((all_r._0.extent_realized.s + 1)*downsampled_box__0.s0._1.rebased) + t327
     for (downsampled_box__0.s0._0.rebased, 0, downsampled_box__0.s0._0.loop_extent) {
      let t166 = (downsampled_box__0.s0._0.rebased*8) + t328
      downsampled_box__0[downsampled_box__0.s0._0.rebased + t329] = binary_op[t166 + 1] + (binary_op[t166] + (binary_op[t166 + 2] + (binary_op[t166 + 3] + (binary_op[t166 + 4] + (binary_op[t166 + 5] + (binary_op[t166 + 7] + binary_op[t166 + 6]))))))
     }
    }
   }
  }
 }
 free binary_op
 produce casted {
  consume downsampled_box__0 {
   let t331 = (all_r._0.extent_realized.s + 1)*casted.extent.1
   let t330 = casted.min.0 % 8
   let t332 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t335 = casted.min.2 + casted.s0._2.rebased
    let t334 = (casted.stride.2*t335) + t332
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t336 = (all_r._0.extent_realized.s + 1)*casted.s0._1.rebased
     let t337 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t334
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$2[int32 * 1]
      produce all_r$2 {
       all_r$2[0] = 0
       let t338 = ((casted.s0._0.rebased + t330)/8) + t336
       for (all_r$2.s1.r237$x, 0, 24) {
        all_r$2[0] = all_r$2[0] + (downsampled_box__0[(all_r$2.s1.r237$x*t331) + t338]*(((all_r$2.s1.r237$x*24) + t335) + 25))
       }
      }
      consume all_r$2 {
       casted[casted.s0._0.rebased + t337] = all_r$2[0]
      }
      free all_r$2
     }
    }
   }
  }
 }
 free downsampled_box__0
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
add_temp_object_file: /tmp/yk0ALq/random_pipeline.a.o
Module.compile(): temporary object /tmp/yk0ALq/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50043_0/random_pipeline.a
file_unlink: /tmp/yk0ALq/random_pipeline.a.o
dir_rmdir: /tmp/yk0ALq
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50043_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50043_0/random_pipeline.registration.cpp
