Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50054_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
(let t5 = all_r$1(_0, _1, _2) in (let t6 = constant_exterior(_0, _1, _2) in ((t6 + int32((t5 == t6))) - t5)))
(let t11 = (int8)relu$1(_0, _1, _2) in (let t12 = upsampled_nn__0(_0, _1, _2) in (int32(t11)/t12)))
(let t16 = (int8)constant_exterior$1(_0, _1, _2) in (let t17 = (int8)constant_exterior$1(_0 + -1, _1, _2) in int32(select(t16 < (int8)constant_exterior$1(_0 + 1, _1, _2), t17, t17/t16))))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$4 }
Injecting realization of { all_w }
Injecting realization of { sum }
Injecting realization of { sliced$1 }
Injecting realization of { all_r$2 }
Injecting realization of { relu }
Inlining constant_exterior
Inlining repeat_edge
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required = let t347 = (input.extent.0 + input.min.0) in (max(min(casted.extent.0 + casted.min.0, t347), input.min.0 + 1) - max(min(t347 + -1, casted.min.0), input.min.0))
let input.min.0.required = max(min((input.extent.0 + input.min.0) + -1, casted.min.0), input.min.0)
let input.extent.1.required = let t348 = (input.extent.1 + input.min.1) in (max(min(casted.extent.1 + casted.min.1, t348), input.min.1 + 1) - max(min(t348 + -1, casted.min.1), input.min.1))
let input.min.1.required = max(min((input.extent.1 + input.min.1) + -1, casted.min.1), input.min.1)
let input.extent.2.required.s = let t349 = (input.extent.2 + input.min.2) in (min(t349, 3) - max(min(t349, 1) + -1, input.min.2))
let input.min.2.required = max(min(input.extent.2 + input.min.2, 1) + -1, input.min.2)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required, 0, input.min.2.required, max(input.extent.2.required.s, 1), input.extent.0.required*input.extent.1.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && ((max(input.extent.2.required.s, 1) + input.min.2.required) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, (max(input.extent.2.required.s, 1) + input.min.2.required) + -1, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 allocate relu[int8 * casted.extent.0 * casted.extent.1 * 3]
 produce relu {
  let t206 = max(min(input.min.2, 3), 0)
  let t210 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t209 = input.extent.2 + input.min.2
  let t208 = input.extent.1 + input.min.1
  let t207 = input.extent.0 + input.min.0
  for (relu.s0._2, 0, t206) {
   let t213 = t209 <= relu.s0._2
   let t212 = relu.s0._2 < input.min.2
   let t215 = (casted.extent.0*casted.extent.1)*relu.s0._2
   let t214 = (max(min(t209 + -1, relu.s0._2), input.min.2)*input.stride.2) - t210
   for (relu.s0._1.rebased, 0, casted.extent.1) {
    let t217 = (casted.extent.0*relu.s0._1.rebased) + t215
    let t216 = casted.min.1 + relu.s0._1.rebased
    for (relu.s0._0.rebased, 0, casted.extent.0) {
     let t157 = casted.min.0 + relu.s0._0.rebased
     relu[relu.s0._0.rebased + t217] = max(int8(select((((((t207 <= t157) || (t157 < input.min.0)) || (t216 < input.min.1)) || (t208 <= t216)) || t212) || t213, 7, input[max(min(t207 + -1, t157), input.min.0) + ((max(min(t208 + -1, t216), input.min.1)*input.stride.1) + t214)])), (int8)0)
    }
   }
  }
  let t232 = casted.extent.0 + casted.min.0
  let t233 = casted.extent.1 + casted.min.1
  let t234 = input.extent.0 + input.min.0
  let t235 = input.extent.1 + input.min.1
  let t236 = input.min.2*input.stride.2
  let t237 = input.min.1*input.stride.1
  let t238 = max(min(input.min.2, 3), 0)
  let t239 = max(casted.min.0, input.min.0)
  let t240 = max(casted.min.1, input.min.1)
  let t220 = min(max(t235, t240), t233)
  let t227 = min(max(t234, t239), t232)
  let t219 = min(t233, t240)
  let t226 = min(t232, t239)
  let t225 = casted.extent.0*casted.extent.1
  let t218 = max(min(input.extent.2 + input.min.2, 3), 0) - t238
  let t224 = (t236 + t237) + input.min.0
  for (relu.s0._2.rebased, 0, t218) {
   let t241 = t219 - casted.min.1
   let t242 = relu.s0._2.rebased + t238
   for (relu.s0._1.rebased, 0, t241) {
    let t244 = (input.stride.2*t242) - t224
    let t245 = (t225*t242) + (casted.extent.0*relu.s0._1.rebased)
    let t243 = casted.min.1 + relu.s0._1.rebased
    for (relu.s0._0.rebased, 0, casted.extent.0) {
     let t162 = casted.min.0 + relu.s0._0.rebased
     relu[relu.s0._0.rebased + t245] = max(int8(select((((t234 <= t162) || (t162 < input.min.0)) || (t243 < input.min.1)) || (t235 <= t243), 7, input[max(min(t234 + -1, t162), input.min.0) + ((max(min(t235 + -1, t243), input.min.1)*input.stride.1) + t244)])), (int8)0)
    }
   }
   let t251 = ((t226 - t236) - t237) - input.min.0
   let t252 = t232 - t227
   let t250 = t227 - t226
   let t247 = t226 - casted.min.0
   let t246 = t220 - t219
   let t249 = t219 - casted.min.1
   let t248 = relu.s0._2.rebased + t238
   for (relu.s0._1.rebased, 0, t246) {
    let t254 = ((relu.s0._1.rebased + t219)*input.stride.1) + ((input.stride.2*t248) - t224)
    let t255 = (t225*t248) + ((relu.s0._1.rebased + t249)*casted.extent.0)
    for (relu.s0._0.rebased, 0, t247) {
     let t167 = casted.min.0 + relu.s0._0.rebased
     relu[relu.s0._0.rebased + t255] = max(int8(select((t234 <= t167) || (t167 < input.min.0), 7, input[max(min(t234 + -1, t167), input.min.0) + t254])), (int8)0)
    }
    let t257 = ((relu.s0._1.rebased + t249)*casted.extent.0) + ((t225*t248) + t247)
    let t256 = ((relu.s0._1.rebased + t219)*input.stride.1) + ((input.stride.2*t248) + t251)
    for (relu.s0._0.rebased, 0, t250) {
     relu[relu.s0._0.rebased + t257] = max(int8(input[relu.s0._0.rebased + t256]), (int8)0)
    }
    let t259 = ((relu.s0._1.rebased + t249)*casted.extent.0) + ((t225*t248) + (t227 - casted.min.0))
    let t258 = ((relu.s0._1.rebased + t219)*input.stride.1) + ((input.stride.2*t248) - t224)
    for (relu.s0._0.rebased, 0, t252) {
     let t170 = relu.s0._0.rebased + t227
     relu[relu.s0._0.rebased + t259] = max(int8(select(t170 < t234, input[max(min(t234 + -1, t170), input.min.0) + t258], 7)), (int8)0)
    }
   }
   let t260 = t233 - t220
   let t262 = t220 - casted.min.1
   let t261 = relu.s0._2.rebased + t238
   for (relu.s0._1.rebased, 0, t260) {
    let t264 = (input.stride.2*t261) - t224
    let t265 = (t225*t261) + ((relu.s0._1.rebased + t262)*casted.extent.0)
    let t263 = relu.s0._1.rebased + t220
    for (relu.s0._0.rebased, 0, casted.extent.0) {
     let t174 = casted.min.0 + relu.s0._0.rebased
     relu[relu.s0._0.rebased + t265] = max(int8(select(((t234 <= t174) || (t174 < input.min.0)) || (t235 <= t263), 7, input[max(min(t234 + -1, t174), input.min.0) + ((max(min(t235 + -1, t263), input.min.1)*input.stride.1) + t264)])), (int8)0)
    }
   }
  }
  let t272 = input.extent.2 + input.min.2
  let t266 = 3 - max(min(t272, 3), 0)
  let t270 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t268 = input.extent.1 + input.min.1
  let t267 = input.extent.0 + input.min.0
  for (relu.s0._2.rebased, 0, t266) {
   let t273 = max(min(t272, 3), 0) + relu.s0._2.rebased
   for (relu.s0._1.rebased, 0, casted.extent.1) {
    let t276 = t272 <= t273
    let t277 = (max(min(t272 + -1, t273), input.min.2)*input.stride.2) - t270
    let t278 = ((casted.extent.0*casted.extent.1)*t273) + (casted.extent.0*relu.s0._1.rebased)
    let t275 = casted.min.1 + relu.s0._1.rebased
    for (relu.s0._0.rebased, 0, casted.extent.0) {
     let t179 = casted.min.0 + relu.s0._0.rebased
     relu[relu.s0._0.rebased + t278] = max(int8(select(((((t267 <= t179) || (t179 < input.min.0)) || (t275 < input.min.1)) || (t268 <= t275)) || t276, 7, input[max(min(t267 + -1, t179), input.min.0) + ((max(min(t268 + -1, t275), input.min.1)*input.stride.1) + t277)])), (int8)0)
    }
   }
  }
 }
 allocate sliced$1[int32 * casted.extent.0 * casted.extent.1 * 1]
 produce sliced$1 {
  consume relu {
   let sliced$1.s0._1.prologue = min(max(casted.min.1, input.min.1), casted.extent.1 + casted.min.1)
   let sliced$1.s0._1.epilogue = min(max(max(casted.min.1, input.min.1), input.extent.1 + input.min.1), casted.extent.1 + casted.min.1)
   let t280 = casted.extent.0*casted.extent.1
   let t279 = sliced$1.s0._1.prologue - casted.min.1
   let t283 = input.extent.2 + input.min.2
   let t282 = input.extent.1 + input.min.1
   let t281 = input.extent.0 + input.min.0
   for (sliced$1.s0._1.rebased, 0, t279) {
    let t286 = casted.extent.0*sliced$1.s0._1.rebased
    let t287 = casted.min.1 + sliced$1.s0._1.rebased
    for (sliced$1.s0._0.rebased, 0, casted.extent.0) {
     allocate all_r$2[int32 * 1]
     produce all_r$2 {
      all_r$2[0] = 0
      let t290 = sliced$1.s0._0.rebased + t286
      for (all_r$2.s1.r137$x, 0, 3) {
       all_r$2[0] = all_r$2[0] + (((all_r$2.s1.r137$x*3) + 4)*int32(relu[(all_r$2.s1.r137$x*t280) + t290]))
      }
     }
     consume all_r$2 {
      let t139.s = all_r$2[0]
      let t185 = casted.min.0 + sliced$1.s0._0.rebased
      let t188 = max(min(t139.s, 2), 0)
      sliced$1[sliced$1.s0._0.rebased + t286] = select((((((t281 <= t185) || (t185 < input.min.0)) || (t287 < input.min.1)) || (t282 <= t287)) || (t188 < input.min.2)) || (t283 <= t188), 7, input[max(min(t281 + -1, t185), input.min.0) + ((max(min(t282 + -1, t287), input.min.1)*input.stride.1) + (((max(min(t283 + -1, t188) - input.min.2, 0)*input.stride.2) - (input.min.1*input.stride.1)) - input.min.0))])
     }
     free all_r$2
    }
   }
   let t301 = casted.extent.0 + casted.min.0
   let t302 = input.extent.0 + input.min.0
   let t303 = max(casted.min.0, input.min.0)
   let t293 = min(max(t302, t303), t301)
   let t292 = min(t301, t303)
   let t299 = input.min.1*input.stride.1
   let t295 = casted.extent.0*casted.extent.1
   let t294 = sliced$1.s0._1.prologue - casted.min.1
   let t291 = sliced$1.s0._1.epilogue - sliced$1.s0._1.prologue
   let t297 = input.extent.2 + input.min.2
   for (sliced$1.s0._1.rebased, 0, t291) {
    let t305 = (sliced$1.s0._1.rebased + t294)*casted.extent.0
    let t307 = (sliced$1.s0._1.prologue + sliced$1.s0._1.rebased)*input.stride.1
    let t304 = t292 - casted.min.0
    for (sliced$1.s0._0.rebased, 0, t304) {
     allocate all_r$2[int32 * 1]
     produce all_r$2 {
      all_r$2[0] = 0
      let t308 = sliced$1.s0._0.rebased + t305
      for (all_r$2.s1.r137$x, 0, 3) {
       all_r$2[0] = all_r$2[0] + (((all_r$2.s1.r137$x*3) + 4)*int32(relu[(all_r$2.s1.r137$x*t295) + t308]))
      }
     }
     consume all_r$2 {
      let t142.s = all_r$2[0]
      let t191 = casted.min.0 + sliced$1.s0._0.rebased
      let t192 = max(min(t142.s, 2), 0)
      sliced$1[sliced$1.s0._0.rebased + t305] = select((((t302 <= t191) || (t191 < input.min.0)) || (t192 < input.min.2)) || (t297 <= t192), 7, input[max(min(t302 + -1, t191), input.min.0) + ((((max(min(t297 + -1, t192) - input.min.2, 0)*input.stride.2) - t299) - input.min.0) + t307)])
     }
     free all_r$2
    }
    let t312 = (sliced$1.s0._1.prologue + sliced$1.s0._1.rebased)*input.stride.1
    let t309 = t293 - t292
    let t310 = ((sliced$1.s0._1.rebased + t294)*casted.extent.0) + (t292 - casted.min.0)
    for (sliced$1.s0._0.rebased, 0, t309) {
     allocate all_r$2[int32 * 1]
     produce all_r$2 {
      all_r$2[0] = 0
      let t313 = sliced$1.s0._0.rebased + t310
      for (all_r$2.s1.r137$x, 0, 3) {
       all_r$2[0] = all_r$2[0] + (((all_r$2.s1.r137$x*3) + 4)*int32(relu[(all_r$2.s1.r137$x*t295) + t313]))
      }
     }
     consume all_r$2 {
      let t145.s = all_r$2[0]
      let t195 = max(min(t145.s, 2), 0)
      sliced$1[sliced$1.s0._0.rebased + t310] = select((t297 <= t195) || (t195 < input.min.2), 7, input[(((((max(min(t297 + -1, t195) - input.min.2, 0)*input.stride.2) + t292) - t299) - input.min.0) + t312) + sliced$1.s0._0.rebased])
     }
     free all_r$2
    }
    let t317 = (sliced$1.s0._1.prologue + sliced$1.s0._1.rebased)*input.stride.1
    let t314 = t301 - t293
    let t315 = ((sliced$1.s0._1.rebased + t294)*casted.extent.0) + (t293 - casted.min.0)
    for (sliced$1.s0._0.rebased, 0, t314) {
     allocate all_r$2[int32 * 1]
     produce all_r$2 {
      all_r$2[0] = 0
      let t318 = sliced$1.s0._0.rebased + t315
      for (all_r$2.s1.r137$x, 0, 3) {
       all_r$2[0] = all_r$2[0] + (((all_r$2.s1.r137$x*3) + 4)*int32(relu[(all_r$2.s1.r137$x*t295) + t318]))
      }
     }
     consume all_r$2 {
      let t147.s = all_r$2[0]
      let t197 = sliced$1.s0._0.rebased + t293
      let t198 = max(min(t147.s, 2), 0)
      sliced$1[sliced$1.s0._0.rebased + t315] = select(((t302 <= t197) || (t198 < input.min.2)) || (t297 <= t198), 7, input[max(min(t302 + -1, t197), input.min.0) + ((((max(min(t297 + -1, t198) - input.min.2, 0)*input.stride.2) - t299) - input.min.0) + t317)])
     }
     free all_r$2
    }
   }
   let t321 = casted.extent.0*casted.extent.1
   let t319 = (casted.extent.1 + casted.min.1) - sliced$1.s0._1.epilogue
   let t320 = sliced$1.s0._1.epilogue - casted.min.1
   let t324 = input.extent.2 + input.min.2
   let t323 = input.extent.1 + input.min.1
   let t322 = input.extent.0 + input.min.0
   for (sliced$1.s0._1.rebased, 0, t319) {
    let t327 = (sliced$1.s0._1.rebased + t320)*casted.extent.0
    let t328 = sliced$1.s0._1.epilogue + sliced$1.s0._1.rebased
    for (sliced$1.s0._0.rebased, 0, casted.extent.0) {
     allocate all_r$2[int32 * 1]
     produce all_r$2 {
      all_r$2[0] = 0
      let t331 = sliced$1.s0._0.rebased + t327
      for (all_r$2.s1.r137$x, 0, 3) {
       all_r$2[0] = all_r$2[0] + (((all_r$2.s1.r137$x*3) + 4)*int32(relu[(all_r$2.s1.r137$x*t321) + t331]))
      }
     }
     consume all_r$2 {
      let t151.s = all_r$2[0]
      let t201 = casted.min.0 + sliced$1.s0._0.rebased
      let t204 = max(min(t151.s, 2), 0)
      sliced$1[sliced$1.s0._0.rebased + t327] = select(((((t322 <= t201) || (t201 < input.min.0)) || (t323 <= t328)) || (t204 < input.min.2)) || (t324 <= t204), 7, input[max(min(t322 + -1, t201), input.min.0) + ((max(min(t323 + -1, t328), input.min.1)*input.stride.1) + (((max(min(t324 + -1, t204) - input.min.2, 0)*input.stride.2) - (input.min.1*input.stride.1)) - input.min.0))])
     }
     free all_r$2
    }
   }
   free relu
  }
 }
 allocate all_w[int32 * casted.extent.0 * casted.extent.1 * 20]
 produce all_w {
  consume sliced$1 {
   for (all_w.s0._2, 0, 20) {
    let t333 = (casted.extent.0*casted.extent.1)*all_w.s0._2
    for (all_w.s0._1.rebased, 0, casted.extent.1) {
     let t336 = all_w.s0._1.rebased*casted.extent.0
     let t335 = t333 + t336
     for (all_w.s0._0.rebased, 0, casted.extent.0) {
      allocate sum[int32 * 1]
      produce sum {
       sum[0] = 0
       sum[0] = sum[0] + (sliced$1[all_w.s0._0.rebased + t336]*(all_w.s0._2 + 2))
      }
      consume sum {
       all_w[all_w.s0._0.rebased + t335] = sum[0]
      }
      free sum
     }
    }
   }
  }
 }
 free sliced$1
 produce casted {
  consume all_w {
   let t338 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t342 = casted.min.2 + casted.s0._2.rebased
    let t341 = (casted.stride.2*t342) + t338
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t343 = casted.extent.0*casted.s0._1.rebased
     let t344 = casted.extent.0*casted.extent.1
     let t345 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t341
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       let t346 = casted.s0._0.rebased + t343
       for (all_r$4.s1.r222$x, 0, 20) {
        all_r$4[0] = all_r$4[0] + (all_w[(all_r$4.s1.r222$x*t344) + t346]*(((all_r$4.s1.r222$x*20) + t342) + 21))
       }
      }
      consume all_r$4 {
       casted[casted.s0._0.rebased + t345] = all_r$4[0]
      }
      free all_r$4
     }
    }
   }
  }
 }
 free all_w
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
add_temp_object_file: /tmp/FX8qNi/random_pipeline.a.o
Module.compile(): temporary object /tmp/FX8qNi/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50054_0/random_pipeline.a
file_unlink: /tmp/FX8qNi/random_pipeline.a.o
dir_rmdir: /tmp/FX8qNi
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50054_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50054_0/random_pipeline.registration.cpp
