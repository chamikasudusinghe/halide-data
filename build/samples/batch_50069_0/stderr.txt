Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50069_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
In random expression: (uint1)1
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 1, _1, _2)
all_w(_0 + 2, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: max(all_w(_0, _1, _2), all_w(_0 + 2, _1, _2))
The following expressions were unused:
all_w(_0 + 1, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: (all_w(_0 + 3, _1, _2) + all_w(_0 + 2, _1, _2))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 1, _1, _2)
In random expression: max(all_w(_0, _1, _2), all_w(_0 + 2, _1, _2))
The following expressions were unused:
all_w(_0 + 1, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: (all_w(_0, _1, _2)/all_w(_0 + 3, _1, _2))
The following expressions were unused:
all_w(_0 + 1, _1, _2)
all_w(_0 + 2, _1, _2)
In random expression: (let t8 = all_w(_0 + 3, _1, _2) in (t8*t8))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 1, _1, _2)
all_w(_0 + 2, _1, _2)
In random expression: (all_w(_0 + 1, _1, _2) % all_w(_0 + 2, _1, _2))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: max(all_w(_0 + 2, _1, _2), all_w(_0 + 1, _1, _2))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: int8(min(all_w(_0 + 2, _1, _2), all_w(_0 + 1, _1, _2)))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 3, _1, _2)
In random expression: max(all_w(_0 + 2, _1, _2), all_w(_0 + 1, _1, _2))
The following expressions were unused:
all_w(_0, _1, _2)
all_w(_0 + 3, _1, _2)
((((0 + all_w(_0, _1, _2)) + all_w(_0 + 1, _1, _2)) + all_w(_0 + 2, _1, _2)) + all_w(_0 + 3, _1, _2))
(let t19 = conv__0(_0, _1, _2) in (let t20 = all_r$1(_0, _1, _2) in max(max(t19, int32(uint8(max(t19, t20)))), t20)))
(let t31 = binary_op(_0, _1, _2) in (let t32 = all_r$2(_0, _1, _2) in (let t33 = max(t31, t32) in select((t32/t31) < t33, select(t31 == 0, 0, 1) % t31, t33))))
(let t42 = conv2D_r__0_1(_0, _1, _2) in (let t43 = upsampled_linear__1(_0, _1, _2) in (((t42*t43)*2) - select(t43 == 0, 0, 1))))
In random expression: (conv2D_r__0_1(_0 + 1, _1, _2) - conv2D_r__0_1(_0, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0 + 2, _1, _2)
conv2D_r__0_1(_0 + 3, _1, _2)
In random expression: (let t49 = conv2D_r__0_1(_0 + 3, _1, _2) in select(t49 == 0, 0, 1))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 1, _1, _2)
conv2D_r__0_1(_0 + 2, _1, _2)
In random expression: (let t50 = conv2D_r__0_1(_0 + 2, _1, _2) in select(t50 == 0, 0, 1))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 1, _1, _2)
conv2D_r__0_1(_0 + 3, _1, _2)
In random expression: (conv2D_r__0_1(_0 + 3, _1, _2) % conv2D_r__0_1(_0 + 1, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 2, _1, _2)
In random expression: min(conv2D_r__0_1(_0 + 3, _1, _2), conv2D_r__0_1(_0 + 1, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 2, _1, _2)
In random expression: (conv2D_r__0_1(_0 + 2, _1, _2) - conv2D_r__0_1(_0 + 1, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 3, _1, _2)
In random expression: (conv2D_r__0_1(_0, _1, _2) != conv2D_r__0_1(_0 + 3, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0 + 1, _1, _2)
conv2D_r__0_1(_0 + 2, _1, _2)
In random expression: (conv2D_r__0_1(_0, _1, _2)/conv2D_r__0_1(_0 + 2, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0 + 1, _1, _2)
conv2D_r__0_1(_0 + 3, _1, _2)
In random expression: (let t51 = conv2D_r__0_1(_0 + 2, _1, _2) in select(conv2D_r__0_1(_0 + 1, _1, _2) == t51, t51, conv2D_r__0_1(_0 + 3, _1, _2)))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
In random expression: (conv2D_r__0_1(_0 + 3, _1, _2) <= conv2D_r__0_1(_0 + 2, _1, _2))
The following expressions were unused:
conv2D_r__0_1(_0, _1, _2)
conv2D_r__0_1(_0 + 1, _1, _2)
((((0 + conv2D_r__0_1(_0, _1, _2)) + conv2D_r__0_1(_0 + 1, _1, _2)) + conv2D_r__0_1(_0 + 2, _1, _2)) + conv2D_r__0_1(_0 + 3, _1, _2))
In random expression: (let t52 = conv__0$1(_0 + 1, _1, _2) in t52)
The following expressions were unused:
conv__0$1(_0, _1, _2)
conv__0$1(_0 + -1, _1, _2)
In random expression: (let t53 = conv__0$1(_0 + -1, _1, _2) in ((t53*t53)/t53))
The following expressions were unused:
conv__0$1(_0, _1, _2)
conv__0$1(_0 + 1, _1, _2)
In random expression: (let t54 = conv__0$1(_0 + 1, _1, _2) in uint8((min(conv__0$1(_0, _1, _2), t54)/t54)))
The following expressions were unused:
conv__0$1(_0 + -1, _1, _2)
In random expression: 0
The following expressions were unused:
conv__0$1(_0, _1, _2)
conv__0$1(_0 + -1, _1, _2)
conv__0$1(_0 + 1, _1, _2)
((conv__0$1(_0 + -1, _1, _2)*conv__0$1(_0, _1, _2))/conv__0$1(_0 + 1, _1, _2))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Inlining upsampled_linear__1$1
Inlining upsampled_linear__0
Injecting realization of { all_r$7 }
Injecting realization of { pool2D_r__0_1 }
Injecting realization of { conv2D_r__0_1 }
Injecting realization of { upsampled_nn__1 }
Injecting realization of { relu }
Injecting realization of { all_w }
Injecting realization of { sum }
Inlining repeat_image
Inlining lambda_0
Inlining input_im
Inlining repeat_edge$3
Inlining lambda_4
Inlining int8_weights_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)int8_weights.buffer) != (uint64)0, halide_error_buffer_argument_is_null("int8_weights"))
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let int8_weights = (void *)_halide_buffer_get_host((struct halide_buffer_t *)int8_weights.buffer)
let int8_weights.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)int8_weights.buffer)
let int8_weights.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)int8_weights.buffer)
let int8_weights.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)int8_weights.buffer)
let int8_weights.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)int8_weights.buffer, 0)
let int8_weights.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)int8_weights.buffer, 0)
let int8_weights.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)int8_weights.buffer, 0)
let int8_weights.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)int8_weights.buffer, 1)
let int8_weights.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)int8_weights.buffer, 1)
let int8_weights.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)int8_weights.buffer, 1)
let int8_weights.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)int8_weights.buffer, 2)
let int8_weights.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)int8_weights.buffer, 2)
let int8_weights.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)int8_weights.buffer, 2)
let int8_weights.min.3 = _halide_buffer_get_min((struct halide_buffer_t *)int8_weights.buffer, 3)
let int8_weights.extent.3 = _halide_buffer_get_extent((struct halide_buffer_t *)int8_weights.buffer, 3)
let int8_weights.stride.3 = _halide_buffer_get_stride((struct halide_buffer_t *)int8_weights.buffer, 3)
let input.extent.0.required.s = let t742 = (input.extent.0 + input.min.0) in (let t743 = (casted.extent.0 + casted.min.0) in (let t744 = (((t742 + 6) <= ((casted.min.0/8)*8)) || ((((t743 + 7)/8)*8) < (input.min.0 + -9))) in (let t745 = (input.min.0 + max(-1 - input.extent.0, max(input.extent.0, 1) + -1)) in (let t746 = max(min((((t743 + 7)/8)*8) + 10, t742) + -1, input.min.0) in (let t747 = (((t742 + -9) <= (((t743 + 7)/8)*8)) || (((casted.min.0/8)*8) < (input.min.0 + 6))) in (let t748 = max(min((casted.min.0/8)*8, t742 + 5) + -6, input.min.0) in (max(select(t744, t745, t746), select(t747, t745, t746)) - min(select(t744, input.min.0, t748), select(t747, input.min.0, t748)))))))))
let input.min.0.required = let t749 = (input.extent.0 + input.min.0) in (let t750 = (casted.extent.0 + casted.min.0) in (let t751 = max(min((casted.min.0/8)*8, t749 + 5) + -6, input.min.0) in min(select(((t749 + 6) <= ((casted.min.0/8)*8)) || ((((t750 + 7)/8)*8) < (input.min.0 + -9)), input.min.0, t751), select(((t749 + -9) <= (((t750 + 7)/8)*8)) || (((casted.min.0/8)*8) < (input.min.0 + 6)), input.min.0, t751))))
let input.extent.1.required.s = let t752 = (input.extent.1 + input.min.1) in (let t753 = (casted.extent.1 + casted.min.1) in (let t754 = (((t752 + 3) <= ((casted.min.1/4)*4)) || ((((t753 + 3)/4)*4) < (input.min.1 + -4))) in (let t755 = (input.min.1 + max(-1 - input.extent.1, max(input.extent.1, 1) + -1)) in (let t756 = max(min((((t753 + 3)/4)*4) + 5, t752) + -1, input.min.1) in (let t757 = (((t752 + -4) <= (((t753 + 3)/4)*4)) || (((casted.min.1/4)*4) < (input.min.1 + 3))) in (let t758 = max(min((casted.min.1/4)*4, t752 + 2) + -3, input.min.1) in (max(select(t754, t755, t756), select(t757, t755, t756)) - min(select(t754, input.min.1, t758), select(t757, input.min.1, t758)))))))))
let input.min.1.required = let t759 = (input.extent.1 + input.min.1) in (let t760 = (casted.extent.1 + casted.min.1) in (let t761 = max(min((casted.min.1/4)*4, t759 + 2) + -3, input.min.1) in min(select(((t759 + 3) <= ((casted.min.1/4)*4)) || ((((t760 + 3)/4)*4) < (input.min.1 + -4)), input.min.1, t761), select(((t759 + -4) <= (((t760 + 3)/4)*4)) || (((casted.min.1/4)*4) < (input.min.1 + 3)), input.min.1, t761))))
let input.extent.2.required.s = let t762 = (input.extent.2 + input.min.2) in (let t763 = ((t762 <= 0) || (2 < input.min.2)) in (let t764 = (input.min.2 + max(-1 - input.extent.2, max(input.extent.2, 1) + -1)) in (let t765 = max(min(t762, 3) + -1, input.min.2) in (let t766 = ((t762 <= 2) || (0 < input.min.2)) in (let t767 = max(min(t762, 1) + -1, input.min.2) in (max(select(t763, t764, t765), select(t766, t764, t765)) - min(select(t763, input.min.2, t767), select(t766, input.min.2, t767))))))))
let input.min.2.required = let t768 = (input.extent.2 + input.min.2) in (let t769 = max(min(t768, 1) + -1, input.min.2) in min(select((t768 <= 0) || (2 < input.min.2), input.min.2, t769), select((t768 <= 2) || (0 < input.min.2), input.min.2, t769)))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
let int8_weights.extent.0.required.s = let t770 = (int8_weights.extent.0 + int8_weights.min.0) in (min(t770, 19) - max(min(t770, 1) + -1, int8_weights.min.0))
let int8_weights.min.0.required = max(min(int8_weights.extent.0 + int8_weights.min.0, 1) + -1, int8_weights.min.0)
let int8_weights.extent.1.required.s = let t771 = (int8_weights.extent.1 + int8_weights.min.1) in (min(t771, 5) - max(min(t771, 0) + -1, int8_weights.min.1))
let int8_weights.min.1.required = max(min(int8_weights.extent.1 + int8_weights.min.1, 0) + -1, int8_weights.min.1)
let int8_weights.extent.2.required.s = let t772 = (int8_weights.extent.2 + int8_weights.min.2) in (min(t772, 5) - max(min(t772, 0) + -1, int8_weights.min.2))
let int8_weights.min.2.required = max(min(int8_weights.extent.2 + int8_weights.min.2, 0) + -1, int8_weights.min.2)
let int8_weights.stride.2.required = max(int8_weights.extent.0.required.s, 1)*max(int8_weights.extent.1.required.s, 1)
let int8_weights.extent.3.required.s = let t773 = (int8_weights.extent.3 + int8_weights.min.3) in (min(t773, 10) - max(min(t773, 1) + -1, int8_weights.min.3))
let int8_weights.min.3.required = max(min(int8_weights.extent.3 + int8_weights.min.3, 1) + -1, int8_weights.min.3)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int8_weights.buffer)) {
 let t774 = max(int8_weights.extent.0.required.s, 1) in (let t775 = max(int8_weights.extent.2.required.s, 1) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)int8_weights.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)int8_weights.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 8, 4, (struct halide_dimension_t *)make_struct(int8_weights.min.0.required, t774, 1, 0, int8_weights.min.1.required, max(int8_weights.extent.1.required.s, 1), t774, 0, int8_weights.min.2.required, t775, int8_weights.stride.2.required, 0, int8_weights.min.3.required, max(int8_weights.extent.3.required.s, 1), t775*int8_weights.stride.2.required, 0), (uint64)0))
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int8_weights.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(int8_weights.type == (uint32)67584, halide_error_bad_type("Input buffer int8_weights", int8_weights.type, (uint32)67584))
 assert(int8_weights.dimensions == 4, halide_error_bad_dimensions("Input buffer int8_weights", int8_weights.dimensions, 4))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((int8_weights.min.0 <= int8_weights.min.0.required) && ((max(int8_weights.extent.0.required.s, 1) + int8_weights.min.0.required) <= (int8_weights.extent.0 + int8_weights.min.0)), halide_error_access_out_of_bounds("Input buffer int8_weights", 0, int8_weights.min.0.required, (max(int8_weights.extent.0.required.s, 1) + int8_weights.min.0.required) + -1, int8_weights.min.0, (int8_weights.extent.0 + int8_weights.min.0) + -1))
 assert(0 <= int8_weights.extent.0, halide_error_buffer_extents_negative("Input buffer int8_weights", 0, int8_weights.extent.0))
 assert((int8_weights.min.1 <= int8_weights.min.1.required) && ((max(int8_weights.extent.1.required.s, 1) + int8_weights.min.1.required) <= (int8_weights.extent.1 + int8_weights.min.1)), halide_error_access_out_of_bounds("Input buffer int8_weights", 1, int8_weights.min.1.required, (max(int8_weights.extent.1.required.s, 1) + int8_weights.min.1.required) + -1, int8_weights.min.1, (int8_weights.extent.1 + int8_weights.min.1) + -1))
 assert(0 <= int8_weights.extent.1, halide_error_buffer_extents_negative("Input buffer int8_weights", 1, int8_weights.extent.1))
 assert((int8_weights.min.2 <= int8_weights.min.2.required) && ((max(int8_weights.extent.2.required.s, 1) + int8_weights.min.2.required) <= (int8_weights.extent.2 + int8_weights.min.2)), halide_error_access_out_of_bounds("Input buffer int8_weights", 2, int8_weights.min.2.required, (max(int8_weights.extent.2.required.s, 1) + int8_weights.min.2.required) + -1, int8_weights.min.2, (int8_weights.extent.2 + int8_weights.min.2) + -1))
 assert(0 <= int8_weights.extent.2, halide_error_buffer_extents_negative("Input buffer int8_weights", 2, int8_weights.extent.2))
 assert((int8_weights.min.3 <= int8_weights.min.3.required) && ((max(int8_weights.extent.3.required.s, 1) + int8_weights.min.3.required) <= (int8_weights.extent.3 + int8_weights.min.3)), halide_error_access_out_of_bounds("Input buffer int8_weights", 3, int8_weights.min.3.required, (max(int8_weights.extent.3.required.s, 1) + int8_weights.min.3.required) + -1, int8_weights.min.3, (int8_weights.extent.3 + int8_weights.min.3) + -1))
 assert(0 <= int8_weights.extent.3, halide_error_buffer_extents_negative("Input buffer int8_weights", 3, int8_weights.extent.3))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(int8_weights.stride.0 == 1, halide_error_constraint_violated("int8_weights.stride.0", int8_weights.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let int8_weights.total_extent.1 = int64(int8_weights.extent.1)*int64(int8_weights.extent.0)
 let int8_weights.total_extent.2 = int8_weights.total_extent.1*int64(int8_weights.extent.2)
 let int8_weights.total_extent.3 = int8_weights.total_extent.2*int64(int8_weights.extent.3)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(uint64(int8_weights.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int8_weights", uint64(int8_weights.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(int8_weights.extent.1)*int64(int8_weights.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int8_weights", (uint64)abs(int64(int8_weights.extent.1)*int64(int8_weights.stride.1)), (uint64)2147483647))
 assert(int8_weights.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("int8_weights", int8_weights.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(int8_weights.extent.2)*int64(int8_weights.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int8_weights", (uint64)abs(int64(int8_weights.extent.2)*int64(int8_weights.stride.2)), (uint64)2147483647))
 assert(int8_weights.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("int8_weights", int8_weights.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(int8_weights.extent.3)*int64(int8_weights.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int8_weights", (uint64)abs(int64(int8_weights.extent.3)*int64(int8_weights.stride.3)), (uint64)2147483647))
 assert(int8_weights.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("int8_weights", int8_weights.total_extent.3, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!int8_weights.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer int8_weights"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(int8_weights != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer int8_weights"))
 let all_w._1.extent_realized.s = (((casted.extent.1 + casted.min.1) + 3)/4) - (casted.min.1/4)
 let all_w._0.extent_realized.s = (((casted.extent.0 + casted.min.0) + 7)/8) - (casted.min.0/8)
 let all_w.stride.2 = ((all_w._0.extent_realized.s*8) + 16)*((all_w._1.extent_realized.s*4) + 8)
 allocate all_w[int32 * ((all_w._0.extent_realized.s*8) + 16) * ((all_w._1.extent_realized.s*4) + 8) * 19]
 produce all_w {
  let t514 = input.extent.0 + input.min.0
  let t515 = input.extent.1 + input.min.1
  let t516 = input.extent.2 + input.min.2
  let t517 = input.min.2*input.stride.2
  let t518 = input.min.1*input.stride.1
  let t519 = max(min(t516, 3), 0)
  let t520 = casted.min.0/8
  let t521 = t520*8
  let t522 = casted.min.1/4
  let t523 = t522*4
  let t524 = max(min(input.min.2, 3), 0)
  let t525 = (all_w._0.extent_realized.s + t520)*8
  let t526 = (all_w._1.extent_realized.s + t522)*4
  let t527 = max(t521 + -6, input.min.0)
  let t528 = t525 + 10
  let t529 = max(t523 + -3, input.min.1)
  let t530 = t526 + 5
  let t495 = min(max(t515, t529), t530)
  let t506 = min(max(t514, t527), t528)
  let t494 = min(t529, t530)
  let t505 = min(t527, t528)
  let t497 = all_w._0.extent_realized.s*8
  let t510 = t519 - t524
  let t511 = 3 - t519
  let t503 = (t517 + t518) + input.min.0
  for (all_w.s0._2, 0, 19) {
   let t534 = all_w.s0._2*all_w.stride.2
   let t531 = t494 - t523
   for (all_w.s0._1.rebased, 0, t531 + 3) {
    let t538 = ((t497 + 16)*all_w.s0._1.rebased) + t534
    let t536 = ((((t523 - input.min.1) + all_w.s0._1.rebased) + -3) % input.extent.1) + input.min.1
    let t535 = all_w.s0._1.rebased + t523
    for (all_w.s0._0.rebased, 0, t497 + 16) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t540 = (select(((t515 + 3) <= t535) || (t535 < (input.min.1 + 3)), t536, max(min(t515 + 2, t535) + -3, input.min.1))*input.stride.1) - t503
      let t541 = ((((t521 - input.min.0) + all_w.s0._0.rebased) + -6) % input.extent.0) + input.min.0
      let t539 = all_w.s0._0.rebased + t521
      for (sum.s1.r85$x, 0, 3) {
       sum[0] = sum[0] + (input[(select((t516 <= sum.s1.r85$x) || (sum.s1.r85$x < input.min.2), ((sum.s1.r85$x - input.min.2) % input.extent.2) + input.min.2, max(min(t516 + -1, sum.s1.r85$x), input.min.2))*input.stride.2) + (select(((t514 + 6) <= t539) || (t539 < (input.min.0 + 6)), t541, max(min(t514 + 5, t539) + -6, input.min.0)) + t540)]*(((sum.s1.r85$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t538] = sum[0]
     }
     free sum
    }
   }
   let t554 = all_w.s0._2*all_w.stride.2
   let t555 = t505 - t521
   let t549 = max(min(t516, 3), 0)
   let t548 = ((t505 - t517) - t518) - input.min.0
   let t551 = t525 - t506
   let t547 = t506 - t505
   let t542 = t495 - t494
   let t546 = t494 - t523
   let t553 = (t506 - t521) + t554
   for (all_w.s0._1.rebased, 0, t542) {
    let t556 = ((all_w.s0._1.rebased + t494)*input.stride.1) - t503
    let t558 = (((all_w.s0._1.rebased + t546) + 3)*(t497 + 16)) + t554
    for (all_w.s0._0.rebased, 0, t555 + 6) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t560 = ((((t521 - input.min.0) + all_w.s0._0.rebased) + -6) % input.extent.0) + input.min.0
      let t559 = all_w.s0._0.rebased + t521
      for (sum.s1.r85$x, 0, 3) {
       sum[0] = sum[0] + (input[(select((t516 <= sum.s1.r85$x) || (sum.s1.r85$x < input.min.2), ((sum.s1.r85$x - input.min.2) % input.extent.2) + input.min.2, max(min(t516 + -1, sum.s1.r85$x), input.min.2))*input.stride.2) + (select(((t514 + 6) <= t559) || (t559 < (input.min.0 + 6)), t560, max(min(t514 + 5, t559) + -6, input.min.0)) + t556)]*(((sum.s1.r85$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t558] = sum[0]
     }
     free sum
    }
    let t563 = (((all_w.s0._1.rebased + t546) + 3)*(t497 + 16)) + (t554 + t555)
    let t561 = ((all_w.s0._1.rebased + t494)*input.stride.1) + t548
    for (all_w.s0._0.rebased, 0, t547) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t564 = all_w.s0._0.rebased + t561
      for (sum.s1.r85$x, 0, t524) {
       sum[0] = sum[0] + (input[(select((t516 <= sum.s1.r85$x) || (sum.s1.r85$x < input.min.2), ((sum.s1.r85$x - input.min.2) % input.extent.2) + input.min.2, max(min(t516 + -1, sum.s1.r85$x), input.min.2))*input.stride.2) + t564]*(((sum.s1.r85$x*3) + all_w.s0._2) + 4))
      }
      let t565 = all_w.s0._0.rebased + t561
      for (sum.s1.r85$x.rebased, 0, t510) {
       let t461 = sum.s1.r85$x.rebased + t524
       sum[0] = sum[0] + (input[(input.stride.2*t461) + t565]*(((t461*3) + all_w.s0._2) + 4))
      }
      let t566 = all_w.s0._0.rebased + t561
      for (sum.s1.r85$x.rebased, 0, t511) {
       let t464 = sum.s1.r85$x.rebased + t549
       sum[0] = sum[0] + (input[(select(t464 < t516, max(min(t516 + -1, t464), input.min.2), (((t549 - input.min.2) + sum.s1.r85$x.rebased) % input.extent.2) + input.min.2)*input.stride.2) + t566]*(((t464*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[(all_w.s0._0.rebased + t563) + 6] = sum[0]
     }
     free sum
    }
    let t568 = ((all_w.s0._1.rebased + t494)*input.stride.1) - t503
    let t570 = (((all_w.s0._1.rebased + t546) + 3)*(t497 + 16)) + t553
    for (all_w.s0._0.rebased, 0, t551 + 10) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t572 = (((t506 - input.min.0) + all_w.s0._0.rebased) % input.extent.0) + input.min.0
      let t571 = all_w.s0._0.rebased + t506
      for (sum.s1.r85$x, 0, 3) {
       sum[0] = sum[0] + (input[(select((t516 <= sum.s1.r85$x) || (sum.s1.r85$x < input.min.2), ((sum.s1.r85$x - input.min.2) % input.extent.2) + input.min.2, max(min(t516 + -1, sum.s1.r85$x), input.min.2))*input.stride.2) + (select(t571 < t514, max(min(t514 + -1, t571), input.min.0), t572) + t568)]*(((sum.s1.r85$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[(all_w.s0._0.rebased + t570) + 6] = sum[0]
     }
     free sum
    }
   }
   let t576 = all_w.s0._2*all_w.stride.2
   let t573 = t526 - t495
   let t577 = t495 - t523
   for (all_w.s0._1.rebased, 0, t573 + 5) {
    let t581 = (((all_w.s0._1.rebased + t577) + 3)*(t497 + 16)) + t576
    let t579 = (((t495 - input.min.1) + all_w.s0._1.rebased) % input.extent.1) + input.min.1
    let t578 = all_w.s0._1.rebased + t495
    for (all_w.s0._0.rebased, 0, t497 + 16) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t583 = (select(t578 < t515, max(min(t515 + -1, t578), input.min.1), t579)*input.stride.1) - t503
      let t584 = ((((t521 - input.min.0) + all_w.s0._0.rebased) + -6) % input.extent.0) + input.min.0
      let t582 = all_w.s0._0.rebased + t521
      for (sum.s1.r85$x, 0, 3) {
       sum[0] = sum[0] + (input[(select((t516 <= sum.s1.r85$x) || (sum.s1.r85$x < input.min.2), ((sum.s1.r85$x - input.min.2) % input.extent.2) + input.min.2, max(min(t516 + -1, sum.s1.r85$x), input.min.2))*input.stride.2) + (select(((t514 + 6) <= t582) || (t582 < (input.min.0 + 6)), t584, max(min(t514 + 5, t582) + -6, input.min.0)) + t583)]*(((sum.s1.r85$x*3) + all_w.s0._2) + 4))
      }
     }
     consume sum {
      all_w[all_w.s0._0.rebased + t581] = sum[0]
     }
     free sum
    }
   }
  }
 }
 let relu.stride.2 = ((all_w._0.extent_realized.s*8) + 16)*((all_w._1.extent_realized.s*4) + 8)
 allocate relu[int8 * ((all_w._0.extent_realized.s*8) + 16) * ((all_w._1.extent_realized.s*4) + 8) * 19]
 produce relu {
  consume all_w {
   let t585 = all_w._1.extent_realized.s*4
   let t586 = all_w._0.extent_realized.s*8
   for (relu.s0._2, 0, 19) {
    let t588 = relu.s0._2*relu.stride.2
    let t587 = all_w.stride.2*relu.s0._2
    for (relu.s0._1.rebased, 0, t585 + 8) {
     let t589 = (t586 + 16)*relu.s0._1.rebased
     for (relu.s0._0.rebased, 0, t586 + 16) {
      relu[(t588 + t589) + relu.s0._0.rebased] = max(int8(all_w[(t587 + t589) + relu.s0._0.rebased]), (int8)0)
     }
    }
   }
  }
 }
 free all_w
 let upsampled_nn__1.stride.2 = ((all_w._0.extent_realized.s*8) + 16)*((all_w._1.extent_realized.s*8) + 16)
 allocate upsampled_nn__1[int8 * ((all_w._0.extent_realized.s*8) + 16) * ((all_w._1.extent_realized.s*8) + 16) * 19]
 produce upsampled_nn__1 {
  consume relu {
   let t590 = all_w._1.extent_realized.s*8
   let t591 = all_w._0.extent_realized.s*8
   for (upsampled_nn__1.s0._2, 0, 19) {
    let t593 = upsampled_nn__1.s0._2*upsampled_nn__1.stride.2
    let t592 = relu.stride.2*upsampled_nn__1.s0._2
    for (upsampled_nn__1.s0._1.rebased, 0, t590 + 16) {
     let t596 = t591 + 16
     let t594 = ((upsampled_nn__1.s0._1.rebased/2)*t596) + t592
     let t595 = (t596*upsampled_nn__1.s0._1.rebased) + t593
     for (upsampled_nn__1.s0._0.rebased, 0, t591 + 16) {
      upsampled_nn__1[t595 + upsampled_nn__1.s0._0.rebased] = relu[t594 + upsampled_nn__1.s0._0.rebased]
     }
    }
   }
  }
 }
 free relu
 let conv2D_r__0_1.stride.2 = ((all_w._0.extent_realized.s*8) + 11)*((all_w._1.extent_realized.s*8) + 11)
 allocate conv2D_r__0_1[int32 * ((all_w._0.extent_realized.s*8) + 11) * ((all_w._1.extent_realized.s*8) + 11) * 10]
 produce conv2D_r__0_1 {
  let t597 = all_w._1.extent_realized.s*8
  let t598 = all_w._0.extent_realized.s*8
  for (conv2D_r__0_1.s0._2, 0, 10) {
   let t599 = conv2D_r__0_1.s0._2*conv2D_r__0_1.stride.2
   for (conv2D_r__0_1.s0._1.rebased, 0, t597 + 11) {
    let t600 = ((t598 + 11)*conv2D_r__0_1.s0._1.rebased) + t599
    for (conv2D_r__0_1.s0._0.rebased, 0, t598 + 11) {
     conv2D_r__0_1[conv2D_r__0_1.s0._0.rebased + t600] = 0
    }
   }
  }
  consume upsampled_nn__1 {
   let t601 = max(min(int8_weights.min.3, 10), 0)
   let t602 = all_w._1.extent_realized.s*8
   let t603 = all_w._0.extent_realized.s*8
   let t605 = ((int8_weights.min.1*int8_weights.stride.1) + ((int8_weights.min.3*int8_weights.stride.3) + (int8_weights.min.2*int8_weights.stride.2))) + int8_weights.min.0
   let t604 = int8_weights.extent.3 + int8_weights.min.3
   let t607 = int8_weights.extent.2 + int8_weights.min.2
   let t608 = int8_weights.extent.1 + int8_weights.min.1
   let t606 = int8_weights.extent.0 + int8_weights.min.0
   for (conv2D_r__0_1.s1._2, 0, t601) {
    let t609 = conv2D_r__0_1.s1._2*conv2D_r__0_1.stride.2
    let t610 = (max(min(t604 + -1, conv2D_r__0_1.s1._2), int8_weights.min.3)*int8_weights.stride.3) - t605
    for (conv2D_r__0_1.s1._1.rebased, 0, t602 + 11) {
     let t611 = ((t603 + 11)*conv2D_r__0_1.s1._1.rebased) + t609
     for (conv2D_r__0_1.s1._0.rebased, 0, t603 + 11) {
      let t612 = conv2D_r__0_1.s1._0.rebased + t611
      for (conv2D_r__0_1.s1.r185$z, 0, 19) {
       let t613 = max(min(t606 + -1, conv2D_r__0_1.s1.r185$z), int8_weights.min.0) + t610
       let t614 = (conv2D_r__0_1.s1.r185$z*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, 6) {
        let t615 = (max(min(conv2D_r__0_1.s1.r185$y.rebased, t607) + -1, int8_weights.min.2)*int8_weights.stride.2) + t613
        let t616 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r185$y.rebased)*(t603 + 16)) + t614
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t612] = conv2D_r__0_1[t612] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t608) + -1, int8_weights.min.1)*int8_weights.stride.1) + t615]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t616])))
        }
       }
      }
     }
    }
   }
   let t637 = int8_weights.extent.0 + int8_weights.min.0
   let t638 = int8_weights.extent.1 + int8_weights.min.1
   let t639 = int8_weights.extent.2 + int8_weights.min.2
   let t640 = int8_weights.min.1*int8_weights.stride.1
   let t641 = int8_weights.min.3*int8_weights.stride.3
   let t642 = int8_weights.min.2*int8_weights.stride.2
   let t643 = max(min(t638, 5), -1)
   let t644 = max(min(t639, 5), -1)
   let t645 = max(min(t637, 19), 0)
   let t646 = max(min(int8_weights.min.0, 19), 0)
   let t647 = max(min(int8_weights.min.1, 5), -1)
   let t648 = max(min(int8_weights.min.2, 5), -1)
   let t649 = max(min(int8_weights.min.3, 10), 0)
   let t618 = all_w._1.extent_realized.s*8
   let t619 = all_w._0.extent_realized.s*8
   let t617 = max(min(int8_weights.extent.3 + int8_weights.min.3, 10), 0) - t649
   let t631 = t644 - t648
   let t633 = t643 - t647
   let t626 = t645 - t646
   let t636 = 19 - t645
   let t635 = 5 - t644
   let t634 = 5 - t643
   let t622 = ((t641 + t642) + t640) + int8_weights.min.0
   for (conv2D_r__0_1.s1._2.rebased, 0, t617) {
    let t656 = conv2D_r__0_1.s1._2.rebased + t649
    let t657 = int8_weights.stride.3*t656
    let t654 = max(min(t639, 5), -1)
    let t653 = max(min(t638, 5), -1)
    let t655 = max(min(t637, 19), 0)
    let t650 = conv2D_r__0_1.stride.2*t656
    let t651 = t657 - t622
    let t652 = ((((t646 - t641) - t642) - t640) - int8_weights.min.0) + t657
    for (conv2D_r__0_1.s1._1.rebased, 0, t618 + 11) {
     let t658 = ((t619 + 11)*conv2D_r__0_1.s1._1.rebased) + t650
     for (conv2D_r__0_1.s1._0.rebased, 0, t619 + 11) {
      let t661 = conv2D_r__0_1.s1._0.rebased + t658
      for (conv2D_r__0_1.s1.r185$z, 0, t646) {
       let t662 = max(min(t637 + -1, conv2D_r__0_1.s1.r185$z), int8_weights.min.0) + t651
       let t663 = (conv2D_r__0_1.s1.r185$z*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, 6) {
        let t664 = (max(min(conv2D_r__0_1.s1.r185$y.rebased, t639) + -1, int8_weights.min.2)*int8_weights.stride.2) + t662
        let t665 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r185$y.rebased)*(t619 + 16)) + t663
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t661] = conv2D_r__0_1[t661] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t638) + -1, int8_weights.min.1)*int8_weights.stride.1) + t664]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t665])))
        }
       }
      }
      let t666 = conv2D_r__0_1.s1._0.rebased + t658
      for (conv2D_r__0_1.s1.r185$z.rebased, 0, t626) {
       let t672 = ((conv2D_r__0_1.s1.r185$z.rebased + t646)*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased
       let t671 = conv2D_r__0_1.s1.r185$z.rebased + t652
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, t648 + 1) {
        let t673 = (max(min(conv2D_r__0_1.s1.r185$y.rebased, t639) + -1, int8_weights.min.2)*int8_weights.stride.2) + t671
        let t674 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r185$y.rebased)*(t619 + 16)) + t672
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t666] = conv2D_r__0_1[t666] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t638) + -1, int8_weights.min.1)*int8_weights.stride.1) + t673]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t674])))
        }
       }
       let t680 = (conv2D_r__0_1.s1.r185$z.rebased + t646)*upsampled_nn__1.stride.2
       let t679 = (conv2D_r__0_1.s1._0.rebased + t653) + t680
       let t678 = (conv2D_r__0_1.s1._0.rebased + t647) + t680
       let t676 = conv2D_r__0_1.s1._0.rebased + t680
       let t675 = conv2D_r__0_1.s1.r185$z.rebased + t652
       let t677 = conv2D_r__0_1.s1._1.rebased + t648
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, t631) {
        let t682 = (((conv2D_r__0_1.s1.r185$y.rebased + t677) + 1)*(t619 + 16)) + t676
        let t681 = ((conv2D_r__0_1.s1.r185$y.rebased + t648)*int8_weights.stride.2) + t675
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, t647 + 1) {
         conv2D_r__0_1[t666] = conv2D_r__0_1[t666] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t638) + -1, int8_weights.min.1)*int8_weights.stride.1) + t681]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t682])))
        }
        let t684 = (((conv2D_r__0_1.s1.r185$y.rebased + t677) + 1)*(t619 + 16)) + t678
        let t683 = ((conv2D_r__0_1.s1.r185$y.rebased + t648)*int8_weights.stride.2) + t675
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, t633) {
         conv2D_r__0_1[t666] = conv2D_r__0_1[t666] + int32(int16((int8_weights[((conv2D_r__0_1.s1.r185$x.rebased + t647)*int8_weights.stride.1) + t683]*upsampled_nn__1[(conv2D_r__0_1.s1.r185$x.rebased + t684) + 1])))
        }
        let t686 = (((conv2D_r__0_1.s1.r185$y.rebased + t677) + 1)*(t619 + 16)) + t679
        let t685 = ((conv2D_r__0_1.s1.r185$y.rebased + t648)*int8_weights.stride.2) + t675
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, t634) {
         conv2D_r__0_1[t666] = conv2D_r__0_1[t666] + int32(int16((int8_weights[(max(min(t638 + -1, conv2D_r__0_1.s1.r185$x.rebased + t653), int8_weights.min.1)*int8_weights.stride.1) + t685]*upsampled_nn__1[(conv2D_r__0_1.s1.r185$x.rebased + t686) + 1])))
        }
       }
       let t688 = ((conv2D_r__0_1.s1.r185$z.rebased + t646)*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased
       let t687 = conv2D_r__0_1.s1.r185$z.rebased + t652
       let t689 = conv2D_r__0_1.s1._1.rebased + t654
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, t635) {
        let t690 = (max(min(t639 + -1, conv2D_r__0_1.s1.r185$y.rebased + t654), int8_weights.min.2)*int8_weights.stride.2) + t687
        let t691 = (((conv2D_r__0_1.s1.r185$y.rebased + t689) + 1)*(t619 + 16)) + t688
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t666] = conv2D_r__0_1[t666] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t638) + -1, int8_weights.min.1)*int8_weights.stride.1) + t690]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t691])))
        }
       }
      }
      let t692 = conv2D_r__0_1.s1._0.rebased + t658
      for (conv2D_r__0_1.s1.r185$z.rebased, 0, t636) {
       let t693 = conv2D_r__0_1.s1.r185$z.rebased + t655
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, 6) {
        let t694 = (max(min(conv2D_r__0_1.s1.r185$y.rebased, t639) + -1, int8_weights.min.2)*int8_weights.stride.2) + (max(min(t637 + -1, t693), int8_weights.min.0) + t651)
        let t695 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r185$y.rebased)*(t619 + 16)) + ((t693*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased)
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t692] = conv2D_r__0_1[t692] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t638) + -1, int8_weights.min.1)*int8_weights.stride.1) + t694]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t695])))
        }
       }
      }
     }
    }
   }
   let t705 = int8_weights.extent.3 + int8_weights.min.3
   let t706 = max(min(t705, 10), 0)
   let t697 = all_w._1.extent_realized.s*8
   let t698 = all_w._0.extent_realized.s*8
   let t701 = ((int8_weights.min.1*int8_weights.stride.1) + ((int8_weights.min.3*int8_weights.stride.3) + (int8_weights.min.2*int8_weights.stride.2))) + int8_weights.min.0
   let t703 = int8_weights.extent.2 + int8_weights.min.2
   let t704 = int8_weights.extent.1 + int8_weights.min.1
   let t702 = int8_weights.extent.0 + int8_weights.min.0
   for (conv2D_r__0_1.s1._2.rebased, 0, 10 - t706) {
    let t707 = (conv2D_r__0_1.s1._2.rebased + t706)*conv2D_r__0_1.stride.2
    let t708 = (max(min(t705 + -1, max(min(t705, 10), 0) + conv2D_r__0_1.s1._2.rebased), int8_weights.min.3)*int8_weights.stride.3) - t701
    for (conv2D_r__0_1.s1._1.rebased, 0, t697 + 11) {
     let t709 = ((t698 + 11)*conv2D_r__0_1.s1._1.rebased) + t707
     for (conv2D_r__0_1.s1._0.rebased, 0, t698 + 11) {
      let t710 = conv2D_r__0_1.s1._0.rebased + t709
      for (conv2D_r__0_1.s1.r185$z, 0, 19) {
       let t711 = max(min(t702 + -1, conv2D_r__0_1.s1.r185$z), int8_weights.min.0) + t708
       let t712 = (conv2D_r__0_1.s1.r185$z*upsampled_nn__1.stride.2) + conv2D_r__0_1.s1._0.rebased
       for (conv2D_r__0_1.s1.r185$y.rebased, 0, 6) {
        let t713 = (max(min(conv2D_r__0_1.s1.r185$y.rebased, t703) + -1, int8_weights.min.2)*int8_weights.stride.2) + t711
        let t714 = ((conv2D_r__0_1.s1._1.rebased + conv2D_r__0_1.s1.r185$y.rebased)*(t698 + 16)) + t712
        for (conv2D_r__0_1.s1.r185$x.rebased, 0, 6) {
         conv2D_r__0_1[t710] = conv2D_r__0_1[t710] + int32(int16((int8_weights[(max(min(conv2D_r__0_1.s1.r185$x.rebased, t704) + -1, int8_weights.min.1)*int8_weights.stride.1) + t713]*upsampled_nn__1[conv2D_r__0_1.s1.r185$x.rebased + t714])))
        }
       }
      }
     }
    }
   }
   free upsampled_nn__1
  }
 }
 let pool2D_r__0_1.stride.2 = (all_w._0.extent_realized.s + 1)*(all_w._1.extent_realized.s + 1)
 allocate pool2D_r__0_1[int16 * (all_w._0.extent_realized.s + 1) * (all_w._1.extent_realized.s + 1) * 10]
 let pool2D_r__0_1.s0._1.loop_extent = (((casted.extent.1 + casted.min.1) + 7)/4) - (casted.min.1/4)
 let pool2D_r__0_1.s0._0.loop_extent = (((casted.extent.0 + casted.min.0) + 15)/8) - (casted.min.0/8)
 produce pool2D_r__0_1 {
  for (pool2D_r__0_1.s0._2, 0, 10) {
   let t715 = pool2D_r__0_1.s0._2*pool2D_r__0_1.stride.2
   for (pool2D_r__0_1.s0._1.rebased, 0, pool2D_r__0_1.s0._1.loop_extent) {
    let t716 = ((all_w._0.extent_realized.s + 1)*pool2D_r__0_1.s0._1.rebased) + t715
    for (pool2D_r__0_1.s0._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
     pool2D_r__0_1[pool2D_r__0_1.s0._0.rebased + t716] = (int16)0
    }
   }
  }
  consume conv2D_r__0_1 {
   for (pool2D_r__0_1.s1._2, 0, 10) {
    let t718 = pool2D_r__0_1.s1._2*pool2D_r__0_1.stride.2
    let t719 = conv2D_r__0_1.stride.2*pool2D_r__0_1.s1._2
    for (pool2D_r__0_1.s1._1.rebased, 0, pool2D_r__0_1.s0._1.loop_extent) {
     let t722 = pool2D_r__0_1.s1._1.rebased*8
     let t723 = all_w._0.extent_realized.s*8
     let t721 = ((all_w._0.extent_realized.s + 1)*pool2D_r__0_1.s1._1.rebased) + t718
     for (pool2D_r__0_1.s1._0.rebased, 0, pool2D_r__0_1.s0._0.loop_extent) {
      let t725 = (pool2D_r__0_1.s1._0.rebased*8) + t719
      let t724 = pool2D_r__0_1.s1._0.rebased + t721
      for (pool2D_r__0_1.s1.r275$y.rebased, 0, 11) {
       let t726 = ((pool2D_r__0_1.s1.r275$y.rebased + t722)*(t723 + 11)) + t725
       for (pool2D_r__0_1.s1.r275$x.rebased, 0, 11) {
        pool2D_r__0_1[t724] = pool2D_r__0_1[t724] + (int16(conv2D_r__0_1[pool2D_r__0_1.s1.r275$x.rebased + t726])/(int16)121)
       }
      }
     }
    }
   }
  }
  free conv2D_r__0_1
 }
 produce casted {
  consume pool2D_r__0_1 {
   let t728 = casted.min.1/4
   let t727 = casted.min.0/8
   let t729 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t732 = casted.min.2 + casted.s0._2.rebased
    let t731 = (casted.stride.2*t732) + t729
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t735 = casted.min.1 + casted.s0._1.rebased
     let t733 = (t735/4) - t728
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$7[int32 * 4]
      produce all_r$7 {
       for (all_r$7.s0._1.rebased, 0, 2) {
        let t736 = all_r$7.s0._1.rebased*2
        for (all_r$7.s0._0.rebased, 0, 2) {
         all_r$7[all_r$7.s0._0.rebased + t736] = 0
        }
       }
       let t737 = ((casted.min.0 + casted.s0._0.rebased)/8) - t727
       for (all_r$7.s1._1.rebased, 0, 2) {
        let t738 = all_r$7.s1._1.rebased*2
        let t739 = ((all_r$7.s1._1.rebased + t733)*(all_w._0.extent_realized.s + 1)) + t737
        for (all_r$7.s1._0.rebased, 0, 2) {
         let t741 = all_r$7.s1._0.rebased + t739
         let t740 = all_r$7.s1._0.rebased + t738
         for (all_r$7.s1.r286$x, 0, 10) {
          all_r$7[t740] = all_r$7[t740] + ((((all_r$7.s1.r286$x*10) + t732) + 11)*int32(pool2D_r__0_1[(all_r$7.s1.r286$x*pool2D_r__0_1.stride.2) + t741]))
         }
        }
       }
      }
      consume all_r$7 {
       let t492 = t735 % 4
       let t493 = (casted.min.0 + casted.s0._0.rebased) % 8
       casted[((casted.stride.1*t735) + t731) + casted.s0._0.rebased] = int32((int16((((4 - t492)*int32((int16(((all_r$7[0]*(8 - t493)) + (all_r$7[1]*t493)))/(int16)16))) + (t492*int32((int16(((all_r$7[2]*(8 - t493)) + (all_r$7[3]*t493)))/(int16)16)))))/(int16)8))
      }
      free all_r$7
     }
    }
   }
  }
 }
 free pool2D_r__0_1
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
add_temp_object_file: /tmp/auhLy0/random_pipeline.a.o
Module.compile(): temporary object /tmp/auhLy0/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50069_0/random_pipeline.a
file_unlink: /tmp/auhLy0/random_pipeline.a.o
dir_rmdir: /tmp/auhLy0
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50069_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50069_0/random_pipeline.registration.cpp
