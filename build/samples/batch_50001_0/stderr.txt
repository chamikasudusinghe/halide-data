Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50001_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
In random expression: (let t6 = sliced(_0 + 1, _1, 0) in (let t7 = sliced(_0 + 2, _1 + -2, 0) in max(select(max(sliced(_0 + 1, _1 + -1, 0), sliced(_0 + 3, _1 + 2, 0)) < (t7 % sliced(_0 + -1, _1 + -5, 0)), t6 - sliced(_0 + -4, _1 + -1, 0), sliced(_0 + -2, _1 + -4, 0) + select(sliced(_0, _1 + -4, 0) == sliced(_0 + -5, _1 + 2, 0), sliced(_0 + -2, _1, 0), t7)), ((int32((sliced(_0 + -3, _1 + 3, 0) <= sliced(_0, _1 + -5, 0)))/sliced(_0, _1 + 3, 0))/(t6/sliced(_0 + -3, _1, 0)))/((sliced(_0 + 2, _1 + -5, 0) + sliced(_0, _1 + 2, 0)) - sliced(_0 + -5, _1 + -3, 0)))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t8 = sliced(_0 + -5, _1 + -2, 0) in (int32(uint8((uint16((max(sliced(_0 + 2, _1 + -5, 0), sliced(_0 + 1, _1 + 2, 0)/sliced(_0, _1 + -1, 0)) % int32(uint16((sliced(_0 + -4, _1 + 3, 0) - sliced(_0 + -2, _1 + -2, 0)))))) % uint16(((sliced(_0 + -3, _1 + -1, 0) + sliced(_0 + -3, _1 + 1, 0)) < max(sliced(_0 + -2, _1 + -4, 0), sliced(_0 + -3, _1 + -5, 0))))))) % (select(t8 < sliced(_0 + -3, _1 + 2, 0), sliced(_0 + 2, _1 + 1, 0), t8/sliced(_0 + 2, _1, 0))*select(t8 == sliced(_0 + -3, _1 + -4, 0), sliced(_0 + -5, _1 + -5, 0), sliced(_0 + -2, _1 + -5, 0)))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t9 = sliced(_0 + -5, _1 + -4, 0) in (max(max(sliced(_0 + -3, _1 + -3, 0), sliced(_0 + -4, _1 + -4, 0)*sliced(_0, _1, 0)), int32((max(sliced(_0, _1 + 1, 0), max(sliced(_0 + -4, _1 + -5, 0), sliced(_0 + 2, _1 + 3, 0))) <= (sliced(_0 + 3, _1, 0) + (t9*2))))) + ((sliced(_0, _1 + -2, 0)*sliced(_0 + -1, _1 + -5, 0)) - (int32((sliced(_0 + -3, _1 + -1, 0) < sliced(_0 + -4, _1 + 3, 0)))/sliced(_0, _1 + 3, 0)))))
The following expressions were unused:
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -5, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t10 = sliced(_0 + 1, _1 + 3, 0) in (let t11 = sliced(_0 + -5, _1 + 2, 0) in (let t12 = sliced(_0 + -5, _1, 0) in (let t13 = sliced(_0, _1, 0) in (let t14 = sliced(_0 + -4, _1 + -3, 0) in (let t15 = sliced(_0 + -1, _1 + -4, 0) in (let t16 = sliced(_0 + 2, _1 + -5, 0) in select((max(sliced(_0 + -4, _1 + -2, 0)/t10, t11)/(t12/sliced(_0 + -1, _1 + 3, 0))) < int32((max(sliced(_0 + -1, _1 + -2, 0), sliced(_0 + -4, _1 + -1, 0)/sliced(_0 + -2, _1 + -3, 0)) < int32((min(t13, t14) <= max(t15, t16))))), select((int32((sliced(_0 + -1, _1 + 2, 0) != sliced(_0 + -3, _1 + 3, 0))) % t14) < ((sliced(_0 + -3, _1 + 2, 0)/sliced(_0 + -1, _1 + 1, 0))/t13), min(t10, t11)*int32(((sliced(_0, _1 + -5, 0) - t12) != int32((sliced(_0 + 1, _1 + -3, 0) == sliced(_0 + -2, _1 + -4, 0))))), min(sliced(_0 + 1, _1 + -4, 0), max(sliced(_0 + 2, _1 + -3, 0), sliced(_0 + -3, _1 + -3, 0)))), int32(select((t15 % sliced(_0 + 2, _1 + 3, 0)) == (sliced(_0 + 3, _1 + -1, 0)/sliced(_0 + -4, _1 + 3, 0)), select(sliced(_0 + 2, _1 + -2, 0) < sliced(_0 + 3, _1 + -3, 0), sliced(_0 + 2, _1 + 1, 0), sliced(_0 + -5, _1 + -2, 0)) < (sliced(_0, _1 + -4, 0) % sliced(_0 + -4, _1 + 1, 0)), uint1(max(sliced(_0 + -2, _1 + 2, 0), t16))))))))))))
The following expressions were unused:
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t17 = sliced(_0 + -3, _1 + -5, 0) in (let t18 = sliced(_0 + -2, _1 + -3, 0) in (let t19 = sliced(_0 + -1, _1 + -5, 0) in (let t20 = sliced(_0 + -1, _1, 0) in (int32(((max(sliced(_0 + 3, _1 + -1, 0), sliced(_0 + 1, _1 + 1, 0)*t17)/max(sliced(_0 + 1, _1 + 2, 0), t18)) < int32(((sliced(_0 + -5, _1 + 1, 0) + max(sliced(_0 + -3, _1 + 1, 0), min(sliced(_0 + -4, _1 + -5, 0), t18))) <= max(sliced(_0 + -3, _1 + -1, 0), sliced(_0 + -1, _1 + 3, 0)))))) <= select((int32((sliced(_0 + 2, _1 + -5, 0) <= sliced(_0 + 3, _1 + 2, 0)))/t19) == (max(sliced(_0 + -2, _1, 0), t20) % sliced(_0 + 3, _1, 0)), sliced(_0 + -2, _1 + 1, 0)*(t20 % sliced(_0 + -1, _1 + -3, 0)), int32(select(t17 < sliced(_0 + 1, _1 + -2, 0), sliced(_0, _1 + 2, 0) <= sliced(_0 + 1, _1 + 3, 0), uint1(sliced(_0, _1 + 1, 0))))/(t19 - sliced(_0 + 2, _1 + 1, 0))))))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t21 = sliced(_0 + -4, _1 + -2, 0) in ((min(sliced(_0 + 3, _1 + -5, 0), sliced(_0 + 1, _1 + 3, 0) % sliced(_0 + -4, _1 + -1, 0)) + ((int32((sliced(_0 + 1, _1 + 2, 0) < sliced(_0 + 2, _1, 0))) % sliced(_0 + -4, _1 + 2, 0)) - (sliced(_0 + -2, _1 + -1, 0) % t21)))/min(sliced(_0 + 3, _1 + 1, 0)/sliced(_0 + -3, _1 + 3, 0), min(sliced(_0 + 2, _1 + -2, 0), t21) % sliced(_0 + -1, _1 + -4, 0))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 2, _1 + -5, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t22 = sliced(_0, _1 + -4, 0) in (let t23 = sliced(_0 + -5, _1 + -2, 0) in (max(max(sliced(_0 + -4, _1 + -4, 0), sliced(_0 + 2, _1 + -3, 0))/sliced(_0 + 1, _1 + -1, 0), select(sliced(_0 + 1, _1 + -3, 0) < sliced(_0 + -5, _1 + 1, 0), t22, min(sliced(_0 + 3, _1 + 2, 0), sliced(_0 + 2, _1 + -4, 0))) % (t23*2)) < max(sliced(_0 + -2, _1 + -1, 0)*int32((sliced(_0 + 3, _1 + -5, 0) < sliced(_0 + -1, _1, 0))), int32(int16((((sliced(_0, _1 + -5, 0)/sliced(_0 + 2, _1, 0))/t22)/(sliced(_0, _1 + -2, 0)/sliced(_0 + 1, _1 + -5, 0)))))))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1 + -5, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t24 = sliced(_0 + -5, _1 + 1, 0) in (let t25 = sliced(_0 + 2, _1 + -5, 0) in (let t26 = sliced(_0 + -1, _1, 0) in uint8((max((sliced(_0 + -2, _1 + 2, 0) + t26)/t25, t24/sliced(_0 + 3, _1 + -5, 0))*(min(t24 - sliced(_0, _1 + -2, 0), int32(uint16(select(sliced(_0, _1 + 2, 0) < sliced(_0 + -3, _1, 0), sliced(_0 + -3, _1 + -4, 0), max(sliced(_0 + 2, _1 + 1, 0), sliced(_0 + -2, _1 + 1, 0)))))) - int32((sliced(_0 + 1, _1 + -4, 0) < ((sliced(_0 + -4, _1 + 1, 0)*t25) + t26)))))))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 2, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 2, _1 + 3, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (let t27 = sliced(_0 + -1, _1 + -3, 0) in (let t28 = sliced(_0 + -3, _1, 0) in ((select((sliced(_0 + 2, _1 + 3, 0)/sliced(_0 + 1, _1 + -2, 0)) < (sliced(_0 + -3, _1 + -3, 0)/sliced(_0 + 3, _1 + -1, 0)), max(sliced(_0 + 1, _1 + -5, 0), sliced(_0 + 1, _1 + -3, 0)), sliced(_0 + -2, _1 + 1, 0) + (sliced(_0 + -2, _1, 0)/sliced(_0 + 1, _1 + -1, 0))) % (select(sliced(_0 + -1, _1, 0) < sliced(_0 + -4, _1 + 2, 0), sliced(_0 + -1, _1 + 1, 0), t27) % sliced(_0 + 2, _1 + -5, 0))) - (select(sliced(_0 + -5, _1 + 1, 0) == t27, sliced(_0 + 1, _1 + 1, 0), sliced(_0 + -4, _1 + 3, 0)) + int32(int8(((t28*t28) - sliced(_0, _1, 0))))))))
The following expressions were unused:
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 2, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -2, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 1, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -2, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + -1, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -2, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -5, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -3, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 2, 0)
sliced(_0 + 3, _1 + 3, 0)
In random expression: (((min(sliced(_0 + 2, _1 + 3, 0), int32((sliced(_0 + 3, _1 + -3, 0) < sliced(_0 + -4, _1, 0)))) - select(sliced(_0 + 3, _1 + 2, 0) < sliced(_0 + 3, _1 + -5, 0), sliced(_0 + 2, _1 + -2, 0), sliced(_0 + -4, _1 + 2, 0)))/(min(sliced(_0 + -4, _1 + 1, 0), sliced(_0 + -3, _1, 0)) - sliced(_0 + -1, _1 + 1, 0))) - (max(sliced(_0 + -5, _1 + 2, 0), sliced(_0 + 1, _1, 0))*(sliced(_0 + -1, _1 + -1, 0)*min(sliced(_0 + -2, _1 + -2, 0), sliced(_0 + -4, _1 + -2, 0)))))
The following expressions were unused:
sliced(_0, _1, 0)
sliced(_0, _1 + -5, 0)
sliced(_0, _1 + -4, 0)
sliced(_0, _1 + -3, 0)
sliced(_0, _1 + -2, 0)
sliced(_0, _1 + -1, 0)
sliced(_0, _1 + 1, 0)
sliced(_0, _1 + 2, 0)
sliced(_0, _1 + 3, 0)
sliced(_0 + -5, _1, 0)
sliced(_0 + -5, _1 + -5, 0)
sliced(_0 + -5, _1 + -4, 0)
sliced(_0 + -5, _1 + -3, 0)
sliced(_0 + -5, _1 + -2, 0)
sliced(_0 + -5, _1 + -1, 0)
sliced(_0 + -5, _1 + 1, 0)
sliced(_0 + -5, _1 + 3, 0)
sliced(_0 + -4, _1 + -5, 0)
sliced(_0 + -4, _1 + -4, 0)
sliced(_0 + -4, _1 + -3, 0)
sliced(_0 + -4, _1 + -1, 0)
sliced(_0 + -4, _1 + 3, 0)
sliced(_0 + -3, _1 + -5, 0)
sliced(_0 + -3, _1 + -4, 0)
sliced(_0 + -3, _1 + -3, 0)
sliced(_0 + -3, _1 + -2, 0)
sliced(_0 + -3, _1 + -1, 0)
sliced(_0 + -3, _1 + 1, 0)
sliced(_0 + -3, _1 + 2, 0)
sliced(_0 + -3, _1 + 3, 0)
sliced(_0 + -2, _1, 0)
sliced(_0 + -2, _1 + -5, 0)
sliced(_0 + -2, _1 + -4, 0)
sliced(_0 + -2, _1 + -3, 0)
sliced(_0 + -2, _1 + -1, 0)
sliced(_0 + -2, _1 + 1, 0)
sliced(_0 + -2, _1 + 2, 0)
sliced(_0 + -2, _1 + 3, 0)
sliced(_0 + -1, _1, 0)
sliced(_0 + -1, _1 + -5, 0)
sliced(_0 + -1, _1 + -4, 0)
sliced(_0 + -1, _1 + -3, 0)
sliced(_0 + -1, _1 + -2, 0)
sliced(_0 + -1, _1 + 2, 0)
sliced(_0 + -1, _1 + 3, 0)
sliced(_0 + 1, _1 + -5, 0)
sliced(_0 + 1, _1 + -4, 0)
sliced(_0 + 1, _1 + -3, 0)
sliced(_0 + 1, _1 + -2, 0)
sliced(_0 + 1, _1 + -1, 0)
sliced(_0 + 1, _1 + 1, 0)
sliced(_0 + 1, _1 + 2, 0)
sliced(_0 + 1, _1 + 3, 0)
sliced(_0 + 2, _1, 0)
sliced(_0 + 2, _1 + -5, 0)
sliced(_0 + 2, _1 + -4, 0)
sliced(_0 + 2, _1 + -3, 0)
sliced(_0 + 2, _1 + -1, 0)
sliced(_0 + 2, _1 + 1, 0)
sliced(_0 + 2, _1 + 2, 0)
sliced(_0 + 3, _1, 0)
sliced(_0 + 3, _1 + -4, 0)
sliced(_0 + 3, _1 + -2, 0)
sliced(_0 + 3, _1 + -1, 0)
sliced(_0 + 3, _1 + 1, 0)
sliced(_0 + 3, _1 + 3, 0)
(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((0 + sliced(_0 + -5, _1 + -5, 0)) + sliced(_0 + -5, _1 + -4, 0)) + sliced(_0 + -5, _1 + -3, 0)) + sliced(_0 + -5, _1 + -2, 0)) + sliced(_0 + -5, _1 + -1, 0)) + sliced(_0 + -5, _1, 0)) + sliced(_0 + -5, _1 + 1, 0)) + sliced(_0 + -5, _1 + 2, 0)) + sliced(_0 + -5, _1 + 3, 0)) + sliced(_0 + -4, _1 + -5, 0)) + sliced(_0 + -4, _1 + -4, 0)) + sliced(_0 + -4, _1 + -3, 0)) + sliced(_0 + -4, _1 + -2, 0)) + sliced(_0 + -4, _1 + -1, 0)) + sliced(_0 + -4, _1, 0)) + sliced(_0 + -4, _1 + 1, 0)) + sliced(_0 + -4, _1 + 2, 0)) + sliced(_0 + -4, _1 + 3, 0)) + sliced(_0 + -3, _1 + -5, 0)) + sliced(_0 + -3, _1 + -4, 0)) + sliced(_0 + -3, _1 + -3, 0)) + sliced(_0 + -3, _1 + -2, 0)) + sliced(_0 + -3, _1 + -1, 0)) + sliced(_0 + -3, _1, 0)) + sliced(_0 + -3, _1 + 1, 0)) + sliced(_0 + -3, _1 + 2, 0)) + sliced(_0 + -3, _1 + 3, 0)) + sliced(_0 + -2, _1 + -5, 0)) + sliced(_0 + -2, _1 + -4, 0)) + sliced(_0 + -2, _1 + -3, 0)) + sliced(_0 + -2, _1 + -2, 0)) + sliced(_0 + -2, _1 + -1, 0)) + sliced(_0 + -2, _1, 0)) + sliced(_0 + -2, _1 + 1, 0)) + sliced(_0 + -2, _1 + 2, 0)) + sliced(_0 + -2, _1 + 3, 0)) + sliced(_0 + -1, _1 + -5, 0)) + sliced(_0 + -1, _1 + -4, 0)) + sliced(_0 + -1, _1 + -3, 0)) + sliced(_0 + -1, _1 + -2, 0)) + sliced(_0 + -1, _1 + -1, 0)) + sliced(_0 + -1, _1, 0)) + sliced(_0 + -1, _1 + 1, 0)) + sliced(_0 + -1, _1 + 2, 0)) + sliced(_0 + -1, _1 + 3, 0)) + sliced(_0, _1 + -5, 0)) + sliced(_0, _1 + -4, 0)) + sliced(_0, _1 + -3, 0)) + sliced(_0, _1 + -2, 0)) + sliced(_0, _1 + -1, 0)) + sliced(_0, _1, 0)) + sliced(_0, _1 + 1, 0)) + sliced(_0, _1 + 2, 0)) + sliced(_0, _1 + 3, 0)) + sliced(_0 + 1, _1 + -5, 0)) + sliced(_0 + 1, _1 + -4, 0)) + sliced(_0 + 1, _1 + -3, 0)) + sliced(_0 + 1, _1 + -2, 0)) + sliced(_0 + 1, _1 + -1, 0)) + sliced(_0 + 1, _1, 0)) + sliced(_0 + 1, _1 + 1, 0)) + sliced(_0 + 1, _1 + 2, 0)) + sliced(_0 + 1, _1 + 3, 0)) + sliced(_0 + 2, _1 + -5, 0)) + sliced(_0 + 2, _1 + -4, 0)) + sliced(_0 + 2, _1 + -3, 0)) + sliced(_0 + 2, _1 + -2, 0)) + sliced(_0 + 2, _1 + -1, 0)) + sliced(_0 + 2, _1, 0)) + sliced(_0 + 2, _1 + 1, 0)) + sliced(_0 + 2, _1 + 2, 0)) + sliced(_0 + 2, _1 + 3, 0)) + sliced(_0 + 3, _1 + -5, 0)) + sliced(_0 + 3, _1 + -4, 0)) + sliced(_0 + 3, _1 + -3, 0)) + sliced(_0 + 3, _1 + -2, 0)) + sliced(_0 + 3, _1 + -1, 0)) + sliced(_0 + 3, _1, 0)) + sliced(_0 + 3, _1 + 1, 0)) + sliced(_0 + 3, _1 + 2, 0)) + sliced(_0 + 3, _1 + 3, 0))
In random expression: (let t36 = all_r$3(_0, _1, _2) in t36)
The following expressions were unused:
constant_exterior(_0, _1, _2)
In random expression: 0
The following expressions were unused:
all_r$3(_0, _1, _2)
constant_exterior(_0, _1, _2)
In random expression: (let t38 = constant_exterior(_0, _1, _2) in (t38*t38))
The following expressions were unused:
all_r$3(_0, _1, _2)
max(constant_exterior(_0, _1, _2), all_r$3(_0, _1, _2))
(let t45 = all_r$2(_0, _1, _2) in ((all_r$4(_0, _1, _2) + t45)/t45))
(let t49 = all_r$5(_0, _1, _2) in max(binary_op(_0, _1, _2) % t49, t49))
In random expression: (let t53 = constant_exterior$1(_0 + -1, _1, _2) in max(constant_exterior$1(_0 + -2, _1, _2), t53))
The following expressions were unused:
constant_exterior$1(_0, _1, _2)
uint8(max(constant_exterior$1(_0, _1, _2), min(constant_exterior$1(_0 + -1, _1, _2), constant_exterior$1(_0 + -2, _1, _2))))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$8 }
Injecting realization of { conv_w__0 }
Injecting realization of { sum$2 }
Injecting realization of { all_r$7 }
Injecting realization of { constant_exterior$1 }
Inlining repeat_edge$7
Injecting realization of { binary_op$2 }
Injecting realization of { binary_op }
Injecting realization of { all_r$3 }
Injecting realization of { conv2D__0_1 }
Injecting realization of { all_r$5 }
Injecting realization of { binary_op$1 }
Injecting realization of { all_r$4 }
Injecting realization of { all_r$2 }
Injecting realization of { constant_exterior }
Inlining repeat_edge$6
Injecting realization of { all_r$1 }
Injecting realization of { sliced }
Inlining upsampled_linear__0
Injecting realization of { all_r }
Injecting realization of { downsampled_nn__0 }
Inlining repeat_image
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s0._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s0._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s0._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Warning: expression is non-monotonic in loop variable sliced.s0._0.rebased: ((((max(min(casted.min.0, 2004), 5) + (sliced.s0._0.rebased - ((((max(min(casted.min.0, 2004), 5) + sliced.s0._0.rebased) + -10)/8)*8))) + -10)/8) + all_r.s1._0.rebased)
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let input.extent.0.required.s = let t1030 = (input.extent.0 + input.min.0) in (let t1031 = max(min(casted.extent.0 + casted.min.0, 1996), -3) in (let t1032 = max(min(casted.min.0, 2004), 5) in (let t1033 = (((t1030 + -6) <= t1031) || (t1032 < (input.min.0 + 10))) in (let t1034 = (input.min.0 + max(-1 - input.extent.0, max(input.extent.0, 1) + -1)) in (let t1035 = max(min(t1031 + 7, t1030) + -1, input.min.0) in (let t1036 = (((t1030 + 10) <= t1032) || (t1031 < (input.min.0 + -6))) in (let t1037 = ((t1030 <= (((t1032 + -10)/8)*8)) || ((((t1031 + 14)/8)*8) < input.min.0)) in (let t1038 = max(min(((t1031 + 14)/8)*8, t1030 + -1), input.min.0) in (let t1039 = ((t1030 <= (((t1031 + 14)/8)*8)) || ((((t1032 + -10)/8)*8) < input.min.0)) in (let t1040 = max(min(t1032, t1030 + 9) + -10, input.min.0) in (let t1041 = max(min(((t1032 + -10)/8)*8, t1030 + -1), input.min.0) in (max(select(t1033, t1034, t1035), max(select(t1036, t1034, t1035), max(select(t1037, t1034, t1038), select(t1039, t1034, t1038)))) - min(select(t1033, input.min.0, t1040), min(select(t1036, input.min.0, t1040), min(select(t1037, input.min.0, t1041), select(t1039, input.min.0, t1041))))))))))))))))
let input.min.0.required = let t1042 = (input.extent.0 + input.min.0) in (let t1043 = max(min(casted.extent.0 + casted.min.0, 1996), -3) in (let t1044 = max(min(casted.min.0, 2004), 5) in (let t1045 = max(min(t1044, t1042 + 9) + -10, input.min.0) in (let t1046 = max(min(((t1044 + -10)/8)*8, t1042 + -1), input.min.0) in min(select(((t1042 + -6) <= t1043) || (t1044 < (input.min.0 + 10)), input.min.0, t1045), min(select(((t1042 + 10) <= t1044) || (t1043 < (input.min.0 + -6)), input.min.0, t1045), min(select((t1042 <= (((t1044 + -10)/8)*8)) || ((((t1043 + 14)/8)*8) < input.min.0), input.min.0, t1046), select((t1042 <= (((t1043 + 14)/8)*8)) || ((((t1044 + -10)/8)*8) < input.min.0), input.min.0, t1046))))))))
let input.extent.1.required.s = let t1047 = (input.extent.1 + input.min.1) in (let t1048 = max(min(casted.min.1, 1999), 0) in (let t1049 = max(min(casted.extent.1 + casted.min.1, 2000), 1) in (let t1050 = (((t1047 + 5) <= t1048) || (t1049 < (input.min.1 + -2))) in (let t1051 = (input.min.1 + max(-1 - input.extent.1, max(input.extent.1, 1) + -1)) in (let t1052 = max(min(t1049 + 3, t1047) + -1, input.min.1) in (let t1053 = (((t1047 + -2) <= t1049) || (t1048 < (input.min.1 + 5))) in (let t1054 = max(min(t1048, t1047 + 4) + -5, input.min.1) in (max(select(t1050, t1051, t1052), select(t1053, t1051, t1052)) - min(select(t1050, input.min.1, t1054), select(t1053, input.min.1, t1054))))))))))
let input.min.1.required = let t1055 = (input.extent.1 + input.min.1) in (let t1056 = max(min(casted.min.1, 1999), 0) in (let t1057 = max(min(casted.extent.1 + casted.min.1, 2000), 1) in (let t1058 = max(min(t1056, t1055 + 4) + -5, input.min.1) in min(select(((t1055 + 5) <= t1056) || (t1057 < (input.min.1 + -2)), input.min.1, t1058), select(((t1055 + -2) <= t1057) || (t1056 < (input.min.1 + 5)), input.min.1, t1058)))))
let input.extent.2.required.s = let t1059 = (input.extent.2 + input.min.2) in (let t1060 = ((t1059 <= 0) || (2 < input.min.2)) in (let t1061 = (input.min.2 + max(-1 - input.extent.2, max(input.extent.2, 1) + -1)) in (let t1062 = max(min(t1059, 3) + -1, input.min.2) in (let t1063 = ((t1059 <= 2) || (0 < input.min.2)) in (let t1064 = max(min(t1059, 1) + -1, input.min.2) in (max(select(t1060, t1061, t1062), select(t1063, t1061, t1062)) - min(select(t1060, input.min.2, t1064), select(t1063, input.min.2, t1064))))))))
let input.min.2.required = let t1065 = (input.extent.2 + input.min.2) in (let t1066 = max(min(t1065, 1) + -1, input.min.2) in min(select((t1065 <= 0) || (2 < input.min.2), input.min.2, t1066), select((t1065 <= 2) || (0 < input.min.2), input.min.2, t1066)))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 let downsampled_nn__0._1.extent_realized.s = max(min(casted.extent.1 + casted.min.1, 2000), 1) - max(min(casted.min.1, 1999), 0)
 let downsampled_nn__0._0.extent_realized.s = ((max(min(casted.extent.0 + casted.min.0, 1996), -3) + 14)/8) - ((max(min(casted.min.0, 2004), 5) + -10)/8)
 let downsampled_nn__0.stride.2 = (downsampled_nn__0._0.extent_realized.s + 1)*(downsampled_nn__0._1.extent_realized.s + 8)
 allocate downsampled_nn__0[int32 * (downsampled_nn__0._0.extent_realized.s + 1) * (downsampled_nn__0._1.extent_realized.s + 8) * 3]
 let downsampled_nn__0.s0._0.loop_extent = ((max(min(casted.extent.0 + casted.min.0, 1996), -3) + 22)/8) - ((max(min(casted.min.0, 2004), 5) + -10)/8)
 produce downsampled_nn__0 {
  let t675 = max(min(input.min.2, 3), 0)
  let t678 = max(min(casted.min.1, 1999), 0)
  let t680 = (max(min(casted.min.0, 2004), 5) + -10)/8
  let t681 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (downsampled_nn__0.s0._2, 0, t675) {
   let t687 = input.extent.2 + input.min.2
   let t686 = downsampled_nn__0.s0._2*downsampled_nn__0.stride.2
   let t682 = (select((t687 <= downsampled_nn__0.s0._2) || (downsampled_nn__0.s0._2 < input.min.2), ((downsampled_nn__0.s0._2 - input.min.2) % input.extent.2) + input.min.2, max(min(t687 + -1, downsampled_nn__0.s0._2), input.min.2))*input.stride.2) - t681
   for (downsampled_nn__0.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s + 8) {
    let t692 = ((downsampled_nn__0._0.extent_realized.s + 1)*downsampled_nn__0.s0._1.rebased) + t686
    let t690 = ((((t678 - input.min.1) + downsampled_nn__0.s0._1.rebased) + -5) % input.extent.1) + input.min.1
    let t689 = input.extent.1 + input.min.1
    let t688 = downsampled_nn__0.s0._1.rebased + t678
    for (downsampled_nn__0.s0._0.rebased, 0, downsampled_nn__0.s0._0.loop_extent) {
     let t574 = downsampled_nn__0.s0._0.rebased + t680
     let t1067 = input.extent.0 + input.min.0
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t692] = input[select((t1067 <= (t574*8)) || ((t574*8) < input.min.0), (((t574*8) - input.min.0) % input.extent.0) + input.min.0, max(min(t574*8, t1067 + -1), input.min.0)) + ((select(((t689 + 5) <= t688) || (t688 < (input.min.1 + 5)), t690, max(min(t689 + 4, t688) + -5, input.min.1))*input.stride.1) + t682)]
    }
   }
  }
  let t706 = input.extent.0 + input.min.0
  let t707 = input.extent.1 + input.min.1
  let t708 = min(casted.min.0, 2004)
  let t709 = max(t708, 5)
  let t710 = (t709 + -10)/8
  let t711 = downsampled_nn__0.s0._0.loop_extent + t710
  let t712 = max(min(casted.min.1, 1999), 0)
  let t713 = downsampled_nn__0._1.extent_realized.s + t712
  let t714 = max(min(input.min.2, 3), 0)
  let t715 = min((max(max(input.min.0 + 17, t708), 5) + -10)/8, t711)
  let t716 = max(t712 + -5, input.min.1)
  let t717 = t713 + 3
  let t703 = max(min((t706 + -1)/8, ((t709 + -18)/8) + downsampled_nn__0.s0._0.loop_extent) + 1, t715)
  let t695 = min(max(t707, t716), t717)
  let t694 = min(t716, t717)
  let t693 = max(min(input.extent.2 + input.min.2, 3), 0) - t714
  let t701 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (downsampled_nn__0.s0._2.rebased, 0, t693) {
   let t718 = t694 - t712
   let t719 = downsampled_nn__0.s0._2.rebased + t714
   for (downsampled_nn__0.s0._1.rebased, 0, t718 + 5) {
    let t722 = (input.stride.2*t719) - t701
    let t724 = (downsampled_nn__0.stride.2*t719) + ((downsampled_nn__0._0.extent_realized.s + 1)*downsampled_nn__0.s0._1.rebased)
    let t723 = ((((t712 - input.min.1) + downsampled_nn__0.s0._1.rebased) + -5) % input.extent.1) + input.min.1
    let t721 = downsampled_nn__0.s0._1.rebased + t712
    for (downsampled_nn__0.s0._0.rebased, 0, downsampled_nn__0.s0._0.loop_extent) {
     let t582 = downsampled_nn__0.s0._0.rebased + t710
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t724] = input[select((t706 <= (t582*8)) || ((t582*8) < input.min.0), (((t582*8) - input.min.0) % input.extent.0) + input.min.0, max(min(t582*8, t706 + -1), input.min.0)) + ((select(((t707 + 5) <= t721) || (t721 < (input.min.1 + 5)), t723, max(min(t707 + 4, t721) + -5, input.min.1))*input.stride.1) + t722)]
    }
   }
   let t730 = t711 - t703
   let t725 = t695 - t694
   let t728 = t694 - t712
   let t727 = downsampled_nn__0.s0._2.rebased + t714
   for (downsampled_nn__0.s0._1.rebased, 0, t725) {
    let t732 = t715 - t710
    let t733 = ((downsampled_nn__0.s0._1.rebased + t694)*input.stride.1) + ((input.stride.2*t727) - t701)
    let t734 = (downsampled_nn__0.stride.2*t727) + (((downsampled_nn__0.s0._1.rebased + t728) + 5)*(downsampled_nn__0._0.extent_realized.s + 1))
    for (downsampled_nn__0.s0._0.rebased, 0, t732) {
     let t588 = downsampled_nn__0.s0._0.rebased + t710
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t734] = input[select((t706 <= (t588*8)) || ((t588*8) < input.min.0), (((t588*8) - input.min.0) % input.extent.0) + input.min.0, max(min(t588*8, t706 + -1), input.min.0)) + t733]
    }
    let t735 = t703 - t715
    let t737 = (((downsampled_nn__0.s0._1.rebased + t728) + 5)*(downsampled_nn__0._0.extent_realized.s + 1)) + ((downsampled_nn__0.stride.2*t727) + (t715 - t710))
    let t736 = ((downsampled_nn__0.s0._1.rebased + t694)*input.stride.1) + ((input.stride.2*t727) - t701)
    for (downsampled_nn__0.s0._0.rebased, 0, t735) {
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t737] = input[((downsampled_nn__0.s0._0.rebased + t715)*8) + t736]
    }
    let t739 = (((downsampled_nn__0.s0._1.rebased + t728) + 5)*(downsampled_nn__0._0.extent_realized.s + 1)) + ((downsampled_nn__0.stride.2*t727) + (t703 - t710))
    let t738 = ((downsampled_nn__0.s0._1.rebased + t694)*input.stride.1) + ((input.stride.2*t727) - t701)
    for (downsampled_nn__0.s0._0.rebased, 0, t730) {
     let t591 = downsampled_nn__0.s0._0.rebased + t703
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t739] = input[select((t591*8) < t706, max(min(t591*8, t706 + -1), input.min.0), (((t591*8) - input.min.0) % input.extent.0) + input.min.0) + t738]
    }
   }
   let t740 = t713 - t695
   let t743 = t695 - t712
   let t741 = downsampled_nn__0.s0._2.rebased + t714
   for (downsampled_nn__0.s0._1.rebased, 0, t740 + 3) {
    let t745 = (input.stride.2*t741) - t701
    let t747 = (downsampled_nn__0.stride.2*t741) + (((downsampled_nn__0.s0._1.rebased + t743) + 5)*(downsampled_nn__0._0.extent_realized.s + 1))
    let t746 = (((t695 - input.min.1) + downsampled_nn__0.s0._1.rebased) % input.extent.1) + input.min.1
    let t744 = downsampled_nn__0.s0._1.rebased + t695
    for (downsampled_nn__0.s0._0.rebased, 0, downsampled_nn__0.s0._0.loop_extent) {
     let t597 = downsampled_nn__0.s0._0.rebased + t710
     downsampled_nn__0[downsampled_nn__0.s0._0.rebased + t747] = input[select((t706 <= (t597*8)) || ((t597*8) < input.min.0), (((t597*8) - input.min.0) % input.extent.0) + input.min.0, max(min(t597*8, t706 + -1), input.min.0)) + ((select(t744 < t707, max(min(t707 + -1, t744), input.min.1), t746)*input.stride.1) + t745)]
    }
   }
  }
  let t755 = input.extent.2 + input.min.2
  let t751 = max(min(casted.min.1, 1999), 0)
  let t753 = (max(min(casted.min.0, 2004), 5) + -10)/8
  let t748 = 3 - max(min(t755, 3), 0)
  let t754 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  for (downsampled_nn__0.s0._2.rebased, 0, t748) {
   let t756 = max(min(t755, 3), 0)
   for (downsampled_nn__0.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s + 8) {
    let t766 = (downsampled_nn__0._0.extent_realized.s + 1)*downsampled_nn__0.s0._1.rebased
    let t762 = (((t756 - input.min.2) + downsampled_nn__0.s0._2.rebased) % input.extent.2) + input.min.2
    let t764 = ((((t751 - input.min.1) + downsampled_nn__0.s0._1.rebased) + -5) % input.extent.1) + input.min.1
    let t763 = input.extent.1 + input.min.1
    let t760 = downsampled_nn__0.s0._2.rebased + t756
    let t761 = downsampled_nn__0.s0._1.rebased + t751
    for (downsampled_nn__0.s0._0.rebased, 0, downsampled_nn__0.s0._0.loop_extent) {
     let t605 = downsampled_nn__0.s0._0.rebased + t753
     let t1068 = input.extent.0 + input.min.0
     downsampled_nn__0[((downsampled_nn__0.stride.2*t760) + t766) + downsampled_nn__0.s0._0.rebased] = input[select((t1068 <= (t605*8)) || ((t605*8) < input.min.0), (((t605*8) - input.min.0) % input.extent.0) + input.min.0, max(min(t605*8, t1068 + -1), input.min.0)) + ((select(((t763 + 5) <= t761) || (t761 < (input.min.1 + 5)), t764, max(min(t763 + 4, t761) + -5, input.min.1))*input.stride.1) + ((select(t760 < t755, max(min(t755 + -1, t760), input.min.2), t762)*input.stride.2) - t754))]
    }
   }
  }
 }
 let sliced._0.extent_realized.s = max(min(casted.extent.0 + casted.min.0, 1996), -3) - max(min(casted.min.0, 2004), 5)
 allocate sliced[int32 * (sliced._0.extent_realized.s + 17) * (downsampled_nn__0._1.extent_realized.s + 8) * 1]
 produce sliced {
  consume downsampled_nn__0 {
   let sliced.s0._1.prologue = let t1069 = max(min(casted.min.1, 1999), 0) in min(max(t1069 + -5, input.min.1), (t1069 + downsampled_nn__0._1.extent_realized.s) + 3)
   let sliced.s0._1.epilogue = let t1070 = max(min(casted.min.1, 1999), 0) in min(max(max(t1070 + -5, input.min.1), input.extent.1 + input.min.1), (t1070 + downsampled_nn__0._1.extent_realized.s) + 3)
   let t774 = max(min(casted.min.1, 1999), 0)
   let t768 = max(min(casted.min.0, 2004), 5)
   let t767 = sliced.s0._1.prologue - t774
   let t773 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (sliced.s0._1.rebased, 0, t767 + 5) {
    let t782 = (sliced._0.extent_realized.s + 17)*sliced.s0._1.rebased
    let t775 = ((downsampled_nn__0._0.extent_realized.s + 1)*sliced.s0._1.rebased) - ((t768 + -10)/8)
    let t778 = ((((t774 - input.min.1) + sliced.s0._1.rebased) + -5) % input.extent.1) + input.min.1
    let t776 = sliced.s0._1.rebased + t774
    let t777 = input.extent.1 + input.min.1
    for (sliced.s0._0.rebased, 0, sliced._0.extent_realized.s + 17) {
     allocate all_r[int32 * 2]
     produce all_r {
      let t783 = sliced.s0._0.rebased + t768
      for (all_r.s0._0.rebased, 0, 2) {
       all_r[all_r.s0._0.rebased] = 0
      }
      let t786 = sliced.s0._0.rebased + t768
      let t785 = ((t786 + -10)/8) + t775
      let t784 = ((t786 + 6) % 8) + 10
      for (all_r.s1._0.rebased, 0, 2) {
       let t787 = ((t784 + -10)/8) + all_r.s1._0.rebased
       let t788 = all_r.s1._0.rebased + t785
       for (all_r.s1.r88$x, 0, 3) {
        all_r[t787] = all_r[t787] + (downsampled_nn__0[(all_r.s1.r88$x*downsampled_nn__0.stride.2) + t788]*((all_r.s1.r88$x*3) + 4))
       }
      }
     }
     consume all_r {
      let t466.s = let t1071 = (((sliced.s0._0.rebased + t768) + 6) % 8) in int16(((all_r[0]*(8 - t1071)) + (all_r[1]*t1071)))
      let t617 = max(min(int32((t466.s/(int16)16)), 2), 0)
      let t620 = sliced.s0._0.rebased + t768
      let t1072 = input.extent.0 + input.min.0
      let t1073 = input.extent.2 + input.min.2
      sliced[sliced.s0._0.rebased + t782] = input[select(((t1072 + 10) <= t620) || (t620 < (input.min.0 + 10)), ((((t768 - input.min.0) + sliced.s0._0.rebased) + -10) % input.extent.0) + input.min.0, max(min(t1072 + 9, t620) + -10, input.min.0)) + ((select((t1073 <= t617) || (t617 < input.min.2), ((t617 - input.min.2) % input.extent.2) + input.min.2, max(min(t1073 + -1, t617), input.min.2))*input.stride.2) + ((select(((t777 + 5) <= t776) || (t776 < (input.min.1 + 5)), t778, max(min(t777 + 4, t776) + -5, input.min.1))*input.stride.1) - t773))]
     }
     free all_r
    }
   }
   let t801 = input.extent.0 + input.min.0
   let t802 = input.min.2*input.stride.2
   let t803 = input.min.1*input.stride.1
   let t804 = max(min(casted.min.0, 2004), 5)
   let t805 = sliced._0.extent_realized.s + t804
   let t806 = t804 + -10
   let t807 = max(input.min.0, t806)
   let t808 = t805 + 7
   let t791 = min(max(t801, t807), t808)
   let t790 = min(t807, t808)
   let t797 = t806/8
   let t793 = sliced.s0._1.prologue - max(min(casted.min.1, 1999), 0)
   let t789 = sliced.s0._1.epilogue - sliced.s0._1.prologue
   let t796 = (t802 + t803) + input.min.0
   for (sliced.s0._1.rebased, 0, t789) {
    let t815 = (sliced.s0._1.rebased + t793) + 5
    let t814 = (sliced._0.extent_realized.s + 17)*t815
    let t810 = ((downsampled_nn__0._0.extent_realized.s + 1)*t815) - ((t804 + -10)/8)
    let t811 = ((sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1) - t796
    let t809 = t790 - t804
    for (sliced.s0._0.rebased, 0, t809 + 10) {
     allocate all_r[int32 * 2]
     produce all_r {
      let t816 = sliced.s0._0.rebased + t804
      for (all_r.s0._0.rebased, 0, 2) {
       all_r[all_r.s0._0.rebased] = 0
      }
      let t819 = sliced.s0._0.rebased + t804
      let t818 = ((t819 + -10)/8) + t810
      let t817 = ((t819 + 6) % 8) + 10
      for (all_r.s1._0.rebased, 0, 2) {
       let t820 = ((t817 + -10)/8) + all_r.s1._0.rebased
       let t821 = all_r.s1._0.rebased + t818
       for (all_r.s1.r88$x, 0, 3) {
        all_r[t820] = all_r[t820] + (downsampled_nn__0[(all_r.s1.r88$x*downsampled_nn__0.stride.2) + t821]*((all_r.s1.r88$x*3) + 4))
       }
      }
     }
     consume all_r {
      let t476.s = let t1074 = (((sliced.s0._0.rebased + t804) + 6) % 8) in int16(((all_r[0]*(8 - t1074)) + (all_r[1]*t1074)))
      let t629 = max(min(int32((t476.s/(int16)16)), 2), 0)
      let t632 = sliced.s0._0.rebased + t804
      let t1075 = input.extent.2 + input.min.2
      sliced[sliced.s0._0.rebased + t814] = input[select(((t801 + 10) <= t632) || (t632 < (input.min.0 + 10)), ((((t804 - input.min.0) + sliced.s0._0.rebased) + -10) % input.extent.0) + input.min.0, max(min(t801 + 9, t632) + -10, input.min.0)) + ((select((t1075 <= t629) || (t629 < input.min.2), ((t629 - input.min.2) % input.extent.2) + input.min.2, max(min(t1075 + -1, t629), input.min.2))*input.stride.2) + t811)]
     }
     free all_r
    }
    let t827 = (sliced.s0._1.rebased + t793) + 5
    let t823 = ((downsampled_nn__0._0.extent_realized.s + 1)*t827) - t797
    let t822 = t791 - t790
    let t826 = ((sliced._0.extent_realized.s + 17)*t827) + (t790 - t804)
    let t824 = ((sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1) + (((t790 - t802) - t803) - input.min.0)
    for (sliced.s0._0.rebased, 0, t822) {
     allocate all_r[int32 * 2]
     produce all_r {
      for (all_r.s0._0.rebased, 0, 2) {
       all_r[all_r.s0._0.rebased] = 0
      }
      let t828 = ((sliced.s0._0.rebased + t790)/8) + t823
      for (all_r.s1._0.rebased, 0, 2) {
       let t829 = all_r.s1._0.rebased + t828
       for (all_r.s1.r88$x, 0, 3) {
        all_r[all_r.s1._0.rebased] = all_r[all_r.s1._0.rebased] + (downsampled_nn__0[(all_r.s1.r88$x*downsampled_nn__0.stride.2) + t829]*((all_r.s1.r88$x*3) + 4))
       }
      }
     }
     consume all_r {
      let t480.s = let t1076 = ((sliced.s0._0.rebased + t790) % 8) in int16(((all_r[0]*(8 - t1076)) + (all_r[1]*t1076)))
      let t635 = max(min(int32((t480.s/(int16)16)), 2), 0)
      let t1077 = input.extent.2 + input.min.2
      sliced[(sliced.s0._0.rebased + t826) + 10] = input[((select((t1077 <= t635) || (t635 < input.min.2), ((t635 - input.min.2) % input.extent.2) + input.min.2, max(min(t1077 + -1, t635), input.min.2))*input.stride.2) + t824) + sliced.s0._0.rebased]
     }
     free all_r
    }
    let t836 = (sliced.s0._1.rebased + t793) + 5
    let t831 = ((downsampled_nn__0._0.extent_realized.s + 1)*t836) - t797
    let t832 = ((sliced.s0._1.prologue + sliced.s0._1.rebased)*input.stride.1) - t796
    let t830 = t805 - t791
    let t835 = ((sliced._0.extent_realized.s + 17)*t836) + (t791 - t804)
    for (sliced.s0._0.rebased, 0, t830 + 7) {
     allocate all_r[int32 * 2]
     produce all_r {
      for (all_r.s0._0.rebased, 0, 2) {
       all_r[all_r.s0._0.rebased] = 0
      }
      let t837 = ((sliced.s0._0.rebased + t791)/8) + t831
      for (all_r.s1._0.rebased, 0, 2) {
       let t838 = all_r.s1._0.rebased + t837
       for (all_r.s1.r88$x, 0, 3) {
        all_r[all_r.s1._0.rebased] = all_r[all_r.s1._0.rebased] + (downsampled_nn__0[(all_r.s1.r88$x*downsampled_nn__0.stride.2) + t838]*((all_r.s1.r88$x*3) + 4))
       }
      }
     }
     consume all_r {
      let t483.s = let t1078 = ((sliced.s0._0.rebased + t791) % 8) in int16(((all_r[0]*(8 - t1078)) + (all_r[1]*t1078)))
      let t638 = max(min(int32((t483.s/(int16)16)), 2), 0)
      let t639 = sliced.s0._0.rebased + t791
      let t1079 = input.extent.2 + input.min.2
      sliced[(sliced.s0._0.rebased + t835) + 10] = input[select(t639 < t801, max(min(t801 + -1, t639), input.min.0), (((t791 - input.min.0) + sliced.s0._0.rebased) % input.extent.0) + input.min.0) + ((select((t1079 <= t638) || (t638 < input.min.2), ((t638 - input.min.2) % input.extent.2) + input.min.2, max(min(t1079 + -1, t638), input.min.2))*input.stride.2) + t832)]
     }
     free all_r
    }
   }
   let t847 = max(min(casted.min.1, 1999), 0)
   let t840 = max(min(casted.min.0, 2004), 5)
   let t839 = (downsampled_nn__0._1.extent_realized.s + t847) - sliced.s0._1.epilogue
   let t841 = sliced.s0._1.epilogue - t847
   let t846 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
   for (sliced.s0._1.rebased, 0, t839 + 3) {
    let t856 = (sliced.s0._1.rebased + t841) + 5
    let t855 = (sliced._0.extent_realized.s + 17)*t856
    let t848 = ((downsampled_nn__0._0.extent_realized.s + 1)*t856) - ((t840 + -10)/8)
    let t851 = (((sliced.s0._1.epilogue - input.min.1) + sliced.s0._1.rebased) % input.extent.1) + input.min.1
    let t849 = sliced.s0._1.epilogue + sliced.s0._1.rebased
    let t850 = input.extent.1 + input.min.1
    for (sliced.s0._0.rebased, 0, sliced._0.extent_realized.s + 17) {
     allocate all_r[int32 * 2]
     produce all_r {
      let t857 = sliced.s0._0.rebased + t840
      for (all_r.s0._0.rebased, 0, 2) {
       all_r[all_r.s0._0.rebased] = 0
      }
      let t860 = sliced.s0._0.rebased + t840
      let t859 = ((t860 + -10)/8) + t848
      let t858 = ((t860 + 6) % 8) + 10
      for (all_r.s1._0.rebased, 0, 2) {
       let t861 = ((t858 + -10)/8) + all_r.s1._0.rebased
       let t862 = all_r.s1._0.rebased + t859
       for (all_r.s1.r88$x, 0, 3) {
        all_r[t861] = all_r[t861] + (downsampled_nn__0[(all_r.s1.r88$x*downsampled_nn__0.stride.2) + t862]*((all_r.s1.r88$x*3) + 4))
       }
      }
     }
     consume all_r {
      let t490.s = let t1080 = (((sliced.s0._0.rebased + t840) + 6) % 8) in int16(((all_r[0]*(8 - t1080)) + (all_r[1]*t1080)))
      let t649 = max(min(int32((t490.s/(int16)16)), 2), 0)
      let t652 = sliced.s0._0.rebased + t840
      let t1081 = input.extent.0 + input.min.0
      let t1082 = input.extent.2 + input.min.2
      sliced[sliced.s0._0.rebased + t855] = input[select(((t1081 + 10) <= t652) || (t652 < (input.min.0 + 10)), ((((t840 - input.min.0) + sliced.s0._0.rebased) + -10) % input.extent.0) + input.min.0, max(min(t1081 + 9, t652) + -10, input.min.0)) + ((select((t1082 <= t649) || (t649 < input.min.2), ((t649 - input.min.2) % input.extent.2) + input.min.2, max(min(t1082 + -1, t649), input.min.2))*input.stride.2) + ((select(t849 < t850, max(min(t850 + -1, t849), input.min.1), t851)*input.stride.1) - t846))]
     }
     free all_r
    }
   }
   free downsampled_nn__0
  }
 }
 allocate all_r$1[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 24]
 produce all_r$1 {
  let t863 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
  for (all_r$1.s0._2, 0, 24) {
   let t864 = all_r$1.s0._2*t863
   for (all_r$1.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
    let t865 = ((sliced._0.extent_realized.s + 9)*all_r$1.s0._1.rebased) + t864
    for (all_r$1.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
     all_r$1[all_r$1.s0._0.rebased + t865] = 0
    }
   }
  }
  consume sliced {
   let t866 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
   for (all_r$1.s1._2, 0, 24) {
    let t867 = all_r$1.s1._2*t866
    for (all_r$1.s1._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
     let t869 = (all_r$1.s1._1.rebased + 5)*(sliced._0.extent_realized.s + 17)
     let t868 = ((sliced._0.extent_realized.s + 9)*all_r$1.s1._1.rebased) + t867
     for (all_r$1.s1._0.rebased, 0, sliced._0.extent_realized.s + 9) {
      let t495.s = all_r$1.s1._0.rebased + t868
      all_r$1[t495.s] = all_r$1[t495.s] + (sliced[(all_r$1.s1._0.rebased + t869) + 5]*(all_r$1.s1._2 + 2))
     }
    }
   }
  }
 }
 allocate constant_exterior[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 24]
 produce constant_exterior {
  consume all_r$1 {
   let t878 = min(casted.min.0, 2004)
   let t879 = max(t878, 5)
   let t880 = sliced._0.extent_realized.s + t879
   let t881 = min(casted.min.1, 1999)
   let t882 = max(t881, 0)
   let t883 = downsampled_nn__0._1.extent_realized.s + t882
   let t884 = max(t880 + 3, t881)
   let t875 = max(min(t880, 1996) + 9, t878)
   let t871 = min(max(t884, 2000), t883)
   let t870 = min(max(t884, 0), t883)
   let t874 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
   for (constant_exterior.s0._2, 0, 24) {
    let t886 = constant_exterior.s0._2*t874
    let t885 = t870 - t882
    for (constant_exterior.s0._1.rebased, 0, t885) {
     let t893 = sliced._0.extent_realized.s + 9
     let t890 = (min(1999 - t882, constant_exterior.s0._1.rebased)*t893) + t886
     let t892 = (constant_exterior.s0._1.rebased*t893) + t886
     let t889 = constant_exterior.s0._1.rebased + t882
     for (constant_exterior.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
      constant_exterior[constant_exterior.s0._0.rebased + t892] = select(max((constant_exterior.s0._0.rebased + t879) + -5, t889) < 2000, all_r$1[min(2004 - t879, constant_exterior.s0._0.rebased) + t890], 0)
     }
    }
    let t899 = max(t875, 5)
    let t896 = constant_exterior.s0._2*t874
    let t895 = t899 - t879
    let t898 = t880 - t899
    let t894 = t871 - t870
    let t897 = t870 - t882
    for (constant_exterior.s0._1.rebased, 0, t894) {
     let t900 = ((constant_exterior.s0._1.rebased + t897)*(sliced._0.extent_realized.s + 9)) + t896
     for (constant_exterior.s0._0.rebased, 0, t895) {
      let t502.s = constant_exterior.s0._0.rebased + t900
      constant_exterior[t502.s] = all_r$1[t502.s]
     }
     let t901 = (constant_exterior.s0._1.rebased + t897)*(sliced._0.extent_realized.s + 9)
     let t902 = t896 - t879
     let t903 = t895 + t896
     for (constant_exterior.s0._0.rebased, 0, t898 + 9) {
      constant_exterior[(t901 + t903) + constant_exterior.s0._0.rebased] = all_r$1[(t901 + t902) + 2004]
     }
    }
    let t905 = constant_exterior.s0._2*t874
    let t904 = t883 - t871
    for (constant_exterior.s0._1.rebased, 0, t904) {
     let t910 = (((t871 - t882) + constant_exterior.s0._1.rebased)*(sliced._0.extent_realized.s + 9)) + t905
     let t908 = constant_exterior.s0._1.rebased + t871
     for (constant_exterior.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
      constant_exterior[constant_exterior.s0._0.rebased + t910] = select(max((constant_exterior.s0._0.rebased + t879) + -5, t908) < 2000, all_r$1[min(2004 - t879, constant_exterior.s0._0.rebased) + (((min(t908, 1999) - t882)*(sliced._0.extent_realized.s + 9)) + t905)], 0)
     }
    }
   }
  }
 }
 free all_r$1
 allocate all_r$2[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 20]
 produce all_r$2 {
  let t911 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
  for (all_r$2.s0._2, 0, 20) {
   let t912 = all_r$2.s0._2*t911
   for (all_r$2.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
    let t913 = ((sliced._0.extent_realized.s + 9)*all_r$2.s0._1.rebased) + t912
    for (all_r$2.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
     all_r$2[all_r$2.s0._0.rebased + t913] = 0
    }
   }
  }
  consume constant_exterior {
   let t914 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
   for (all_r$2.s1._2, 0, 20) {
    for (all_r$2.s1._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
     let t918 = (sliced._0.extent_realized.s + 9)*all_r$2.s1._1.rebased
     let t916 = (all_r$2.s1._2*t914) + t918
     for (all_r$2.s1._0.rebased, 0, sliced._0.extent_realized.s + 9) {
      let t920 = all_r$2.s1._0.rebased + t918
      let t919 = all_r$2.s1._0.rebased + t916
      for (all_r$2.s1.r128$x, 0, 24) {
       all_r$2[t919] = all_r$2[t919] + (constant_exterior[(all_r$2.s1.r128$x*t914) + t920]*(((all_r$2.s1.r128$x*24) + all_r$2.s1._2) + 25))
      }
     }
    }
   }
  }
 }
 allocate binary_op$1[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 20]
 produce binary_op$1 {
  consume all_r$2 {
   consume sliced {
    let t921 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
    for (binary_op$1.s0._2, 0, 20) {
     let t922 = binary_op$1.s0._2*t921
     for (binary_op$1.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
      let t923 = (binary_op$1.s0._1.rebased + 5)*(sliced._0.extent_realized.s + 17)
      let t924 = ((sliced._0.extent_realized.s + 9)*binary_op$1.s0._1.rebased) + t922
      for (binary_op$1.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
       allocate all_r$4[int32 * 1]
       produce all_r$4 {
        all_r$4[0] = 0
        all_r$4[0] = all_r$4[0] + (sliced[(binary_op$1.s0._0.rebased + t923) + 5]*(binary_op$1.s0._2 + 2))
       }
       consume all_r$4 {
        let t512.s = binary_op$1.s0._0.rebased + t924
        let t513 = all_r$2[t512.s]
        binary_op$1[t512.s] = (all_r$4[0] + t513)/t513
       }
       free all_r$4
      }
     }
    }
   }
  }
 }
 free all_r$2
 allocate conv2D__0_1[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 19]
 produce conv2D__0_1 {
  consume sliced {
   let t931 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
   for (conv2D__0_1.s0._2, 0, 19) {
    let t938 = conv2D__0_1.s0._2*t931
    for (conv2D__0_1.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
     let t939 = (conv2D__0_1.s0._1.rebased + 5)*(sliced._0.extent_realized.s + 17)
     let t946 = ((sliced._0.extent_realized.s + 9)*conv2D__0_1.s0._1.rebased) + t938
     for (conv2D__0_1.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
      let t517.s = ((sliced._0.extent_realized.s*3) + t939) + conv2D__0_1.s0._0.rebased
      let t518.s = ((sliced._0.extent_realized.s*2) + t939) + conv2D__0_1.s0._0.rebased
      let t521.s = ((sliced._0.extent_realized.s*-2) + t939) + conv2D__0_1.s0._0.rebased
      let t522.s = ((sliced._0.extent_realized.s*-3) + t939) + conv2D__0_1.s0._0.rebased
      let t523.s = ((sliced._0.extent_realized.s*-4) + t939) + conv2D__0_1.s0._0.rebased
      let t524.s = ((sliced._0.extent_realized.s*-5) + t939) + conv2D__0_1.s0._0.rebased
      let t665 = (sliced._0.extent_realized.s + t939) + conv2D__0_1.s0._0.rebased
      let t666 = conv2D__0_1.s0._0.rebased + t939
      let t667 = (t939 - sliced._0.extent_realized.s) + conv2D__0_1.s0._0.rebased
      conv2D__0_1[conv2D__0_1.s0._0.rebased + t946] = sliced[t523.s + -68] + (sliced[t524.s + -85] + (sliced[t522.s + -51] + (sliced[t521.s + -34] + (sliced[t667 + -17] + (sliced[t666] + (sliced[t665 + 17] + (sliced[t518.s + 34] + (sliced[t517.s + 51] + (sliced[t524.s + -84] + (sliced[t523.s + -67] + (sliced[t522.s + -50] + (sliced[t521.s + -33] + (sliced[t667 + -16] + (sliced[t666 + 1] + (sliced[t665 + 18] + (sliced[t518.s + 35] + (sliced[t517.s + 52] + (sliced[t524.s + -83] + (sliced[t523.s + -66] + (sliced[t522.s + -49] + (sliced[t521.s + -32] + (sliced[t667 + -15] + (sliced[t666 + 2] + (sliced[t665 + 19] + (sliced[t518.s + 36] + (sliced[t517.s + 53] + (sliced[t524.s + -82] + (sliced[t523.s + -65] + (sliced[t522.s + -48] + (sliced[t521.s + -31] + (sliced[t667 + -14] + (sliced[t666 + 3] + (sliced[t665 + 20] + (sliced[t518.s + 37] + (sliced[t517.s + 54] + (sliced[t524.s + -81] + (sliced[t523.s + -64] + (sliced[t522.s + -47] + (sliced[t521.s + -30] + (sliced[t667 + -13] + (sliced[t666 + 4] + (sliced[t665 + 21] + (sliced[t518.s + 38] + (sliced[t517.s + 55] + (sliced[t524.s + -80] + (sliced[t523.s + -63] + (sliced[t522.s + -46] + (sliced[t521.s + -29] + (sliced[t667 + -12] + (sliced[t666 + 5] + (sliced[t665 + 22] + (sliced[t518.s + 39] + (sliced[t517.s + 56] + (sliced[t524.s + -79] + (sliced[t523.s + -62] + (sliced[t522.s + -45] + (sliced[t521.s + -28] + (sliced[t667 + -11] + (sliced[t666 + 6] + (sliced[t665 + 23] + (sliced[t518.s + 40] + (sliced[t517.s + 57] + (sliced[t524.s + -78] + (sliced[t523.s + -61] + (sliced[t522.s + -44] + (sliced[t521.s + -27] + (sliced[t667 + -10] + (sliced[t666 + 7] + (sliced[t665 + 24] + (sliced[t518.s + 41] + (sliced[t517.s + 58] + (sliced[t524.s + -77] + (sliced[t523.s + -60] + (sliced[t522.s + -43] + (sliced[t521.s + -26] + (sliced[t667 + -9] + (sliced[t666 + 8] + (sliced[t665 + 25] + (sliced[t517.s + 59] + sliced[t518.s + 42])))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
     }
    }
   }
  }
 }
 free sliced
 allocate binary_op[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 24]
 produce binary_op {
  consume conv2D__0_1 {
   consume constant_exterior {
    let t947 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
    for (binary_op.s0._2, 0, 24) {
     for (binary_op.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
      let t951 = (sliced._0.extent_realized.s + 9)*binary_op.s0._1.rebased
      let t950 = (binary_op.s0._2*t947) + t951
      for (binary_op.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
       allocate all_r$3[int32 * 1]
       produce all_r$3 {
        all_r$3[0] = 0
        let t952 = binary_op.s0._0.rebased + t951
        for (all_r$3.s1.r139$x, 0, 19) {
         all_r$3[0] = all_r$3[0] + (conv2D__0_1[(all_r$3.s1.r139$x*t947) + t952]*(((all_r$3.s1.r139$x*19) + binary_op.s0._2) + 20))
        }
       }
       consume all_r$3 {
        let t525.s = binary_op.s0._0.rebased + t950
        binary_op[t525.s] = max(constant_exterior[t525.s], all_r$3[0])
       }
       free all_r$3
      }
     }
    }
   }
  }
 }
 free constant_exterior
 free conv2D__0_1
 allocate binary_op$2[int32 * (sliced._0.extent_realized.s + 9) * downsampled_nn__0._1.extent_realized.s * 24]
 produce binary_op$2 {
  consume binary_op {
   consume binary_op$1 {
    let t953 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
    for (binary_op$2.s0._2, 0, 24) {
     for (binary_op$2.s0._1.rebased, 0, downsampled_nn__0._1.extent_realized.s) {
      let t957 = (sliced._0.extent_realized.s + 9)*binary_op$2.s0._1.rebased
      let t956 = (binary_op$2.s0._2*t953) + t957
      for (binary_op$2.s0._0.rebased, 0, sliced._0.extent_realized.s + 9) {
       allocate all_r$5[int32 * 1]
       produce all_r$5 {
        all_r$5[0] = 0
        let t958 = binary_op$2.s0._0.rebased + t957
        for (all_r$5.s1.r189$x, 0, 20) {
         all_r$5[0] = all_r$5[0] + (binary_op$1[(all_r$5.s1.r189$x*t953) + t958]*(((all_r$5.s1.r189$x*20) + binary_op$2.s0._2) + 21))
        }
       }
       consume all_r$5 {
        let t526.s = binary_op$2.s0._0.rebased + t956
        let t527 = all_r$5[0]
        binary_op$2[t526.s] = max(binary_op[t526.s] % t527, t527)
       }
       free all_r$5
      }
     }
    }
   }
  }
 }
 free binary_op$1
 free binary_op
 allocate constant_exterior$1[int32 * (casted.extent.0 + 9) * casted.extent.1 * 24]
 produce constant_exterior$1 {
  consume binary_op$2 {
   let t969 = casted.extent.0 + casted.min.0
   let t970 = casted.extent.1 + casted.min.1
   let t971 = min(max(casted.min.0, 5), t969 + 9)
   let t966 = max(min(t969, 1996) + 9, t971)
   let t963 = max(min(casted.min.1, 1999), 0)
   let t962 = max(min(casted.min.0, 2004), 5)
   let t960 = min(max(casted.min.1, 2000), t970)
   let t959 = min(max(casted.min.1, 0), t970)
   let t961 = (sliced._0.extent_realized.s + 9)*downsampled_nn__0._1.extent_realized.s
   let t964 = (casted.extent.0 + 9)*casted.extent.1
   for (constant_exterior$1.s0._2, 0, 24) {
    let t974 = constant_exterior$1.s0._2*t964
    let t973 = (constant_exterior$1.s0._2*t961) - t962
    let t972 = t959 - casted.min.1
    for (constant_exterior$1.s0._1.rebased, 0, t972) {
     let t976 = ((casted.extent.0 + 9)*constant_exterior$1.s0._1.rebased) + t974
     let t975 = casted.min.1 + constant_exterior$1.s0._1.rebased
     for (constant_exterior$1.s0._0.rebased, 0, casted.extent.0 + 9) {
      let t668 = casted.min.0 + constant_exterior$1.s0._0.rebased
      constant_exterior$1[constant_exterior$1.s0._0.rebased + t976] = select(((2005 <= t668) || (t668 < 5)) || (t975 < 0), 0, binary_op$2[max(min(t668, 2004), 5) + (((max(t975, 0) - t963)*(sliced._0.extent_realized.s + 9)) + t973)])
     }
    }
    let t988 = constant_exterior$1.s0._2*t961
    let t989 = constant_exterior$1.s0._2*t964
    let t990 = t971 - casted.min.0
    let t979 = t988 - t962
    let t986 = t969 - t966
    let t983 = t966 - t971
    let t977 = t960 - t959
    let t980 = t959 - t963
    let t982 = t959 - casted.min.1
    let t987 = (t966 - casted.min.0) + t989
    let t984 = (t971 - t962) + t988
    for (constant_exterior$1.s0._1.rebased, 0, t977) {
     let t992 = ((constant_exterior$1.s0._1.rebased + t982)*(casted.extent.0 + 9)) + t989
     let t991 = ((constant_exterior$1.s0._1.rebased + t980)*(sliced._0.extent_realized.s + 9)) + t979
     for (constant_exterior$1.s0._0.rebased, 0, t990) {
      let t671 = casted.min.0 + constant_exterior$1.s0._0.rebased
      constant_exterior$1[constant_exterior$1.s0._0.rebased + t992] = select(t671 < 5, 0, binary_op$2[max(t671, 5) + t991])
     }
     let t994 = ((constant_exterior$1.s0._1.rebased + t982)*(casted.extent.0 + 9)) + (t989 + t990)
     let t993 = ((constant_exterior$1.s0._1.rebased + t980)*(sliced._0.extent_realized.s + 9)) + t984
     for (constant_exterior$1.s0._0.rebased, 0, t983) {
      constant_exterior$1[constant_exterior$1.s0._0.rebased + t994] = binary_op$2[constant_exterior$1.s0._0.rebased + t993]
     }
     let t996 = ((constant_exterior$1.s0._1.rebased + t982)*(casted.extent.0 + 9)) + t987
     let t995 = ((constant_exterior$1.s0._1.rebased + t980)*(sliced._0.extent_realized.s + 9)) + t979
     for (constant_exterior$1.s0._0.rebased, 0, t986 + 9) {
      let t672 = constant_exterior$1.s0._0.rebased + t966
      constant_exterior$1[constant_exterior$1.s0._0.rebased + t996] = select(t672 < 2005, binary_op$2[max(min(t672, 2004), 5) + t995], 0)
     }
    }
    let t999 = constant_exterior$1.s0._2*t964
    let t998 = (constant_exterior$1.s0._2*t961) - t962
    let t997 = t970 - t960
    let t1000 = t960 - casted.min.1
    for (constant_exterior$1.s0._1.rebased, 0, t997) {
     let t1002 = ((constant_exterior$1.s0._1.rebased + t1000)*(casted.extent.0 + 9)) + t999
     let t1001 = constant_exterior$1.s0._1.rebased + t960
     for (constant_exterior$1.s0._0.rebased, 0, casted.extent.0 + 9) {
      let t673 = casted.min.0 + constant_exterior$1.s0._0.rebased
      constant_exterior$1[constant_exterior$1.s0._0.rebased + t1002] = select(((2005 <= t673) || (t673 < 5)) || (2000 <= t1001), 0, binary_op$2[max(min(t673, 2004), 5) + (((max(min(t1001, 1999), 0) - t963)*(sliced._0.extent_realized.s + 9)) + t998)])
     }
    }
   }
  }
 }
 free binary_op$2
 allocate all_r$7[int32 * (casted.extent.0 + 9) * casted.extent.1 * 5]
 produce all_r$7 {
  let t1003 = (casted.extent.0 + 9)*casted.extent.1
  for (all_r$7.s0._2, 0, 5) {
   let t1004 = all_r$7.s0._2*t1003
   for (all_r$7.s0._1.rebased, 0, casted.extent.1) {
    let t1005 = ((casted.extent.0 + 9)*all_r$7.s0._1.rebased) + t1004
    for (all_r$7.s0._0.rebased, 0, casted.extent.0 + 9) {
     all_r$7[all_r$7.s0._0.rebased + t1005] = 0
    }
   }
  }
  consume constant_exterior$1 {
   let t1006 = (casted.extent.0 + 9)*casted.extent.1
   for (all_r$7.s1._2, 0, 5) {
    for (all_r$7.s1._1.rebased, 0, casted.extent.1) {
     let t1010 = (casted.extent.0 + 9)*all_r$7.s1._1.rebased
     let t1008 = (all_r$7.s1._2*t1006) + t1010
     for (all_r$7.s1._0.rebased, 0, casted.extent.0 + 9) {
      let t1012 = all_r$7.s1._0.rebased + t1010
      let t1011 = all_r$7.s1._0.rebased + t1008
      for (all_r$7.s1.r248$x, 0, 24) {
       all_r$7[t1011] = all_r$7[t1011] + (constant_exterior$1[(all_r$7.s1.r248$x*t1006) + t1012]*(((all_r$7.s1.r248$x*24) + all_r$7.s1._2) + 25))
      }
     }
    }
   }
  }
  free constant_exterior$1
 }
 allocate conv_w__0[int32 * casted.extent.0 * casted.extent.1 * 5]
 produce conv_w__0 {
  consume all_r$7 {
   let t1013 = (casted.extent.0 + 9)*casted.extent.1
   for (conv_w__0.s0._2, 0, 5) {
    let t1016 = (casted.extent.0*casted.extent.1)*conv_w__0.s0._2
    let t1015 = conv_w__0.s0._2*t1013
    for (conv_w__0.s0._1.rebased, 0, casted.extent.1) {
     let t1017 = ((casted.extent.0 + 9)*conv_w__0.s0._1.rebased) + t1015
     let t1018 = (casted.extent.0*conv_w__0.s0._1.rebased) + t1016
     for (conv_w__0.s0._0.rebased, 0, casted.extent.0) {
      allocate sum$2[int32 * 1]
      produce sum$2 {
       sum$2[0] = 0
       let t1019 = conv_w__0.s0._0.rebased + t1017
       for (sum$2.s1.r259$x.rebased, 0, 10) {
        sum$2[0] = sum$2[0] + (all_r$7[sum$2.s1.r259$x.rebased + t1019]*47)
       }
      }
      consume sum$2 {
       conv_w__0[conv_w__0.s0._0.rebased + t1018] = sum$2[0]
      }
      free sum$2
     }
    }
   }
  }
 }
 free all_r$7
 produce casted {
  consume conv_w__0 {
   let t1021 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t1025 = casted.min.2 + casted.s0._2.rebased
    let t1024 = (casted.stride.2*t1025) + t1021
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t1026 = casted.extent.0*casted.s0._1.rebased
     let t1027 = casted.extent.0*casted.extent.1
     let t1028 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t1024
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$8[int32 * 1]
      produce all_r$8 {
       all_r$8[0] = 0
       let t1029 = casted.s0._0.rebased + t1026
       for (all_r$8.s1.r281$x, 0, 5) {
        all_r$8[0] = all_r$8[0] + (conv_w__0[(all_r$8.s1.r281$x*t1027) + t1029]*(((all_r$8.s1.r281$x*5) + t1025) + 6))
       }
      }
      consume all_r$8 {
       casted[casted.s0._0.rebased + t1028] = all_r$8[0]
      }
      free all_r$8
     }
    }
   }
  }
 }
 free conv_w__0
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.1 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.0 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(input.extent.2 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t513 != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 0)
Original expression:
(t527 != 0)
add_temp_object_file: /tmp/O9JCAd/random_pipeline.a.o
Module.compile(): temporary object /tmp/O9JCAd/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50001_0/random_pipeline.a
file_unlink: /tmp/O9JCAd/random_pipeline.a.o
dir_rmdir: /tmp/O9JCAd
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50001_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50001_0/random_pipeline.registration.cpp
