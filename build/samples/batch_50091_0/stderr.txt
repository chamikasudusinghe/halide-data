Generator random_pipeline has base_path /home/chamika2/upstream/halide-data/build/samples/batch_50091_0/random_pipeline
compile_multitarget: single target is x86-64-linux-avx-avx2-avx512-avx512_cannonlake-avx512_sapphirerapids-avx512_skylake-f16c-fma-no_runtime-sse41
In random expression: 0
The following expressions were unused:
upsampled_linear__1(_0, _1, _2)
upsampled_nn__1(_0, _1, _2)
(let t13 = upsampled_nn__1(_0, _1, _2) in (let t14 = upsampled_linear__1(_0, _1, _2) in int32(((t13 < t14) || uint1(t14)))))
min(upsampled_linear__1(_0, _1, _2), upsampled_linear__1$1(_0, _1, _2))
In random expression: (let t22 = upsampled_linear__1$2(_0, _1, _2) in select(t22 == 0, 0, 1))
The following expressions were unused:
upsampled_linear__1(_0, _1, _2)
In random expression: int32(int16((upsampled_linear__1$2(_0, _1, _2) + 1)))
The following expressions were unused:
upsampled_linear__1(_0, _1, _2)
(let t24 = upsampled_linear__1(_0, _1, _2) in (min(upsampled_linear__1$2(_0, _1, _2), 0) + t24))
(let t25 = binary_op$2(_0, _1, _2) in max(min(binary_op$1(_0, _1, _2), t25*t25), 0))
Applying autoscheduler (NONE) to Generator random_pipeline ...
Creating initial loop nests...
Injecting realization of { casted }
Injecting realization of { all_r$5 }
Inlining downsampled_box__1
Injecting realization of { upsampled_nn__1$1 }
Injecting realization of { sliced }
Injecting realization of { all_r$4 }
Inlining downsampled_nn__1$1
Injecting realization of { constant_exterior }
Inlining repeat_edge$6
Injecting realization of { binary_op$3 }
Injecting realization of { binary_op$2 }
Inlining upsampled_linear__1$2
Injecting realization of { all_r$2 }
Injecting realization of { binary_op$1 }
Inlining upsampled_linear__1$1
Injecting realization of { all_r$1 }
Injecting realization of { upsampled_linear__1 }
Injecting realization of { conv2D_w__0_1 }
Injecting realization of { sum }
Inlining repeat_edge$5
Inlining lambda_6
Inlining int32_weights_im
Inlining mirror_interior
Inlining lambda_0
Inlining input_im
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: (min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) - min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$1.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2) + 2) + all_r$1.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$1.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: (min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) - min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Warning: expression is non-monotonic in loop variable binary_op$2.s0._1.rebased: ((min(max((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2, max(input.extent.1, 0) + input.min.1), ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2) + 2) + all_r$2.s1._1.rebased) - ((max(min(casted.min.1*2, 3999), 0) + binary_op$2.s0._1.rebased)/2))
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Extracting tile operations...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)int32_weights.buffer) != (uint64)0, halide_error_buffer_argument_is_null("int32_weights"))
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)casted.buffer) != (uint64)0, halide_error_buffer_argument_is_null("casted"))
let casted = (void *)_halide_buffer_get_host((struct halide_buffer_t *)casted.buffer)
let casted.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)casted.buffer)
let casted.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)casted.buffer)
let casted.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)casted.buffer)
let casted.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 0)
let casted.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 0)
let casted.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 0)
let casted.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 1)
let casted.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 1)
let casted.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 1)
let casted.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)casted.buffer, 2)
let casted.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)casted.buffer, 2)
let casted.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)casted.buffer, 2)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 2)
let int32_weights = (void *)_halide_buffer_get_host((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)int32_weights.buffer)
let int32_weights.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 0)
let int32_weights.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 1)
let int32_weights.min.2 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.extent.2 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.stride.2 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 2)
let int32_weights.min.3 = _halide_buffer_get_min((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.extent.3 = _halide_buffer_get_extent((struct halide_buffer_t *)int32_weights.buffer, 3)
let int32_weights.stride.3 = _halide_buffer_get_stride((struct halide_buffer_t *)int32_weights.buffer, 3)
let conv2D_w__0_1.s0._1.max = let t2150 = (casted.extent.1 + casted.min.1) in max((max(min(t2150*2, 3999), 0)/2) + 1, t2150)
let conv2D_w__0_1.s0._1.min = min(max(min(casted.min.1*2, 3999), 0)/2, casted.min.1)
let input.extent.0.required.s = let t2151 = (input.extent.0 + input.min.0) in (let t2152 = (casted.extent.0 + casted.min.0) in (let t2153 = max(min(t2152, 2000), 1) in (let t2154 = min(casted.min.0, 1999) in (let t2155 = max(t2154, 0) in (let t2156 = (((t2151 + 1) <= t2153) || (t2155 < input.min.0)) in (let t2157 = max(min(t2153, t2151) + -1, input.min.0) in (let t2158 = ((t2151 <= t2155) || (t2153 < (input.min.0 + 1))) in (let t2159 = max(t2152, 1) in (let t2160 = (((t2151 + 1) <= t2154) || (t2159 < input.min.0)) in (let t2161 = max(min(t2159, t2151 + -1), input.min.0) in (let t2162 = ((t2151 <= t2159) || (t2154 < (input.min.0 + 1))) in (let t2163 = (input.min.0 + (input.extent.0 - int32(max(uint32((input.extent.0 + -1)), uint32(((max(1 - (input.extent.0*2), max(input.extent.0*2, 3) + -3) - input.extent.0) + 1)))))) in (let t2164 = max(min(t2155, t2151 + -1), input.min.0) in (let t2165 = max(min(min(t2151, casted.min.0), 1999) + -1, input.min.0) in (max(select(t2156, t2151 + -1, t2157), max(select(t2158, t2151 + -1, t2157), max(select(t2160, t2151 + -1, t2161), select(t2162, t2151 + -1, t2161)))) - min(select(t2156, t2163 + -1, t2164), min(select(t2158, t2163 + -1, t2164), min(select(t2160, t2163 + -1, t2165), select(t2162, t2163 + -1, t2165)))))))))))))))))))
let input.min.0.required = let t2166 = (input.extent.0 + input.min.0) in (let t2167 = (casted.extent.0 + casted.min.0) in (let t2168 = max(min(t2167, 2000), 1) in (let t2169 = min(casted.min.0, 1999) in (let t2170 = max(t2169, 0) in (let t2171 = (input.min.0 + (input.extent.0 - int32(max(uint32((input.extent.0 + -1)), uint32(((max(1 - (input.extent.0*2), max(input.extent.0*2, 3) + -3) - input.extent.0) + 1)))))) in (let t2172 = max(min(t2170, t2166 + -1), input.min.0) in (let t2173 = max(t2167, 1) in (let t2174 = max(min(min(t2166, casted.min.0), 1999) + -1, input.min.0) in min(select(((t2166 + 1) <= t2168) || (t2170 < input.min.0), t2171 + -1, t2172), min(select((t2166 <= t2170) || (t2168 < (input.min.0 + 1)), t2171 + -1, t2172), min(select(((t2166 + 1) <= t2169) || (t2173 < input.min.0), t2171 + -1, t2174), select((t2166 <= t2173) || (t2169 < (input.min.0 + 1)), t2171 + -1, t2174))))))))))))
let input.extent.1.required.s = let t2175 = (input.extent.1 + input.min.1) in (let t2176 = max(min((casted.extent.1 + casted.min.1)*2, 3999), 0) in (let t2177 = max(min(casted.min.1*2, 3999), 0) in (let t2178 = (((t2175 + -1) <= (t2176/2)) || ((t2177/2) < input.min.1)) in (let t2179 = max(min((t2176/2) + 2, t2175) + -1, input.min.1) in (let t2180 = ((t2175 <= (t2177/2)) || ((t2176/2) < (input.min.1 + -1))) in (let t2181 = (((t2175 + 1) <= conv2D_w__0_1.s0._1.min) || (conv2D_w__0_1.s0._1.max < (input.min.1 + -1))) in (let t2182 = max(min(conv2D_w__0_1.s0._1.max + 2, t2175) + -1, input.min.1) in (let t2183 = (((t2175 + -1) <= conv2D_w__0_1.s0._1.max) || (conv2D_w__0_1.s0._1.min < (input.min.1 + 1))) in (let t2184 = (input.min.1 + (input.extent.1 - int32(max(uint32((input.extent.1 + -1)), uint32(((max(1 - (input.extent.1*2), max(input.extent.1*2, 3) + -3) - input.extent.1) + 1)))))) in (let t2185 = max(min(t2177/2, t2175 + -1), input.min.1) in (let t2186 = max(min(t2175, conv2D_w__0_1.s0._1.min) + -1, input.min.1) in (max(select(t2178, t2175 + -1, t2179), max(select(t2180, t2175 + -1, t2179), max(select(t2181, t2175 + -1, t2182), select(t2183, t2175 + -1, t2182)))) - min(select(t2178, t2184 + -1, t2185), min(select(t2180, t2184 + -1, t2185), min(select(t2181, t2184 + -1, t2186), select(t2183, t2184 + -1, t2186))))))))))))))))
let input.min.1.required = let t2187 = (input.extent.1 + input.min.1) in (let t2188 = max(min((casted.extent.1 + casted.min.1)*2, 3999), 0) in (let t2189 = max(min(casted.min.1*2, 3999), 0) in (let t2190 = (input.min.1 + (input.extent.1 - int32(max(uint32((input.extent.1 + -1)), uint32(((max(1 - (input.extent.1*2), max(input.extent.1*2, 3) + -3) - input.extent.1) + 1)))))) in (let t2191 = max(min(t2189/2, t2187 + -1), input.min.1) in (let t2192 = max(min(t2187, conv2D_w__0_1.s0._1.min) + -1, input.min.1) in min(select(((t2187 + -1) <= (t2188/2)) || ((t2189/2) < input.min.1), t2190 + -1, t2191), min(select((t2187 <= (t2189/2)) || ((t2188/2) < (input.min.1 + -1)), t2190 + -1, t2191), min(select(((t2187 + 1) <= conv2D_w__0_1.s0._1.min) || (conv2D_w__0_1.s0._1.max < (input.min.1 + -1)), t2190 + -1, t2192), select(((t2187 + -1) <= conv2D_w__0_1.s0._1.max) || (conv2D_w__0_1.s0._1.min < (input.min.1 + 1)), t2190 + -1, t2192)))))))))
let input.extent.2.required.s = let t2193 = (input.extent.2 + input.min.2) in (let t2194 = ((t2193 <= 0) || (2 < input.min.2)) in (let t2195 = max(min(t2193, 3) + -1, input.min.2) in (let t2196 = ((t2193 <= 2) || (0 < input.min.2)) in (let t2197 = (input.min.2 + (input.extent.2 - int32(max(uint32((input.extent.2 + -1)), uint32(((max(1 - (input.extent.2*2), max(input.extent.2*2, 3) + -3) - input.extent.2) + 1)))))) in (let t2198 = max(min(t2193, 1) + -1, input.min.2) in (max(select(t2194, t2193 + -1, t2195), select(t2196, t2193 + -1, t2195)) - min(select(t2194, t2197 + -1, t2198), select(t2196, t2197 + -1, t2198))))))))
let input.min.2.required = let t2199 = (input.extent.2 + input.min.2) in (let t2200 = (input.min.2 + (input.extent.2 - int32(max(uint32((input.extent.2 + -1)), uint32(((max(1 - (input.extent.2*2), max(input.extent.2*2, 3) + -3) - input.extent.2) + 1)))))) in (let t2201 = max(min(t2199, 1) + -1, input.min.2) in min(select((t2199 <= 0) || (2 < input.min.2), t2200 + -1, t2201), select((t2199 <= 2) || (0 < input.min.2), t2200 + -1, t2201))))
let input.stride.2.required = (input.extent.0.required.s + 1)*(input.extent.1.required.s + 1)
let int32_weights.extent.0.required.s = let t2202 = (int32_weights.extent.0 + int32_weights.min.0) in (min(t2202, 3) - max(min(t2202, 1) + -1, int32_weights.min.0))
let int32_weights.min.0.required = max(min(int32_weights.extent.0 + int32_weights.min.0, 1) + -1, int32_weights.min.0)
let int32_weights.extent.1.required.s = let t2203 = (int32_weights.extent.1 + int32_weights.min.1) in (min(t2203, 2) - max(min(t2203, 0) + -1, int32_weights.min.1))
let int32_weights.min.1.required = max(min(int32_weights.extent.1 + int32_weights.min.1, 0) + -1, int32_weights.min.1)
let int32_weights.extent.2.required.s = let t2204 = (int32_weights.extent.2 + int32_weights.min.2) in (min(t2204, 2) - max(min(t2204, 0) + -1, int32_weights.min.2))
let int32_weights.min.2.required = max(min(int32_weights.extent.2 + int32_weights.min.2, 0) + -1, int32_weights.min.2)
let int32_weights.stride.2.required = max(int32_weights.extent.0.required.s, 1)*max(int32_weights.extent.1.required.s, 1)
let int32_weights.extent.3.required.s = let t2205 = (int32_weights.extent.3 + int32_weights.min.3) in (min(t2205, 19) - max(min(t2205, 1) + -1, int32_weights.min.3))
let int32_weights.min.3.required = max(min(int32_weights.extent.3 + int32_weights.min.3, 1) + -1, int32_weights.min.3)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)casted.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)casted.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(casted.min.0, casted.extent.0, 1, 0, casted.min.1, casted.extent.1, casted.extent.0, 0, casted.min.2, casted.extent.2, casted.extent.0*casted.extent.1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 3, (struct halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer)) {
 let t2206 = max(int32_weights.extent.0.required.s, 1) in (let t2207 = max(int32_weights.extent.2.required.s, 1) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)int32_weights.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)int32_weights.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 4, (struct halide_dimension_t *)make_struct(int32_weights.min.0.required, t2206, 1, 0, int32_weights.min.1.required, max(int32_weights.extent.1.required.s, 1), t2206, 0, int32_weights.min.2.required, t2207, int32_weights.stride.2.required, 0, int32_weights.min.3.required, max(int32_weights.extent.3.required.s, 1), t2207*int32_weights.stride.2.required, 0), (uint64)0))
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)int32_weights.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)casted.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)))) {
 assert(casted.type == (uint32)73728, halide_error_bad_type("Output buffer casted", casted.type, (uint32)73728))
 assert(casted.dimensions == 3, halide_error_bad_dimensions("Output buffer casted", casted.dimensions, 3))
 assert(input.type == (uint32)73728, halide_error_bad_type("Input buffer input", input.type, (uint32)73728))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(int32_weights.type == (uint32)73728, halide_error_bad_type("Input buffer int32_weights", int32_weights.type, (uint32)73728))
 assert(int32_weights.dimensions == 4, halide_error_bad_dimensions("Input buffer int32_weights", int32_weights.dimensions, 4))
 assert(0 <= casted.extent.0, halide_error_buffer_extents_negative("Output buffer casted", 0, casted.extent.0))
 assert(0 <= casted.extent.1, halide_error_buffer_extents_negative("Output buffer casted", 1, casted.extent.1))
 assert(0 <= casted.extent.2, halide_error_buffer_extents_negative("Output buffer casted", 2, casted.extent.2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((int32_weights.min.0 <= int32_weights.min.0.required) && ((max(int32_weights.extent.0.required.s, 1) + int32_weights.min.0.required) <= (int32_weights.extent.0 + int32_weights.min.0)), halide_error_access_out_of_bounds("Input buffer int32_weights", 0, int32_weights.min.0.required, (max(int32_weights.extent.0.required.s, 1) + int32_weights.min.0.required) + -1, int32_weights.min.0, (int32_weights.extent.0 + int32_weights.min.0) + -1))
 assert(0 <= int32_weights.extent.0, halide_error_buffer_extents_negative("Input buffer int32_weights", 0, int32_weights.extent.0))
 assert((int32_weights.min.1 <= int32_weights.min.1.required) && ((max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) <= (int32_weights.extent.1 + int32_weights.min.1)), halide_error_access_out_of_bounds("Input buffer int32_weights", 1, int32_weights.min.1.required, (max(int32_weights.extent.1.required.s, 1) + int32_weights.min.1.required) + -1, int32_weights.min.1, (int32_weights.extent.1 + int32_weights.min.1) + -1))
 assert(0 <= int32_weights.extent.1, halide_error_buffer_extents_negative("Input buffer int32_weights", 1, int32_weights.extent.1))
 assert((int32_weights.min.2 <= int32_weights.min.2.required) && ((max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) <= (int32_weights.extent.2 + int32_weights.min.2)), halide_error_access_out_of_bounds("Input buffer int32_weights", 2, int32_weights.min.2.required, (max(int32_weights.extent.2.required.s, 1) + int32_weights.min.2.required) + -1, int32_weights.min.2, (int32_weights.extent.2 + int32_weights.min.2) + -1))
 assert(0 <= int32_weights.extent.2, halide_error_buffer_extents_negative("Input buffer int32_weights", 2, int32_weights.extent.2))
 assert((int32_weights.min.3 <= int32_weights.min.3.required) && ((max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) <= (int32_weights.extent.3 + int32_weights.min.3)), halide_error_access_out_of_bounds("Input buffer int32_weights", 3, int32_weights.min.3.required, (max(int32_weights.extent.3.required.s, 1) + int32_weights.min.3.required) + -1, int32_weights.min.3, (int32_weights.extent.3 + int32_weights.min.3) + -1))
 assert(0 <= int32_weights.extent.3, halide_error_buffer_extents_negative("Input buffer int32_weights", 3, int32_weights.extent.3))
 assert(casted.stride.0 == 1, halide_error_constraint_violated("casted.stride.0", casted.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(int32_weights.stride.0 == 1, halide_error_constraint_violated("int32_weights.stride.0", int32_weights.stride.0, "1", 1))
 let casted.total_extent.1 = int64(casted.extent.1)*int64(casted.extent.0)
 let casted.total_extent.2 = casted.total_extent.1*int64(casted.extent.2)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let int32_weights.total_extent.1 = int64(int32_weights.extent.1)*int64(int32_weights.extent.0)
 let int32_weights.total_extent.2 = int32_weights.total_extent.1*int64(int32_weights.extent.2)
 let int32_weights.total_extent.3 = int32_weights.total_extent.2*int64(int32_weights.extent.3)
 assert(uint64(casted.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", uint64(casted.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.1)*int64(casted.stride.1)), (uint64)2147483647))
 assert(casted.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("casted", (uint64)abs(int64(casted.extent.2)*int64(casted.stride.2)), (uint64)2147483647))
 assert(casted.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("casted", casted.total_extent.2, (int64)2147483647))
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(uint64(int32_weights.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", uint64(int32_weights.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.1)*int64(int32_weights.stride.1)), (uint64)2147483647))
 assert(int32_weights.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.2)*int64(int32_weights.stride.2)), (uint64)2147483647))
 assert(int32_weights.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("int32_weights", (uint64)abs(int64(int32_weights.extent.3)*int64(int32_weights.stride.3)), (uint64)2147483647))
 assert(int32_weights.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("int32_weights", int32_weights.total_extent.3, (int64)2147483647))
 assert(!casted.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer casted"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!int32_weights.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer int32_weights"))
 assert(casted != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer casted"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(int32_weights != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer int32_weights"))
 let conv2D_w__0_1._0.extent_realized = max(casted.extent.0 + casted.min.0, 1) - min(casted.min.0, 1999)
 allocate conv2D_w__0_1[int32 * conv2D_w__0_1._0.extent_realized * ((conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min) + 1) * 19]
 produce conv2D_w__0_1 {
  let t1447 = conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min
  let t1430 = max(min(int32_weights.min.3, 19), 0)
  let t1435 = min(casted.min.0, 1999)
  let t1446 = (t1447 + 1)*conv2D_w__0_1._0.extent_realized
  let t1437 = ((int32_weights.min.1*int32_weights.stride.1) + ((int32_weights.min.3*int32_weights.stride.3) + (int32_weights.min.2*int32_weights.stride.2))) + int32_weights.min.0
  let t1442 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t1436 = int32_weights.extent.3 + int32_weights.min.3
  let t1439 = int32_weights.extent.2 + int32_weights.min.2
  let t1440 = int32_weights.extent.1 + int32_weights.min.1
  let t1438 = int32_weights.extent.0 + int32_weights.min.0
  for (conv2D_w__0_1.s0._2, 0, t1430) {
   let t1457 = conv2D_w__0_1.s0._2*t1446
   let t1448 = (max(min(t1436 + -1, conv2D_w__0_1.s0._2), int32_weights.min.3)*int32_weights.stride.3) - t1437
   for (conv2D_w__0_1.s0._1.rebased, 0, t1447 + 1) {
    let t1467 = (conv2D_w__0_1._0.extent_realized*conv2D_w__0_1.s0._1.rebased) + t1457
    let t1462 = (conv2D_w__0_1.s0._1.min - input.min.1) + conv2D_w__0_1.s0._1.rebased
    let t1458 = conv2D_w__0_1.s0._1.min + conv2D_w__0_1.s0._1.rebased
    for (conv2D_w__0_1.s0._0.rebased, 0, conv2D_w__0_1._0.extent_realized) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1474 = (t1435 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1468 = conv2D_w__0_1.s0._0.rebased + t1435
      for (sum.s1.r85$z, 0, 3) {
       let t1482 = input.extent.2 + input.min.2
       let t1477 = (select((t1482 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1482 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1482 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1442
       let t1476 = max(min(t1438 + -1, sum.s1.r85$z), int32_weights.min.0) + t1448
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1489 = input.extent.1 + input.min.1
        let t1486 = t1489 - int32((uint32)abs(((((sum.s1.r85$y.rebased + t1462) + -1) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1484 = (max(min(sum.s1.r85$y.rebased, t1439) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1476
        let t1483 = sum.s1.r85$y.rebased + t1458
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1300 = sum.s1.r85$x.rebased + t1468
         let t2208 = input.extent.0 + input.min.0
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1440) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1484]*input[select(((t2208 + 1) <= t1300) || (t1300 < (input.min.0 + 1)), (t2208 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1474) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t2208, t1300) + -1, input.min.0)) + ((select(((t1489 + 1) <= t1483) || (t1483 < (input.min.1 + 1)), t1486 + -1, max(min(t1483, t1489) + -1, input.min.1))*input.stride.1) + t1477)])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1467] = sum[0]
     }
     free sum
    }
   }
  }
  let t1524 = input.extent.0 + input.min.0
  let t1525 = input.extent.1 + input.min.1
  let t1526 = input.extent.2 + input.min.2
  let t1527 = int32_weights.extent.0 + int32_weights.min.0
  let t1528 = int32_weights.extent.1 + int32_weights.min.1
  let t1529 = int32_weights.extent.2 + int32_weights.min.2
  let t1530 = input.min.2*input.stride.2
  let t1531 = input.min.1*input.stride.1
  let t1532 = int32_weights.min.1*int32_weights.stride.1
  let t1533 = int32_weights.min.3*int32_weights.stride.3
  let t1534 = int32_weights.min.2*int32_weights.stride.2
  let t1535 = min(casted.min.0, 1999)
  let t1536 = conv2D_w__0_1._0.extent_realized + t1535
  let t1537 = max(min(t1528, 2), -1)
  let t1538 = max(min(t1529, 2), -1)
  let t1539 = max(min(int32_weights.min.1, 2), -1)
  let t1540 = max(min(int32_weights.min.2, 2), -1)
  let t1541 = max(min(int32_weights.min.3, 19), 0)
  let t1542 = min(max(input.min.1 + 1, conv2D_w__0_1.s0._1.min), conv2D_w__0_1.s0._1.max + 1)
  let t1543 = max(input.min.0 + 1, t1535)
  let t1544 = max(input.min.2, int32_weights.min.0)
  let t1511 = max(min(t1526, t1527), t1544)
  let t1492 = max(min(t1525 + -2, conv2D_w__0_1.s0._1.max) + 1, t1542)
  let t1509 = min(max(t1524 + -1, t1543), t1536)
  let t1508 = min(t1536, t1543)
  let t1507 = ((conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min) + 1)*conv2D_w__0_1._0.extent_realized
  let t1490 = max(min(int32_weights.extent.3 + int32_weights.min.3, 19), 0) - t1541
  let t1518 = t1538 - t1540
  let t1520 = t1537 - t1539
  let t1522 = 2 - t1538
  let t1521 = 2 - t1537
  let t1498 = ((t1533 + t1534) + t1532) + int32_weights.min.0
  let t1503 = (t1530 + t1531) + input.min.0
  for (conv2D_w__0_1.s0._2.rebased, 0, t1490) {
   let t1553 = conv2D_w__0_1.s0._2.rebased + t1541
   let t1552 = t1507*t1553
   let t1546 = (int32_weights.stride.3*t1553) - t1498
   let t1545 = t1542 - conv2D_w__0_1.s0._1.min
   for (conv2D_w__0_1.s0._1.rebased, 0, t1545) {
    let t1560 = (conv2D_w__0_1._0.extent_realized*conv2D_w__0_1.s0._1.rebased) + t1552
    let t1556 = (conv2D_w__0_1.s0._1.min - input.min.1) + conv2D_w__0_1.s0._1.rebased
    let t1554 = conv2D_w__0_1.s0._1.min + conv2D_w__0_1.s0._1.rebased
    for (conv2D_w__0_1.s0._0.rebased, 0, conv2D_w__0_1._0.extent_realized) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1564 = (t1535 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1561 = conv2D_w__0_1.s0._0.rebased + t1535
      for (sum.s1.r85$z, 0, 3) {
       let t1567 = (select((t1526 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1526 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1526 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1503
       let t1566 = max(min(t1527 + -1, sum.s1.r85$z), int32_weights.min.0) + t1546
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1572 = t1525 - int32((uint32)abs(((((sum.s1.r85$y.rebased + t1556) + -1) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1571 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1566
        let t1570 = sum.s1.r85$y.rebased + t1554
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1306 = sum.s1.r85$x.rebased + t1561
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1571]*input[select(((t1524 + 1) <= t1306) || (t1306 < (input.min.0 + 1)), (t1524 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1564) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t1306, t1524) + -1, input.min.0)) + ((select(((t1525 + 1) <= t1570) || (t1570 < (input.min.1 + 1)), t1572 + -1, max(min(t1525, t1570) + -1, input.min.1))*input.stride.1) + t1567)])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1560] = sum[0]
     }
     free sum
    }
   }
   let t1597 = conv2D_w__0_1.s0._2.rebased + t1541
   let t1598 = t1507*t1597
   let t1599 = t1508 - t1535
   let t1600 = max(min(t1511, 3), 0)
   let t1601 = int32_weights.stride.3*t1597
   let t1602 = max(min(t1544, 3), 0)
   let t1590 = max(min(t1529, 2), -1)
   let t1589 = max(min(t1528, 2), -1)
   let t1576 = t1601 - t1498
   let t1588 = (((t1508 + t1539) - t1530) - t1531) - input.min.0
   let t1584 = ((t1508 - t1530) - t1531) - input.min.0
   let t1581 = t1542 - conv2D_w__0_1.s0._1.min
   let t1594 = t1536 - t1509
   let t1574 = t1492 - t1542
   let t1596 = (t1509 - t1535) + t1598
   for (conv2D_w__0_1.s0._1.rebased, 0, t1574) {
    let t1607 = ((conv2D_w__0_1.s0._1.rebased + t1581)*conv2D_w__0_1._0.extent_realized) + t1598
    let t1604 = conv2D_w__0_1.s0._1.rebased + t1542
    for (conv2D_w__0_1.s0._0.rebased, 0, t1599) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1610 = (t1535 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1608 = conv2D_w__0_1.s0._0.rebased + t1535
      for (sum.s1.r85$z, 0, 3) {
       let t1613 = (select((t1526 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1526 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1526 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1503
       let t1612 = max(min(t1527 + -1, sum.s1.r85$z), int32_weights.min.0) + t1576
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1615 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1612
        let t1616 = (((sum.s1.r85$y.rebased + t1604) + -1)*input.stride.1) + t1613
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1312 = sum.s1.r85$x.rebased + t1608
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1615]*input[select(((t1524 + 1) <= t1312) || (t1312 < (input.min.0 + 1)), (t1524 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1610) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t1312, t1524) + -1, input.min.0)) + t1616])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1607] = sum[0]
     }
     free sum
    }
    let t1624 = (((t1508 + t1589) - t1530) - t1531) - input.min.0
    let t1618 = t1509 - t1508
    let t1628 = ((conv2D_w__0_1.s0._1.rebased + t1581)*conv2D_w__0_1._0.extent_realized) + (t1598 + t1599)
    let t1622 = ((((t1602 - t1533) - t1534) - t1532) - int32_weights.min.0) + t1601
    let t1625 = (t1542 + t1590) + conv2D_w__0_1.s0._1.rebased
    let t1623 = (t1540 + t1542) + conv2D_w__0_1.s0._1.rebased
    let t1620 = conv2D_w__0_1.s0._1.rebased + t1542
    for (conv2D_w__0_1.s0._0.rebased, 0, t1618) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1629 = conv2D_w__0_1.s0._0.rebased + t1584
      for (sum.s1.r85$z, 0, t1602) {
       let t1631 = max(min(t1527 + -1, sum.s1.r85$z), int32_weights.min.0) + t1576
       let t1632 = (select((t1526 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1526 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1526 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) + t1629
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1633 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1631
        let t1634 = (((sum.s1.r85$y.rebased + t1620) + -1)*input.stride.1) + t1632
        for (sum.s1.r85$x.rebased, 0, 3) {
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1633]*input[(sum.s1.r85$x.rebased + t1634) + -1])
        }
       }
      }
      let t1635 = t1600 - t1602
      let t1638 = conv2D_w__0_1.s0._0.rebased + t1624
      let t1637 = conv2D_w__0_1.s0._0.rebased + t1588
      let t1636 = conv2D_w__0_1.s0._0.rebased + t1584
      for (sum.s1.r85$z.rebased, 0, t1635) {
       let t1640 = ((sum.s1.r85$z.rebased + t1602)*input.stride.2) + t1636
       let t1639 = sum.s1.r85$z.rebased + t1622
       for (sum.s1.r85$y.rebased, 0, t1540 + 1) {
        let t1641 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1639
        let t1642 = (((sum.s1.r85$y.rebased + t1620) + -1)*input.stride.1) + t1640
        for (sum.s1.r85$x.rebased, 0, 3) {
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1641]*input[(sum.s1.r85$x.rebased + t1642) + -1])
        }
       }
       let t1647 = (sum.s1.r85$z.rebased + t1602)*input.stride.2
       let t1646 = t1638 + t1647
       let t1645 = t1637 + t1647
       let t1644 = t1636 + t1647
       let t1643 = sum.s1.r85$z.rebased + t1622
       for (sum.s1.r85$y.rebased, 0, t1518) {
        let t1649 = ((sum.s1.r85$y.rebased + t1623)*input.stride.1) + t1644
        let t1648 = ((sum.s1.r85$y.rebased + t1540)*int32_weights.stride.2) + t1643
        for (sum.s1.r85$x.rebased, 0, t1539 + 1) {
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1648]*input[(sum.s1.r85$x.rebased + t1649) + -1])
        }
        let t1651 = ((sum.s1.r85$y.rebased + t1623)*input.stride.1) + t1645
        let t1650 = ((sum.s1.r85$y.rebased + t1540)*int32_weights.stride.2) + t1643
        for (sum.s1.r85$x.rebased, 0, t1520) {
         sum[0] = sum[0] + (int32_weights[((sum.s1.r85$x.rebased + t1539)*int32_weights.stride.1) + t1650]*input[sum.s1.r85$x.rebased + t1651])
        }
        let t1653 = ((sum.s1.r85$y.rebased + t1623)*input.stride.1) + t1646
        let t1652 = ((sum.s1.r85$y.rebased + t1540)*int32_weights.stride.2) + t1643
        for (sum.s1.r85$x.rebased, 0, t1521) {
         sum[0] = sum[0] + (int32_weights[(max(min(t1528 + -1, sum.s1.r85$x.rebased + t1589), int32_weights.min.1)*int32_weights.stride.1) + t1652]*input[sum.s1.r85$x.rebased + t1653])
        }
       }
       let t1655 = ((sum.s1.r85$z.rebased + t1602)*input.stride.2) + t1636
       let t1654 = sum.s1.r85$z.rebased + t1622
       for (sum.s1.r85$y.rebased, 0, t1522) {
        let t1656 = (max(min(t1529 + -1, sum.s1.r85$y.rebased + t1590), int32_weights.min.2)*int32_weights.stride.2) + t1654
        let t1657 = ((sum.s1.r85$y.rebased + t1625)*input.stride.1) + t1655
        for (sum.s1.r85$x.rebased, 0, 3) {
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1656]*input[(sum.s1.r85$x.rebased + t1657) + -1])
        }
       }
      }
      let t1659 = conv2D_w__0_1.s0._0.rebased + t1584
      for (sum.s1.r85$z.rebased, 0, 3 - t1600) {
       let t1663 = t1526 - int32((uint32)abs(((((t1600 - input.min.2) + sum.s1.r85$z.rebased) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))
       let t1662 = sum.s1.r85$z.rebased + t1600
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1664 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + (max(min(t1527 + -1, t1662), int32_weights.min.0) + t1576)
        let t1665 = (((sum.s1.r85$y.rebased + t1620) + -1)*input.stride.1) + ((select(t1662 < t1526, max(min(t1526 + -1, t1662), input.min.2), t1663 + -1)*input.stride.2) + t1659)
        for (sum.s1.r85$x.rebased, 0, 3) {
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1664]*input[(sum.s1.r85$x.rebased + t1665) + -1])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1628] = sum[0]
     }
     free sum
    }
    let t1670 = ((conv2D_w__0_1.s0._1.rebased + t1581)*conv2D_w__0_1._0.extent_realized) + t1596
    let t1667 = conv2D_w__0_1.s0._1.rebased + t1542
    for (conv2D_w__0_1.s0._0.rebased, 0, t1594) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1673 = (t1509 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1671 = conv2D_w__0_1.s0._0.rebased + t1509
      for (sum.s1.r85$z, 0, 3) {
       let t1676 = (select((t1526 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1526 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1526 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1503
       let t1675 = max(min(t1527 + -1, sum.s1.r85$z), int32_weights.min.0) + t1576
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1678 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1675
        let t1679 = (((sum.s1.r85$y.rebased + t1667) + -1)*input.stride.1) + t1676
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1331 = sum.s1.r85$x.rebased + t1671
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1678]*input[select(t1331 < (t1524 + 1), max(min(t1331, t1524) + -1, input.min.0), (t1524 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1673) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1) + t1679])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1670] = sum[0]
     }
     free sum
    }
   }
   let t1690 = conv2D_w__0_1.s0._2.rebased + t1541
   let t1688 = t1507*t1690
   let t1682 = (int32_weights.stride.3*t1690) - t1498
   let t1689 = t1492 - conv2D_w__0_1.s0._1.min
   let t1681 = conv2D_w__0_1.s0._1.max - t1492
   for (conv2D_w__0_1.s0._1.rebased, 0, t1681 + 1) {
    let t1697 = ((conv2D_w__0_1.s0._1.rebased + t1689)*conv2D_w__0_1._0.extent_realized) + t1688
    let t1693 = (t1492 - input.min.1) + conv2D_w__0_1.s0._1.rebased
    let t1691 = conv2D_w__0_1.s0._1.rebased + t1492
    for (conv2D_w__0_1.s0._0.rebased, 0, conv2D_w__0_1._0.extent_realized) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1701 = (t1535 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1698 = conv2D_w__0_1.s0._0.rebased + t1535
      for (sum.s1.r85$z, 0, 3) {
       let t1704 = (select((t1526 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1526 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1526 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1503
       let t1703 = max(min(t1527 + -1, sum.s1.r85$z), int32_weights.min.0) + t1682
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1709 = t1525 - int32((uint32)abs(((((sum.s1.r85$y.rebased + t1693) + -1) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1708 = (max(min(sum.s1.r85$y.rebased, t1529) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1703
        let t1707 = sum.s1.r85$y.rebased + t1691
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1338 = sum.s1.r85$x.rebased + t1698
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1528) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1708]*input[select(((t1524 + 1) <= t1338) || (t1338 < (input.min.0 + 1)), (t1524 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1701) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t1338, t1524) + -1, input.min.0)) + ((select(t1707 < (t1525 + 1), max(min(t1525, t1707) + -1, input.min.1), t1709 + -1)*input.stride.1) + t1704)])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1697] = sum[0]
     }
     free sum
    }
   }
  }
  let t1729 = int32_weights.extent.3 + int32_weights.min.3
  let t1730 = max(min(t1729, 19), 0)
  let t1731 = conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min
  let t1717 = min(casted.min.0, 1999)
  let t1727 = (t1731 + 1)*conv2D_w__0_1._0.extent_realized
  let t1718 = ((int32_weights.min.1*int32_weights.stride.1) + ((int32_weights.min.3*int32_weights.stride.3) + (int32_weights.min.2*int32_weights.stride.2))) + int32_weights.min.0
  let t1723 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  let t1720 = int32_weights.extent.2 + int32_weights.min.2
  let t1721 = int32_weights.extent.1 + int32_weights.min.1
  let t1719 = int32_weights.extent.0 + int32_weights.min.0
  for (conv2D_w__0_1.s0._2.rebased, 0, 19 - t1730) {
   let t1741 = (conv2D_w__0_1.s0._2.rebased + t1730)*t1727
   let t1732 = (max(min(t1729 + -1, max(min(t1729, 19), 0) + conv2D_w__0_1.s0._2.rebased), int32_weights.min.3)*int32_weights.stride.3) - t1718
   for (conv2D_w__0_1.s0._1.rebased, 0, t1731 + 1) {
    let t1751 = (conv2D_w__0_1._0.extent_realized*conv2D_w__0_1.s0._1.rebased) + t1741
    let t1746 = (conv2D_w__0_1.s0._1.min - input.min.1) + conv2D_w__0_1.s0._1.rebased
    let t1742 = conv2D_w__0_1.s0._1.min + conv2D_w__0_1.s0._1.rebased
    for (conv2D_w__0_1.s0._0.rebased, 0, conv2D_w__0_1._0.extent_realized) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t1758 = (t1717 - input.min.0) + conv2D_w__0_1.s0._0.rebased
      let t1752 = conv2D_w__0_1.s0._0.rebased + t1717
      for (sum.s1.r85$z, 0, 3) {
       let t1766 = input.extent.2 + input.min.2
       let t1761 = (select((t1766 <= sum.s1.r85$z) || (sum.s1.r85$z < input.min.2), (t1766 - int32((uint32)abs((((sum.s1.r85$z - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1766 + -1, sum.s1.r85$z), input.min.2))*input.stride.2) - t1723
       let t1760 = max(min(t1719 + -1, sum.s1.r85$z), int32_weights.min.0) + t1732
       for (sum.s1.r85$y.rebased, 0, 3) {
        let t1773 = input.extent.1 + input.min.1
        let t1770 = t1773 - int32((uint32)abs(((((sum.s1.r85$y.rebased + t1746) + -1) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1768 = (max(min(sum.s1.r85$y.rebased, t1720) + -1, int32_weights.min.2)*int32_weights.stride.2) + t1760
        let t1767 = sum.s1.r85$y.rebased + t1742
        for (sum.s1.r85$x.rebased, 0, 3) {
         let t1345 = sum.s1.r85$x.rebased + t1752
         let t2209 = input.extent.0 + input.min.0
         sum[0] = sum[0] + (int32_weights[(max(min(sum.s1.r85$x.rebased, t1721) + -1, int32_weights.min.1)*int32_weights.stride.1) + t1768]*input[select(((t2209 + 1) <= t1345) || (t1345 < (input.min.0 + 1)), (t2209 - int32((uint32)abs(((((sum.s1.r85$x.rebased + t1758) + -1) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))) + -1, max(min(t2209, t1345) + -1, input.min.0)) + ((select(((t1773 + 1) <= t1767) || (t1767 < (input.min.1 + 1)), t1770 + -1, max(min(t1767, t1773) + -1, input.min.1))*input.stride.1) + t1761)])
        }
       }
      }
     }
     consume sum {
      conv2D_w__0_1[conv2D_w__0_1.s0._0.rebased + t1751] = sum[0]
     }
     free sum
    }
   }
  }
 }
 let upsampled_linear__1._1.extent_realized.s = max(min((casted.extent.1 + casted.min.1)*2, 3999), 0) - max(min(casted.min.1*2, 3999), 0)
 let upsampled_linear__1._0.extent_realized = max(min(casted.extent.0 + casted.min.0, 2000), 1) - max(min(casted.min.0, 1999), 0)
 allocate upsampled_linear__1[int32 * upsampled_linear__1._0.extent_realized * (upsampled_linear__1._1.extent_realized.s + 1) * 19]
 produce upsampled_linear__1 {
  consume conv2D_w__0_1 {
   let t1776 = max(min(casted.min.1*2, 3999), 0)
   let t1774 = min(casted.min.0, 1999)
   let t1775 = ((conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min) + 1)*conv2D_w__0_1._0.extent_realized
   let t1777 = (upsampled_linear__1._1.extent_realized.s + 1)*upsampled_linear__1._0.extent_realized
   for (upsampled_linear__1.s0._2, 0, 19) {
    let t1779 = t1777*upsampled_linear__1.s0._2
    let t1778 = (t1775*upsampled_linear__1.s0._2) - min(t1774, 0)
    for (upsampled_linear__1.s0._1.rebased, 0, upsampled_linear__1._1.extent_realized.s + 1) {
     let t1783 = t1776 + upsampled_linear__1.s0._1.rebased
     let t1781 = t1783 % 2
     let t1780 = (((t1783/2) - conv2D_w__0_1.s0._1.min)*conv2D_w__0_1._0.extent_realized) + t1778
     let t1782 = (upsampled_linear__1._0.extent_realized*upsampled_linear__1.s0._1.rebased) + t1779
     for (upsampled_linear__1.s0._0.rebased, 0, upsampled_linear__1._0.extent_realized) {
      let t1172 = t1780 + upsampled_linear__1.s0._0.rebased
      upsampled_linear__1[t1782 + upsampled_linear__1.s0._0.rebased] = int32((int16(((conv2D_w__0_1[t1172]*(2 - t1781)) + (conv2D_w__0_1[conv2D_w__0_1._0.extent_realized + t1172]*t1781)))/(int16)4))
     }
    }
   }
  }
 }
 allocate binary_op$1[int32 * upsampled_linear__1._0.extent_realized * (upsampled_linear__1._1.extent_realized.s + 1) * 19]
 produce binary_op$1 {
  consume upsampled_linear__1 {
   let t1802 = input.extent.0 + input.min.0
   let t1803 = input.extent.2 + input.min.2
   let t1804 = input.min.2*input.stride.2
   let t1805 = input.min.1*input.stride.1
   let t1806 = min(casted.min.0, 1999)
   let t1807 = max(t1806, 0)
   let t1808 = t1807 + upsampled_linear__1._0.extent_realized
   let t1809 = max(min(t1803, 3), 0)
   let t1810 = max(min(input.min.2, 3), 0)
   let t1811 = max(input.min.0, t1806)
   let t1789 = max(min(casted.min.1*2, 3999), 0)
   let t1785 = min(max(max(t1802, t1811), 0), t1808)
   let t1784 = min(max(t1811, 0), t1808)
   let t1795 = (upsampled_linear__1._1.extent_realized.s + 1)*upsampled_linear__1._0.extent_realized
   let t1799 = t1809 - t1810
   let t1800 = 3 - t1809
   let t1792 = (t1804 + t1805) + input.min.0
   for (binary_op$1.s0._2, 0, 19) {
    let t1826 = binary_op$1.s0._2*t1795
    let t1827 = t1784 - t1807
    let t1821 = max(min(t1803, 3), 0)
    let t1820 = ((t1784 - t1804) - t1805) - input.min.0
    let t1823 = t1808 - t1785
    let t1819 = t1785 - t1784
    let t1825 = (t1785 - t1807) + t1826
    for (binary_op$1.s0._1.rebased, 0, upsampled_linear__1._1.extent_realized.s + 1) {
     let t1836 = binary_op$1.s0._1.rebased + t1789
     let t1835 = t1836 % 2
     let t1834 = (binary_op$1.s0._1.rebased*upsampled_linear__1._0.extent_realized) + t1826
     for (binary_op$1.s0._0.rebased, 0, t1827) {
      allocate all_r$1[int32 * 2]
      produce all_r$1 {
       for (all_r$1.s0._1.rebased, 0, 2) {
        all_r$1[all_r$1.s0._1.rebased] = 0
       }
       let t1844 = t1836/2
       let t1839 = t1802 - int32((uint32)abs(((((t1807 - input.min.0) + binary_op$1.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t1837 = binary_op$1.s0._0.rebased + t1807
       for (all_r$1.s1._1.rebased, 0, 2) {
        let t1850 = input.extent.1 + input.min.1
        let t1846 = select((t1802 <= t1837) || (t1837 < input.min.0), t1839 + -1, max(min(t1802 + -1, t1837), input.min.0)) - t1792
        let t1848 = t1850 - int32((uint32)abs(((((t1844 - input.min.1) + all_r$1.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1845 = all_r$1.s1._1.rebased + t1844
        for (all_r$1.s1.r127$x, 0, 3) {
         all_r$1[all_r$1.s1._1.rebased] = all_r$1[all_r$1.s1._1.rebased] + (input[(select((t1803 <= all_r$1.s1.r127$x) || (all_r$1.s1.r127$x < input.min.2), (t1803 - int32((uint32)abs((((all_r$1.s1.r127$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1803 + -1, all_r$1.s1.r127$x), input.min.2))*input.stride.2) + ((select((t1850 <= t1845) || (t1845 < input.min.1), t1848 + -1, max(min(t1850 + -1, t1845), input.min.1))*input.stride.1) + t1846)]*(((all_r$1.s1.r127$x*3) + binary_op$1.s0._2) + 4))
        }
       }
      }
      consume all_r$1 {
       let t1179 = binary_op$1.s0._0.rebased + t1834
       binary_op$1[t1179] = min(upsampled_linear__1[t1179], int32((int16(((all_r$1[0]*(2 - t1835)) + (all_r$1[1]*t1835)))/(int16)4)))
      }
      free all_r$1
     }
     let t1863 = binary_op$1.s0._1.rebased + t1789
     let t1864 = input.extent.1 + input.min.1
     let t1865 = t1863/2
     let t1866 = t1865 + 2
     let t1867 = max(input.min.1, t1865)
     let t1868 = min(t1866, t1867)
     let t1860 = max(min(t1865 - t1864, 0), -2)
     let t1853 = max(min(input.min.1 - t1865, 2), 0)
     let t1852 = min(max(t1864, t1867), t1866)
     let t1862 = t1863 % 2
     let t1858 = min(max(t1864, t1865), t1866) - t1868
     let t1861 = (binary_op$1.s0._1.rebased*upsampled_linear__1._0.extent_realized) + (t1826 + t1827)
     for (binary_op$1.s0._0.rebased, 0, t1819) {
      allocate all_r$1[int32 * 2]
      produce all_r$1 {
       for (all_r$1.s0._1.rebased, 0, 2) {
        all_r$1[all_r$1.s0._1.rebased] = 0
       }
       let t1874 = t1863/2
       let t1870 = binary_op$1.s0._0.rebased + t1820
       for (all_r$1.s1._1.rebased, 0, t1853) {
        let t1876 = t1864 - int32((uint32)abs(((((t1874 - input.min.1) + all_r$1.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1875 = all_r$1.s1._1.rebased + t1874
        for (all_r$1.s1.r127$x, 0, 3) {
         all_r$1[all_r$1.s1._1.rebased] = all_r$1[all_r$1.s1._1.rebased] + (input[(select((t1803 <= all_r$1.s1.r127$x) || (all_r$1.s1.r127$x < input.min.2), (t1803 - int32((uint32)abs((((all_r$1.s1.r127$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1803 + -1, all_r$1.s1.r127$x), input.min.2))*input.stride.2) + ((select((t1864 <= t1875) || (t1875 < input.min.1), t1876 + -1, max(min(t1864 + -1, t1875), input.min.1))*input.stride.1) + t1870)]*(((all_r$1.s1.r127$x*3) + binary_op$1.s0._2) + 4))
        }
       }
       let t1878 = max(min(input.min.1 - (t1863/2), 2), 0)
       let t1879 = binary_op$1.s0._0.rebased + t1820
       for (all_r$1.s1._1.rebased, 0, t1858) {
        let t1883 = ((all_r$1.s1._1.rebased + t1868)*input.stride.1) + t1879
        let t1882 = all_r$1.s1._1.rebased + t1878
        for (all_r$1.s1.r127$x, 0, t1810) {
         all_r$1[t1882] = all_r$1[t1882] + (input[(select((t1803 <= all_r$1.s1.r127$x) || (all_r$1.s1.r127$x < input.min.2), (t1803 - int32((uint32)abs((((all_r$1.s1.r127$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1803 + -1, all_r$1.s1.r127$x), input.min.2))*input.stride.2) + t1883]*(((all_r$1.s1.r127$x*3) + binary_op$1.s0._2) + 4))
        }
        let t1886 = ((all_r$1.s1._1.rebased + t1868)*input.stride.1) + t1879
        let t1885 = all_r$1.s1._1.rebased + t1878
        for (all_r$1.s1.r127$x.rebased, 0, t1799) {
         let t1368 = all_r$1.s1.r127$x.rebased + t1810
         all_r$1[t1885] = all_r$1[t1885] + (input[(input.stride.2*t1368) + t1886]*(((t1368*3) + binary_op$1.s0._2) + 4))
        }
        let t1888 = ((all_r$1.s1._1.rebased + t1868)*input.stride.1) + t1879
        let t1887 = all_r$1.s1._1.rebased + t1878
        for (all_r$1.s1.r127$x.rebased, 0, t1800) {
         let t1372 = all_r$1.s1.r127$x.rebased + t1821
         all_r$1[t1887] = all_r$1[t1887] + (input[(select(t1372 < t1803, max(min(t1803 + -1, t1372), input.min.2), (t1803 - int32((uint32)abs(((((t1821 - input.min.2) + all_r$1.s1.r127$x.rebased) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1)*input.stride.2) + t1888]*(((t1372*3) + binary_op$1.s0._2) + 4))
        }
       }
       let t1891 = max(min(t1864 - (t1863/2), 2), 0)
       let t1892 = binary_op$1.s0._0.rebased + t1820
       for (all_r$1.s1._1.rebased, 0, t1860 + 2) {
        let t1898 = t1864 - int32((uint32)abs(((((t1852 - input.min.1) + all_r$1.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1896 = all_r$1.s1._1.rebased + t1891
        let t1897 = all_r$1.s1._1.rebased + t1852
        for (all_r$1.s1.r127$x, 0, 3) {
         all_r$1[t1896] = all_r$1[t1896] + (input[(select((t1803 <= all_r$1.s1.r127$x) || (all_r$1.s1.r127$x < input.min.2), (t1803 - int32((uint32)abs((((all_r$1.s1.r127$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1803 + -1, all_r$1.s1.r127$x), input.min.2))*input.stride.2) + ((select(t1897 < t1864, max(min(t1864 + -1, t1897), input.min.1), t1898 + -1)*input.stride.1) + t1892)]*(((all_r$1.s1.r127$x*3) + binary_op$1.s0._2) + 4))
        }
       }
      }
      consume all_r$1 {
       let t1196 = binary_op$1.s0._0.rebased + t1861
       binary_op$1[t1196] = min(upsampled_linear__1[t1196], int32((int16(((all_r$1[0]*(2 - t1862)) + (all_r$1[1]*t1862)))/(int16)4)))
      }
      free all_r$1
     }
     let t1908 = binary_op$1.s0._1.rebased + t1789
     let t1907 = t1908 % 2
     let t1906 = (binary_op$1.s0._1.rebased*upsampled_linear__1._0.extent_realized) + t1825
     for (binary_op$1.s0._0.rebased, 0, t1823) {
      allocate all_r$1[int32 * 2]
      produce all_r$1 {
       for (all_r$1.s0._1.rebased, 0, 2) {
        all_r$1[all_r$1.s0._1.rebased] = 0
       }
       let t1916 = t1908/2
       let t1911 = t1802 - int32((uint32)abs(((((t1785 - input.min.0) + binary_op$1.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t1909 = binary_op$1.s0._0.rebased + t1785
       for (all_r$1.s1._1.rebased, 0, 2) {
        let t1922 = input.extent.1 + input.min.1
        let t1918 = select(t1909 < t1802, max(min(t1802 + -1, t1909), input.min.0), t1911 + -1) - t1792
        let t1920 = t1922 - int32((uint32)abs(((((t1916 - input.min.1) + all_r$1.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1917 = all_r$1.s1._1.rebased + t1916
        for (all_r$1.s1.r127$x, 0, 3) {
         all_r$1[all_r$1.s1._1.rebased] = all_r$1[all_r$1.s1._1.rebased] + (input[(select((t1803 <= all_r$1.s1.r127$x) || (all_r$1.s1.r127$x < input.min.2), (t1803 - int32((uint32)abs((((all_r$1.s1.r127$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1803 + -1, all_r$1.s1.r127$x), input.min.2))*input.stride.2) + ((select((t1922 <= t1917) || (t1917 < input.min.1), t1920 + -1, max(min(t1922 + -1, t1917), input.min.1))*input.stride.1) + t1918)]*(((all_r$1.s1.r127$x*3) + binary_op$1.s0._2) + 4))
        }
       }
      }
      consume all_r$1 {
       let t1201 = binary_op$1.s0._0.rebased + t1906
       binary_op$1[t1201] = min(upsampled_linear__1[t1201], int32((int16(((all_r$1[0]*(2 - t1907)) + (all_r$1[1]*t1907)))/(int16)4)))
      }
      free all_r$1
     }
    }
   }
  }
 }
 allocate binary_op$2[int32 * upsampled_linear__1._0.extent_realized * (upsampled_linear__1._1.extent_realized.s + 1) * 19]
 produce binary_op$2 {
  consume upsampled_linear__1 {
   let t1941 = input.extent.0 + input.min.0
   let t1942 = input.extent.2 + input.min.2
   let t1943 = input.min.2*input.stride.2
   let t1944 = input.min.1*input.stride.1
   let t1945 = min(casted.min.0, 1999)
   let t1946 = max(t1945, 0)
   let t1947 = t1946 + upsampled_linear__1._0.extent_realized
   let t1948 = max(min(t1942, 3), 0)
   let t1949 = max(min(input.min.2, 3), 0)
   let t1950 = max(input.min.0, t1945)
   let t1928 = max(min(casted.min.1*2, 3999), 0)
   let t1924 = min(max(max(t1941, t1950), 0), t1947)
   let t1923 = min(max(t1950, 0), t1947)
   let t1934 = (upsampled_linear__1._1.extent_realized.s + 1)*upsampled_linear__1._0.extent_realized
   let t1938 = t1948 - t1949
   let t1939 = 3 - t1948
   let t1931 = (t1943 + t1944) + input.min.0
   for (binary_op$2.s0._2, 0, 19) {
    let t1965 = binary_op$2.s0._2*t1934
    let t1966 = t1923 - t1946
    let t1960 = max(min(t1942, 3), 0)
    let t1959 = ((t1923 - t1943) - t1944) - input.min.0
    let t1962 = t1947 - t1924
    let t1958 = t1924 - t1923
    let t1964 = (t1924 - t1946) + t1965
    for (binary_op$2.s0._1.rebased, 0, upsampled_linear__1._1.extent_realized.s + 1) {
     let t1975 = binary_op$2.s0._1.rebased + t1928
     let t1974 = t1975 % 2
     let t1973 = (binary_op$2.s0._1.rebased*upsampled_linear__1._0.extent_realized) + t1965
     for (binary_op$2.s0._0.rebased, 0, t1966) {
      allocate all_r$2[int32 * 2]
      produce all_r$2 {
       for (all_r$2.s0._1.rebased, 0, 2) {
        all_r$2[all_r$2.s0._1.rebased] = 0
       }
       let t1983 = t1975/2
       let t1978 = t1941 - int32((uint32)abs(((((t1946 - input.min.0) + binary_op$2.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t1976 = binary_op$2.s0._0.rebased + t1946
       for (all_r$2.s1._1.rebased, 0, 2) {
        let t1989 = input.extent.1 + input.min.1
        let t1985 = select((t1941 <= t1976) || (t1976 < input.min.0), t1978 + -1, max(min(t1941 + -1, t1976), input.min.0)) - t1931
        let t1987 = t1989 - int32((uint32)abs(((((t1983 - input.min.1) + all_r$2.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t1984 = all_r$2.s1._1.rebased + t1983
        for (all_r$2.s1.r144$x, 0, 3) {
         all_r$2[all_r$2.s1._1.rebased] = all_r$2[all_r$2.s1._1.rebased] + (input[(select((t1942 <= all_r$2.s1.r144$x) || (all_r$2.s1.r144$x < input.min.2), (t1942 - int32((uint32)abs((((all_r$2.s1.r144$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1942 + -1, all_r$2.s1.r144$x), input.min.2))*input.stride.2) + ((select((t1989 <= t1984) || (t1984 < input.min.1), t1987 + -1, max(min(t1989 + -1, t1984), input.min.1))*input.stride.1) + t1985)]*(((all_r$2.s1.r144$x*3) + binary_op$2.s0._2) + 4))
        }
       }
      }
      consume all_r$2 {
       let t1208 = binary_op$2.s0._0.rebased + t1973
       binary_op$2[t1208] = upsampled_linear__1[t1208] + min(int32((int16(((all_r$2[0]*(2 - t1974)) + (all_r$2[1]*t1974)))/(int16)4)), 0)
      }
      free all_r$2
     }
     let t2002 = binary_op$2.s0._1.rebased + t1928
     let t2003 = input.extent.1 + input.min.1
     let t2004 = t2002/2
     let t2005 = t2004 + 2
     let t2006 = max(input.min.1, t2004)
     let t2007 = min(t2005, t2006)
     let t1999 = max(min(t2004 - t2003, 0), -2)
     let t1992 = max(min(input.min.1 - t2004, 2), 0)
     let t1991 = min(max(t2003, t2006), t2005)
     let t2001 = t2002 % 2
     let t1997 = min(max(t2003, t2004), t2005) - t2007
     let t2000 = (binary_op$2.s0._1.rebased*upsampled_linear__1._0.extent_realized) + (t1965 + t1966)
     for (binary_op$2.s0._0.rebased, 0, t1958) {
      allocate all_r$2[int32 * 2]
      produce all_r$2 {
       for (all_r$2.s0._1.rebased, 0, 2) {
        all_r$2[all_r$2.s0._1.rebased] = 0
       }
       let t2013 = t2002/2
       let t2009 = binary_op$2.s0._0.rebased + t1959
       for (all_r$2.s1._1.rebased, 0, t1992) {
        let t2015 = t2003 - int32((uint32)abs(((((t2013 - input.min.1) + all_r$2.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t2014 = all_r$2.s1._1.rebased + t2013
        for (all_r$2.s1.r144$x, 0, 3) {
         all_r$2[all_r$2.s1._1.rebased] = all_r$2[all_r$2.s1._1.rebased] + (input[(select((t1942 <= all_r$2.s1.r144$x) || (all_r$2.s1.r144$x < input.min.2), (t1942 - int32((uint32)abs((((all_r$2.s1.r144$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1942 + -1, all_r$2.s1.r144$x), input.min.2))*input.stride.2) + ((select((t2003 <= t2014) || (t2014 < input.min.1), t2015 + -1, max(min(t2003 + -1, t2014), input.min.1))*input.stride.1) + t2009)]*(((all_r$2.s1.r144$x*3) + binary_op$2.s0._2) + 4))
        }
       }
       let t2017 = max(min(input.min.1 - (t2002/2), 2), 0)
       let t2018 = binary_op$2.s0._0.rebased + t1959
       for (all_r$2.s1._1.rebased, 0, t1997) {
        let t2022 = ((all_r$2.s1._1.rebased + t2007)*input.stride.1) + t2018
        let t2021 = all_r$2.s1._1.rebased + t2017
        for (all_r$2.s1.r144$x, 0, t1949) {
         all_r$2[t2021] = all_r$2[t2021] + (input[(select((t1942 <= all_r$2.s1.r144$x) || (all_r$2.s1.r144$x < input.min.2), (t1942 - int32((uint32)abs((((all_r$2.s1.r144$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1942 + -1, all_r$2.s1.r144$x), input.min.2))*input.stride.2) + t2022]*(((all_r$2.s1.r144$x*3) + binary_op$2.s0._2) + 4))
        }
        let t2025 = ((all_r$2.s1._1.rebased + t2007)*input.stride.1) + t2018
        let t2024 = all_r$2.s1._1.rebased + t2017
        for (all_r$2.s1.r144$x.rebased, 0, t1938) {
         let t1405 = all_r$2.s1.r144$x.rebased + t1949
         all_r$2[t2024] = all_r$2[t2024] + (input[(input.stride.2*t1405) + t2025]*(((t1405*3) + binary_op$2.s0._2) + 4))
        }
        let t2027 = ((all_r$2.s1._1.rebased + t2007)*input.stride.1) + t2018
        let t2026 = all_r$2.s1._1.rebased + t2017
        for (all_r$2.s1.r144$x.rebased, 0, t1939) {
         let t1409 = all_r$2.s1.r144$x.rebased + t1960
         all_r$2[t2026] = all_r$2[t2026] + (input[(select(t1409 < t1942, max(min(t1942 + -1, t1409), input.min.2), (t1942 - int32((uint32)abs(((((t1960 - input.min.2) + all_r$2.s1.r144$x.rebased) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1)*input.stride.2) + t2027]*(((t1409*3) + binary_op$2.s0._2) + 4))
        }
       }
       let t2030 = max(min(t2003 - (t2002/2), 2), 0)
       let t2031 = binary_op$2.s0._0.rebased + t1959
       for (all_r$2.s1._1.rebased, 0, t1999 + 2) {
        let t2037 = t2003 - int32((uint32)abs(((((t1991 - input.min.1) + all_r$2.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t2035 = all_r$2.s1._1.rebased + t2030
        let t2036 = all_r$2.s1._1.rebased + t1991
        for (all_r$2.s1.r144$x, 0, 3) {
         all_r$2[t2035] = all_r$2[t2035] + (input[(select((t1942 <= all_r$2.s1.r144$x) || (all_r$2.s1.r144$x < input.min.2), (t1942 - int32((uint32)abs((((all_r$2.s1.r144$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1942 + -1, all_r$2.s1.r144$x), input.min.2))*input.stride.2) + ((select(t2036 < t2003, max(min(t2003 + -1, t2036), input.min.1), t2037 + -1)*input.stride.1) + t2031)]*(((all_r$2.s1.r144$x*3) + binary_op$2.s0._2) + 4))
        }
       }
      }
      consume all_r$2 {
       let t1225 = binary_op$2.s0._0.rebased + t2000
       binary_op$2[t1225] = upsampled_linear__1[t1225] + min(int32((int16(((all_r$2[0]*(2 - t2001)) + (all_r$2[1]*t2001)))/(int16)4)), 0)
      }
      free all_r$2
     }
     let t2047 = binary_op$2.s0._1.rebased + t1928
     let t2046 = t2047 % 2
     let t2045 = (binary_op$2.s0._1.rebased*upsampled_linear__1._0.extent_realized) + t1964
     for (binary_op$2.s0._0.rebased, 0, t1962) {
      allocate all_r$2[int32 * 2]
      produce all_r$2 {
       for (all_r$2.s0._1.rebased, 0, 2) {
        all_r$2[all_r$2.s0._1.rebased] = 0
       }
       let t2055 = t2047/2
       let t2050 = t1941 - int32((uint32)abs(((((t1924 - input.min.0) + binary_op$2.s0._0.rebased) % ((input.extent.0*2) + -2)) - input.extent.0) + 1))
       let t2048 = binary_op$2.s0._0.rebased + t1924
       for (all_r$2.s1._1.rebased, 0, 2) {
        let t2061 = input.extent.1 + input.min.1
        let t2057 = select(t2048 < t1941, max(min(t1941 + -1, t2048), input.min.0), t2050 + -1) - t1931
        let t2059 = t2061 - int32((uint32)abs(((((t2055 - input.min.1) + all_r$2.s1._1.rebased) % ((input.extent.1*2) + -2)) - input.extent.1) + 1))
        let t2056 = all_r$2.s1._1.rebased + t2055
        for (all_r$2.s1.r144$x, 0, 3) {
         all_r$2[all_r$2.s1._1.rebased] = all_r$2[all_r$2.s1._1.rebased] + (input[(select((t1942 <= all_r$2.s1.r144$x) || (all_r$2.s1.r144$x < input.min.2), (t1942 - int32((uint32)abs((((all_r$2.s1.r144$x - input.min.2) % ((input.extent.2*2) + -2)) - input.extent.2) + 1))) + -1, max(min(t1942 + -1, all_r$2.s1.r144$x), input.min.2))*input.stride.2) + ((select((t2061 <= t2056) || (t2056 < input.min.1), t2059 + -1, max(min(t2061 + -1, t2056), input.min.1))*input.stride.1) + t2057)]*(((all_r$2.s1.r144$x*3) + binary_op$2.s0._2) + 4))
        }
       }
      }
      consume all_r$2 {
       let t1230 = binary_op$2.s0._0.rebased + t2045
       binary_op$2[t1230] = upsampled_linear__1[t1230] + min(int32((int16(((all_r$2[0]*(2 - t2046)) + (all_r$2[1]*t2046)))/(int16)4)), 0)
      }
      free all_r$2
     }
    }
   }
  }
 }
 free upsampled_linear__1
 allocate binary_op$3[int32 * upsampled_linear__1._0.extent_realized * (upsampled_linear__1._1.extent_realized.s + 1) * 19]
 produce binary_op$3 {
  consume binary_op$2 {
   consume binary_op$1 {
    let t2062 = (upsampled_linear__1._1.extent_realized.s + 1)*upsampled_linear__1._0.extent_realized
    for (binary_op$3.s0._2, 0, 19) {
     let t2063 = binary_op$3.s0._2*t2062
     for (binary_op$3.s0._1.rebased, 0, upsampled_linear__1._1.extent_realized.s + 1) {
      let t2064 = (binary_op$3.s0._1.rebased*upsampled_linear__1._0.extent_realized) + t2063
      for (binary_op$3.s0._0.rebased, 0, upsampled_linear__1._0.extent_realized) {
       let t1232 = binary_op$3.s0._0.rebased + t2064
       let t1233 = binary_op$2[t1232]
       binary_op$3[t1232] = max(min(binary_op$1[t1232], t1233*t1233), 0)
      }
     }
    }
   }
  }
 }
 free binary_op$1
 free binary_op$2
 allocate constant_exterior[int32 * casted.extent.0 * ((casted.extent.1*2) + 1) * 19]
 produce constant_exterior {
  consume binary_op$3 {
   let t2076 = casted.extent.0 + casted.min.0
   let t2077 = casted.min.1*2
   let t2078 = (casted.extent.1 + casted.min.1)*2
   let t2079 = min(max(casted.min.1, 0)*2, t2078 + 1)
   let t2066 = max(min(t2078, 3999) + 1, t2079)
   let t2070 = max(min(t2077, 3999), 0)
   let t2069 = max(min(casted.min.0, 1999), 0)
   let t2073 = min(max(casted.min.0, 2000), t2076)
   let t2072 = min(max(casted.min.0, 0), t2076)
   let t2071 = ((casted.extent.1*2) + 1)*casted.extent.0
   let t2068 = (upsampled_linear__1._1.extent_realized.s + 1)*upsampled_linear__1._0.extent_realized
   for (constant_exterior.s0._2, 0, 19) {
    let t2082 = constant_exterior.s0._2*t2071
    let t2081 = (constant_exterior.s0._2*t2068) - t2069
    let t2080 = t2079 - t2077
    for (constant_exterior.s0._1.rebased, 0, t2080) {
     let t2084 = (casted.extent.0*constant_exterior.s0._1.rebased) + t2082
     let t2083 = constant_exterior.s0._1.rebased + t2077
     for (constant_exterior.s0._0.rebased, 0, casted.extent.0) {
      let t1423 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t2084] = select(((2000 <= t1423) || (t1423 < 0)) || (t2083 < 0), 0, binary_op$3[max(min(t1423, 1999), 0) + (((max(t2083, 0) - t2070)*upsampled_linear__1._0.extent_realized) + t2081)])
     }
    }
    let t2096 = constant_exterior.s0._2*t2068
    let t2097 = constant_exterior.s0._2*t2071
    let t2098 = t2072 - casted.min.0
    let t2087 = t2096 - t2069
    let t2090 = t2079 - t2077
    let t2088 = t2079 - t2070
    let t2094 = t2076 - t2073
    let t2091 = t2073 - t2072
    let t2085 = t2066 - t2079
    let t2095 = (t2073 - casted.min.0) + t2097
    let t2092 = (t2072 - t2069) + t2096
    for (constant_exterior.s0._1.rebased, 0, t2085) {
     let t2100 = ((constant_exterior.s0._1.rebased + t2090)*casted.extent.0) + t2097
     let t2099 = ((constant_exterior.s0._1.rebased + t2088)*upsampled_linear__1._0.extent_realized) + t2087
     for (constant_exterior.s0._0.rebased, 0, t2098) {
      let t1425 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t2100] = select(t1425 < 0, 0, binary_op$3[max(t1425, 0) + t2099])
     }
     let t2102 = ((constant_exterior.s0._1.rebased + t2090)*casted.extent.0) + (t2097 + t2098)
     let t2101 = ((constant_exterior.s0._1.rebased + t2088)*upsampled_linear__1._0.extent_realized) + t2092
     for (constant_exterior.s0._0.rebased, 0, t2091) {
      constant_exterior[constant_exterior.s0._0.rebased + t2102] = binary_op$3[constant_exterior.s0._0.rebased + t2101]
     }
     let t2104 = ((constant_exterior.s0._1.rebased + t2090)*casted.extent.0) + t2095
     let t2103 = ((constant_exterior.s0._1.rebased + t2088)*upsampled_linear__1._0.extent_realized) + t2087
     for (constant_exterior.s0._0.rebased, 0, t2094) {
      let t1426 = constant_exterior.s0._0.rebased + t2073
      constant_exterior[constant_exterior.s0._0.rebased + t2104] = select(t1426 < 2000, binary_op$3[max(min(t1426, 1999), 0) + t2103], 0)
     }
    }
    let t2107 = constant_exterior.s0._2*t2071
    let t2106 = (constant_exterior.s0._2*t2068) - t2069
    let t2105 = t2078 - t2066
    let t2108 = t2066 - t2077
    for (constant_exterior.s0._1.rebased, 0, t2105 + 1) {
     let t2110 = ((constant_exterior.s0._1.rebased + t2108)*casted.extent.0) + t2107
     let t2109 = constant_exterior.s0._1.rebased + t2066
     for (constant_exterior.s0._0.rebased, 0, casted.extent.0) {
      let t1427 = casted.min.0 + constant_exterior.s0._0.rebased
      constant_exterior[constant_exterior.s0._0.rebased + t2110] = select(((2000 <= t1427) || (t1427 < 0)) || (4000 <= t2109), 0, binary_op$3[max(min(t1427, 1999), 0) + (((max(min(t2109, 3999), 0) - t2070)*upsampled_linear__1._0.extent_realized) + t2106)])
     }
    }
   }
  }
 }
 free binary_op$3
 allocate sliced[int32 * casted.extent.0 * (casted.extent.1 + 1) * 1]
 produce sliced {
  consume constant_exterior {
   consume conv2D_w__0_1 {
    let t2113 = min(casted.min.0, 1999)
    let t2111 = ((casted.extent.1*2) + 1)*casted.extent.0
    let t2112 = ((conv2D_w__0_1.s0._1.max - conv2D_w__0_1.s0._1.min) + 1)*conv2D_w__0_1._0.extent_realized
    let t2114 = casted.min.1 - conv2D_w__0_1.s0._1.min
    for (sliced.s0._1.rebased, 0, casted.extent.1 + 1) {
     let t2118 = casted.extent.0*sliced.s0._1.rebased
     let t2116 = (sliced.s0._1.rebased + t2114)*conv2D_w__0_1._0.extent_realized
     for (sliced.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$4[int32 * 1]
      produce all_r$4 {
       all_r$4[0] = 0
       let t2119 = (t2118*2) + sliced.s0._0.rebased
       for (all_r$4.s1.r270$x, 0, 19) {
        all_r$4[0] = all_r$4[0] + (constant_exterior[(all_r$4.s1.r270$x*t2111) + t2119]*((all_r$4.s1.r270$x*19) + 20))
       }
      }
      consume all_r$4 {
       sliced[sliced.s0._0.rebased + t2118] = conv2D_w__0_1[((((max(min(all_r$4[0], 18), 0)*t2112) + casted.min.0) - t2113) + t2116) + sliced.s0._0.rebased]
      }
      free all_r$4
     }
    }
   }
  }
 }
 free conv2D_w__0_1
 free constant_exterior
 allocate upsampled_nn__1$1[int32 * casted.extent.0 * (casted.extent.1*8) * 1]
 produce upsampled_nn__1$1 {
  consume sliced {
   let t2120 = casted.extent.1*8
   for (upsampled_nn__1$1.s0._1.rebased, 0, t2120) {
    let t2121 = ((upsampled_nn__1$1.s0._1.rebased + 1)/8)*casted.extent.0
    let t2122 = casted.extent.0*upsampled_nn__1$1.s0._1.rebased
    for (upsampled_nn__1$1.s0._0.rebased, 0, casted.extent.0) {
     upsampled_nn__1$1[t2122 + upsampled_nn__1$1.s0._0.rebased] = sliced[t2121 + upsampled_nn__1$1.s0._0.rebased]
    }
   }
  }
 }
 free sliced
 produce casted {
  consume upsampled_nn__1$1 {
   let t2130 = 0 - ((casted.min.2*casted.stride.2) + (casted.min.1*casted.stride.1))
   for (casted.s0._2.rebased, 0, casted.extent.2) {
    let t2140 = casted.min.2 + casted.s0._2.rebased
    let t2139 = (casted.stride.2*t2140) + t2130
    for (casted.s0._1.rebased, 0, casted.extent.1) {
     let t2141 = ((casted.s0._1.rebased*8) + -1)*casted.extent.0
     let t2149 = ((casted.min.1 + casted.s0._1.rebased)*casted.stride.1) + t2139
     for (casted.s0._0.rebased, 0, casted.extent.0) {
      allocate all_r$5[int32 * 1]
      produce all_r$5 {
       all_r$5[0] = 0
       all_r$5[0] = all_r$5[0] + ((upsampled_nn__1$1[((casted.extent.0*2) + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[(casted.extent.0 + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[((casted.extent.0*3) + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[((casted.extent.0*4) + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[((casted.extent.0*5) + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[((casted.extent.0*6) + t2141) + casted.s0._0.rebased] + (upsampled_nn__1$1[((casted.extent.0*8) + t2141) + casted.s0._0.rebased] + upsampled_nn__1$1[((casted.extent.0*7) + t2141) + casted.s0._0.rebased])))))))*(t2140 + 2))
      }
      consume all_r$5 {
       casted[casted.s0._0.rebased + t2149] = all_r$5[0]
      }
      free all_r$5
     }
    }
   }
  }
 }
 free upsampled_nn__1$1
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function random_pipeline...
Generating llvm bitcode for function random_pipeline...
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.0*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.1*2) + -2) != 0)
Failed to prove, but could not find a counter-example:
 (v0 != 1)
Original expression:
(((input.extent.2*2) + -2) != 0)
add_temp_object_file: /tmp/FHhNR6/random_pipeline.a.o
Module.compile(): temporary object /tmp/FHhNR6/random_pipeline.a.o
emit_file.Compiling to native code...
Module.compile(): static_library /home/chamika2/upstream/halide-data/build/samples/batch_50091_0/random_pipeline.a
file_unlink: /tmp/FHhNR6/random_pipeline.a.o
dir_rmdir: /tmp/FHhNR6
Module.compile(): c_header /home/chamika2/upstream/halide-data/build/samples/batch_50091_0/random_pipeline.h
Module.compile(): registration /home/chamika2/upstream/halide-data/build/samples/batch_50091_0/random_pipeline.registration.cpp
